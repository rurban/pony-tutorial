{
    "docs": [
        {
            "location": "/", 
            "text": "Pony tutorial\n\n\nWelcome to the Pony tutorial! If you're reading this, chances are you want to learn Pony. That's great, we're going to make that happen.\n\n\nThis tutorial is aimed at people who have some experience programming already. It doesn't really matter if you know a little Python, or a bit of Ruby, or you are a JavaScript hacker, or Java, or Scala, or C/C++, or Haskell, or OCaml: as long as you've written some code before, you should be fine.\n\n\nMore help\n\n\nIf you need more help than this tutorial gives you, you can always write to the developer's \nmailing list\n, or \nopen an issue\n. Whatever your question is, it isn't dumb, and we won't get annoyed.\n\n\nWhat's Pony, anyway?\n\n\nPony is an object-oriented, actor-model, capabilities-secure programming language. It's \nobject-oriented\n because it has classes and objects, like Python, Java, C++, and many other languages. It's \nactor-model\n because it has \nactors\n (similar to Erlang or Akka). These behave like objects, but they can also execute code \nasynchronously\n. Actors make Pony awesome. \n\n\nWhen we say Pony is \ncapabilities-secure\n, we mean a few things:\n\n\n\n\nIt's type safe. Really type safe. There's a mathematical proof and everything.\n\n\nIt's memory safe. Ok, this comes with type safe, but it's still interesting. There are no dangling pointers, no buffer overruns, heck, the language doesn't even have the concept of \nnull\n!\n\n\nIt's exception safe. There are no runtime exceptions. All exceptions have defined semantics, and they are \nalways\n handled.\n\n\nIt's data-race free. Pony doesn't have locks or atomic operations or anything like that. Instead, the type system ensures \nat compile time\n that your concurrent program can never have data races. So you can write highly concurrent code and never get it wrong.\n\n\nIt's deadlock free. This one is easy, because Pony has no locks at all! So they definitely don't deadlock, because they don't exist.\n\n\n\n\nWe'll talk more about capabilities-security, including both \nobject capabilities\n and \nreference capabilities\n later.", 
            "title": "Welcome!"
        }, 
        {
            "location": "/#pony-tutorial", 
            "text": "Welcome to the Pony tutorial! If you're reading this, chances are you want to learn Pony. That's great, we're going to make that happen.  This tutorial is aimed at people who have some experience programming already. It doesn't really matter if you know a little Python, or a bit of Ruby, or you are a JavaScript hacker, or Java, or Scala, or C/C++, or Haskell, or OCaml: as long as you've written some code before, you should be fine.", 
            "title": "Pony tutorial"
        }, 
        {
            "location": "/#more-help", 
            "text": "If you need more help than this tutorial gives you, you can always write to the developer's  mailing list , or  open an issue . Whatever your question is, it isn't dumb, and we won't get annoyed.", 
            "title": "More help"
        }, 
        {
            "location": "/#whats-pony-anyway", 
            "text": "Pony is an object-oriented, actor-model, capabilities-secure programming language. It's  object-oriented  because it has classes and objects, like Python, Java, C++, and many other languages. It's  actor-model  because it has  actors  (similar to Erlang or Akka). These behave like objects, but they can also execute code  asynchronously . Actors make Pony awesome.   When we say Pony is  capabilities-secure , we mean a few things:   It's type safe. Really type safe. There's a mathematical proof and everything.  It's memory safe. Ok, this comes with type safe, but it's still interesting. There are no dangling pointers, no buffer overruns, heck, the language doesn't even have the concept of  null !  It's exception safe. There are no runtime exceptions. All exceptions have defined semantics, and they are  always  handled.  It's data-race free. Pony doesn't have locks or atomic operations or anything like that. Instead, the type system ensures  at compile time  that your concurrent program can never have data races. So you can write highly concurrent code and never get it wrong.  It's deadlock free. This one is easy, because Pony has no locks at all! So they definitely don't deadlock, because they don't exist.   We'll talk more about capabilities-security, including both  object capabilities  and  reference capabilities  later.", 
            "title": "What's Pony, anyway?"
        }, 
        {
            "location": "/getting-started/what-you-need-to-start/", 
            "text": "To get started, you'll need a text editor and the \nponyc\n compiler. That's it.\n\n\nA text editor\n\n\nWhile you can write code using any editor, it's nice to use one with some support for the language. Here are some:\n\n\n\n\nSublime Text\n. There's a \nPony Language\n package.\n\n\nAtom\n. There's a \nlanguage-pony\n package.\n\n\nEmacs\n. There's a \nponylang-mode\n. \nM-x package-install ponylang\n\n\nVim\n. There's a \npony-vim-syntax\n plugin. Install \npony\n with \nvim-plug\n or \npathogen\n.\n\n\nMicrosoft Visual Studio\n. There's a \nVS-pony\n plugin.\n\n\nBBEdit\n. There's a \nbbedit-pony\n module.\n\n\n\n\nIf you have a favourite editor that isn't supported, we'd love to help you build a Pony package for it.\n\n\nThe compiler\n\n\nPony is a \ncompiled\n language, rather than an \ninterpreted\n one. In fact, it goes even further: Pony is an \nahead-of-time\n (AOT) compiled language, rather than a \njust-in-time\n (JIT) compiled language.\n\n\nWhat this means is that once you build your program, you can run it over and over again without needing a compiler or a virtual machine or anything else. It's a complete program, all on its own.\n\n\nBut it also means you need to build your program before you can run it. In an interpreted language or a JIT compiled language, you tend to do things like this to run your program:\n\n\n$ python helloworld.py\n\n\n\n\nOr maybe you put a \nshebang\n in your program (like \n#!/usr/bin/env python\n), then \nchmod\n to set the executable bit, and then do:\n\n\n$ ./helloworld.py\n\n\n\n\nWhen you use Pony, you don't do any of that!\n\n\nCompiling your program\n\n\nIf you are in the same directory as your program, you can just do:\n\n\n$ ponyc\n\n\n\n\nThat tells the Pony compiler that your current working directory contains your source code, and to please compile it. If your source code is in some other directory, you can tell ponyc where it is:\n\n\n$ ponyc path/to/my/code\n\n\n\n\nThere are other options as well, but we'll cover those later.", 
            "title": "What you need to start"
        }, 
        {
            "location": "/getting-started/what-you-need-to-start/#a-text-editor", 
            "text": "While you can write code using any editor, it's nice to use one with some support for the language. Here are some:   Sublime Text . There's a  Pony Language  package.  Atom . There's a  language-pony  package.  Emacs . There's a  ponylang-mode .  M-x package-install ponylang  Vim . There's a  pony-vim-syntax  plugin. Install  pony  with  vim-plug  or  pathogen .  Microsoft Visual Studio . There's a  VS-pony  plugin.  BBEdit . There's a  bbedit-pony  module.   If you have a favourite editor that isn't supported, we'd love to help you build a Pony package for it.", 
            "title": "A text editor"
        }, 
        {
            "location": "/getting-started/what-you-need-to-start/#the-compiler", 
            "text": "Pony is a  compiled  language, rather than an  interpreted  one. In fact, it goes even further: Pony is an  ahead-of-time  (AOT) compiled language, rather than a  just-in-time  (JIT) compiled language.  What this means is that once you build your program, you can run it over and over again without needing a compiler or a virtual machine or anything else. It's a complete program, all on its own.  But it also means you need to build your program before you can run it. In an interpreted language or a JIT compiled language, you tend to do things like this to run your program:  $ python helloworld.py  Or maybe you put a  shebang  in your program (like  #!/usr/bin/env python ), then  chmod  to set the executable bit, and then do:  $ ./helloworld.py  When you use Pony, you don't do any of that!", 
            "title": "The compiler"
        }, 
        {
            "location": "/getting-started/what-you-need-to-start/#compiling-your-program", 
            "text": "If you are in the same directory as your program, you can just do:  $ ponyc  That tells the Pony compiler that your current working directory contains your source code, and to please compile it. If your source code is in some other directory, you can tell ponyc where it is:  $ ponyc path/to/my/code  There are other options as well, but we'll cover those later.", 
            "title": "Compiling your program"
        }, 
        {
            "location": "/getting-started/installation/", 
            "text": "Mac OSX\n\n\nFirst, install \nhomebrew\n if you haven't already.\n\n\nMake sure to have the newest \nbrew\n formulas from \nhomebrew:master\n:\n\n\n$ brew update\n\n\n\n\nThen, install ponyc:\n\n\n$ brew install ponyc\n\n\n\n\nLinux\n\n\nInstallers for various distributions to supply precompiled binaries are available. All linux installers are signed with the public key published \nhere\n.\n\n\nAvailable packages\n\n\n\n\nponyc\n: Recommended. Should work on most modern \nx86_64\n platforms.\n\n\nponyc-avx2\n: For platforms with AVX2 support.\n\n\n\n\nApt-get and Aptitude\n\n\nFirst, to avoid warnings about an untrusted repository, you can trust \nponylang.org\n:\n\n\n$ wget -O - http://releases.ponylang.org/buildbot@lists.ponylang.org.gpg.key | sudo apt-key add -\n\n\n\n\nOption 1:\n Install \npython-software-properties\n (Debian Wheezy and earlier, Ubuntu) or \nsoftware-properties-common\n (Debian Jessy and later) for \nadd-apt-repository\n. Then, add the ponylang.org repository:\n\n\n$ sudo add-apt-repository \ndeb http://releases.ponylang.org/apt ponyc main\n\n$ sudo add-apt-repository \ndeb http://releases.ponylang.org/apt ponyc-avx2 main\n\n\n\n\n\nOption 2\n: Manually add the following three lines to your \nsources.list\n (\n/etc/apt/sources.list\n on Ubuntu, and \n/etc/apt-get/sources.list\n on Debian):\n\n\ndeb http://releases.ponylang.org/apt ponyc main\ndeb http://releases.ponylang.org/apt ponyc-avx2 main\n\n\n\n\nThen, update your repository cache:\n\n\n$ sudo apt-get update\n\n\n\n\nInstall \nponyc\n or \nponyc-avx2\n\n\n$ sudo apt-get install \npackage name\n\n\n\n\n\nZypper\n\n\nFirst, add the ponylang.org repository:\n\n\n$ sudo zypper ar -f http://releases.ponylang.org/yum/ponyc.repo\n\n\n\n\nInstall \nponyc\n or \nponyc-avx2\n:\n\n\n$ sudo zypper install \npackage-name\n\n\n\n\n\nYUM\n\n\nFirst, add the ponylang.org repository:\n\n\n$ sudo yum-config-manager --add-repo=http://releases.ponylang.org/yum/ponyc.repo\n\n\n\n\nAlternatively\n, if \nyum-config-manager\n is not available on your system, you can add the repository manually:\n\n\n$  sudo wget -O /etc/yum.repos.d/ponyc.repo http://releases.ponylang.org/yum/ponyc.repo\n\n\n\n\nInstall \nponyc\n or \nponyc-avx2\n:\n\n\n$ sudo yum install \npackage-name\n\n\n\n\n\nGentoo\n\n\nlayman -a stefantalpalaru\nemerge dev-lang/pony\n\n\n\n\nWindows\n\n\n64-Bit installers for Windows 7, 8, 8.1 and 10 will be available soon.\n\n\nDid it work?\n\n\nRunning the following command should now display the installed version of \nponyc\n:\n\n\n$ ponyc --version\n0.1.7\n\n\n\n\nDownloads\n\n\nAll installers can also be downloaded from ponylang.org's servers:\n\n\n\n\nUbuntu/Debian\n\n\nRPM\n\n\nWindows", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/installation/#mac-osx", 
            "text": "First, install  homebrew  if you haven't already.  Make sure to have the newest  brew  formulas from  homebrew:master :  $ brew update  Then, install ponyc:  $ brew install ponyc", 
            "title": "Mac OSX"
        }, 
        {
            "location": "/getting-started/installation/#linux", 
            "text": "Installers for various distributions to supply precompiled binaries are available. All linux installers are signed with the public key published  here .", 
            "title": "Linux"
        }, 
        {
            "location": "/getting-started/installation/#available-packages", 
            "text": "ponyc : Recommended. Should work on most modern  x86_64  platforms.  ponyc-avx2 : For platforms with AVX2 support.", 
            "title": "Available packages"
        }, 
        {
            "location": "/getting-started/installation/#apt-get-and-aptitude", 
            "text": "First, to avoid warnings about an untrusted repository, you can trust  ponylang.org :  $ wget -O - http://releases.ponylang.org/buildbot@lists.ponylang.org.gpg.key | sudo apt-key add -  Option 1:  Install  python-software-properties  (Debian Wheezy and earlier, Ubuntu) or  software-properties-common  (Debian Jessy and later) for  add-apt-repository . Then, add the ponylang.org repository:  $ sudo add-apt-repository  deb http://releases.ponylang.org/apt ponyc main \n$ sudo add-apt-repository  deb http://releases.ponylang.org/apt ponyc-avx2 main   Option 2 : Manually add the following three lines to your  sources.list  ( /etc/apt/sources.list  on Ubuntu, and  /etc/apt-get/sources.list  on Debian):  deb http://releases.ponylang.org/apt ponyc main\ndeb http://releases.ponylang.org/apt ponyc-avx2 main  Then, update your repository cache:  $ sudo apt-get update  Install  ponyc  or  ponyc-avx2  $ sudo apt-get install  package name", 
            "title": "Apt-get and Aptitude"
        }, 
        {
            "location": "/getting-started/installation/#zypper", 
            "text": "First, add the ponylang.org repository:  $ sudo zypper ar -f http://releases.ponylang.org/yum/ponyc.repo  Install  ponyc  or  ponyc-avx2 :  $ sudo zypper install  package-name", 
            "title": "Zypper"
        }, 
        {
            "location": "/getting-started/installation/#yum", 
            "text": "First, add the ponylang.org repository:  $ sudo yum-config-manager --add-repo=http://releases.ponylang.org/yum/ponyc.repo  Alternatively , if  yum-config-manager  is not available on your system, you can add the repository manually:  $  sudo wget -O /etc/yum.repos.d/ponyc.repo http://releases.ponylang.org/yum/ponyc.repo  Install  ponyc  or  ponyc-avx2 :  $ sudo yum install  package-name", 
            "title": "YUM"
        }, 
        {
            "location": "/getting-started/installation/#gentoo", 
            "text": "layman -a stefantalpalaru\nemerge dev-lang/pony", 
            "title": "Gentoo"
        }, 
        {
            "location": "/getting-started/installation/#windows", 
            "text": "64-Bit installers for Windows 7, 8, 8.1 and 10 will be available soon.", 
            "title": "Windows"
        }, 
        {
            "location": "/getting-started/installation/#did-it-work", 
            "text": "Running the following command should now display the installed version of  ponyc :  $ ponyc --version\n0.1.7", 
            "title": "Did it work?"
        }, 
        {
            "location": "/getting-started/installation/#downloads", 
            "text": "All installers can also be downloaded from ponylang.org's servers:   Ubuntu/Debian  RPM  Windows", 
            "title": "Downloads"
        }, 
        {
            "location": "/getting-started/helloworld/", 
            "text": "Our first program will be a very traditional one. We're going to print \"Hello, world!\". First, create a directory called \nhelloworld\n:\n\n\n$ mkdir helloworld\n$ cd helloworld\n\n\n\n\nDoes the name of the directory matter?\n Yes, it does. It's the name of your program! When your program is compiled, the resulting executable binary will have the same name as the directory your program lives in.\n\n\nThe code\n\n\nThen, create a file in that directory called \nmain.pony\n. \n\n\nDoes the name of the file matter?\n Not to the compiler, no. Pony doesn't care about filenames other than that they end in \n.pony\n. But it might matter to you! By giving files good names, it can be easier to find the code you're looking for later.\n\n\nIn your file, put the following code:\n\n\nactor Main\n  new create(env: Env) =\n\n    env.out.print(\nHello, world!\n)\n\n\n\n\nCompiling the program\n\n\nNow compile it:\n\n\n$ ponyc\nBuilding .\nBuilding builtin\nGenerating\nOptimising\nWriting ./helloworld.o\nLinking ./helloworld\n\n\n\n\nLook at that! It built the current directory, \n.\n, plus the stuff that is built in to Pony, \nbuiltin\n, it generated some code, optimised it, created an object file (don't worry if you don't know what that is), and linked it into an executable with whatever libraries were needed. If you're a C/C++ programmer, that will all make sense to you, otherwise it probably won't, but that's ok, you can ignore it.\n\n\nWait, it linked too?\n Yes. You won't need a build system (like \nmake\n) for Pony. It handles that for you (including handling the order of dependencies when you link to C libraries, but we'll get to that later).\n\n\nRunning the program\n\n\nNow we can run the program:\n\n\n$ ./helloworld\nHello, world!\n\n\n\n\nCongratulations, you've written your first Pony program! Next, we'll explain what some of that code does.", 
            "title": "Helloworld"
        }, 
        {
            "location": "/getting-started/helloworld/#the-code", 
            "text": "Then, create a file in that directory called  main.pony .   Does the name of the file matter?  Not to the compiler, no. Pony doesn't care about filenames other than that they end in  .pony . But it might matter to you! By giving files good names, it can be easier to find the code you're looking for later.  In your file, put the following code:  actor Main\n  new create(env: Env) = \n    env.out.print( Hello, world! )", 
            "title": "The code"
        }, 
        {
            "location": "/getting-started/helloworld/#compiling-the-program", 
            "text": "Now compile it:  $ ponyc\nBuilding .\nBuilding builtin\nGenerating\nOptimising\nWriting ./helloworld.o\nLinking ./helloworld  Look at that! It built the current directory,  . , plus the stuff that is built in to Pony,  builtin , it generated some code, optimised it, created an object file (don't worry if you don't know what that is), and linked it into an executable with whatever libraries were needed. If you're a C/C++ programmer, that will all make sense to you, otherwise it probably won't, but that's ok, you can ignore it.  Wait, it linked too?  Yes. You won't need a build system (like  make ) for Pony. It handles that for you (including handling the order of dependencies when you link to C libraries, but we'll get to that later).", 
            "title": "Compiling the program"
        }, 
        {
            "location": "/getting-started/helloworld/#running-the-program", 
            "text": "Now we can run the program:  $ ./helloworld\nHello, world!  Congratulations, you've written your first Pony program! Next, we'll explain what some of that code does.", 
            "title": "Running the program"
        }, 
        {
            "location": "/getting-started/how-it-works/", 
            "text": "Let's look at our \nhelloworld\n code again:\n\n\nactor Main\n  new create(env: Env) =\n\n    env.out.print(\nHello, world!\n)\n\n\n\n\nLet's go through that line by line.\n\n\nLine 1\n\n\nactor Main\n\n\n\n\nThis is a \ntype declaration\n. The keyword \nactor\n means we are going to define an actor, which is a bit like a class in Python, Java, C#, C++, etc. Pony has classes too, which we'll see later.\n\n\nThe difference between an actor and a class is that an actor can have \nasynchronous\n methods, called \nbehaviours\n. We'll talk more about that later.\n\n\nA Pony program has to have a \nMain\n actor. It's kind of like the \nmain\n function in C or C++, or the \nmain\n method in Java, or the \nMain\n method in C#. It's where the action starts.\n\n\nLine 2\n\n\n  new create(env: Env) =\n\n\n\n\n\nThis is a \nconstructor\n. The keyword \nnew\n means it's a function that creates a new instance of the type. In this case, it creates a new \nMain\n.\n\n\nUnlike other languages, constructors in Pony have names. That means there can be more than one way to construct an instance of a type. In this case, the name of the constructor is \ncreate\n.\n\n\nThe parameters of a function come next. In this case, our constructor has a single parameter called \nenv\n that is of the type \nEnv\n.\n\n\nIn Pony, the type of something always comes after its name, and is separated by a colon. In C, C++, Java or C#, you might say \nEnv env\n, but we do it the other way around (like Go, Pascal, and a bunch of other languages).\n\n\nIt turns out, our \nMain\n actor \nhas\n to have a constructor called \ncreate\n that takes a single parameter of type \nEnv\n. That's how all programs start! So the beginning of your program is essentially the body of that constructor.\n\n\nWait, what's the body?\n It's the code that comes after the \n=\n.\n\n\nLine 3\n\n\n    env.out.print(\nHello, world!\n)\n\n\n\n\nThis is your program! What the heck is it doing?\n\n\nIn Pony a dot is a either a field access or a method call, much like other languages. If the name after the dot has parentheses after it, it's a method call. Otherwise, it's a field access.\n\n\nSo here, we start with a reference to \nenv\n. We then lookup the field \nout\n on our object \nenv\n. As it happens, that field represents \nstdout\n, i.e. usually it means printing to your console. Then, we call the \nprint\n method on \nenv.out\n. The stuff inside the parentheses are the arguments to the function. In this case, we are passing a \nstring literal\n, i.e. the stuff in double quotes.\n\n\nIn Pony, string literals can be in double quotes, in which case they follow C/C++ style escaping (using stuff like \\n), or they can be in \"triple double\" quotes, like a Python triple quoted string, in which case they are considered raw data.\n\n\nWhat's an Env, anyway?\n It's the \"environment\" your program was invoked with. That means it has command line arguments, environment variables, \nstdin\n, \nstdout\n, and \nstderr\n. Pony has no global variables, so these things are explicitly passed to your program.\n\n\nThat's it!\n\n\nReally, that's it. The program begins by creating a \nMain\n actor, and in the constructor, we print \"Hello, world!\" to \nstdout\n.", 
            "title": "How it works"
        }, 
        {
            "location": "/getting-started/how-it-works/#line-1", 
            "text": "actor Main  This is a  type declaration . The keyword  actor  means we are going to define an actor, which is a bit like a class in Python, Java, C#, C++, etc. Pony has classes too, which we'll see later.  The difference between an actor and a class is that an actor can have  asynchronous  methods, called  behaviours . We'll talk more about that later.  A Pony program has to have a  Main  actor. It's kind of like the  main  function in C or C++, or the  main  method in Java, or the  Main  method in C#. It's where the action starts.", 
            "title": "Line 1"
        }, 
        {
            "location": "/getting-started/how-it-works/#line-2", 
            "text": "new create(env: Env) =   This is a  constructor . The keyword  new  means it's a function that creates a new instance of the type. In this case, it creates a new  Main .  Unlike other languages, constructors in Pony have names. That means there can be more than one way to construct an instance of a type. In this case, the name of the constructor is  create .  The parameters of a function come next. In this case, our constructor has a single parameter called  env  that is of the type  Env .  In Pony, the type of something always comes after its name, and is separated by a colon. In C, C++, Java or C#, you might say  Env env , but we do it the other way around (like Go, Pascal, and a bunch of other languages).  It turns out, our  Main  actor  has  to have a constructor called  create  that takes a single parameter of type  Env . That's how all programs start! So the beginning of your program is essentially the body of that constructor.  Wait, what's the body?  It's the code that comes after the  = .", 
            "title": "Line 2"
        }, 
        {
            "location": "/getting-started/how-it-works/#line-3", 
            "text": "env.out.print( Hello, world! )  This is your program! What the heck is it doing?  In Pony a dot is a either a field access or a method call, much like other languages. If the name after the dot has parentheses after it, it's a method call. Otherwise, it's a field access.  So here, we start with a reference to  env . We then lookup the field  out  on our object  env . As it happens, that field represents  stdout , i.e. usually it means printing to your console. Then, we call the  print  method on  env.out . The stuff inside the parentheses are the arguments to the function. In this case, we are passing a  string literal , i.e. the stuff in double quotes.  In Pony, string literals can be in double quotes, in which case they follow C/C++ style escaping (using stuff like \\n), or they can be in \"triple double\" quotes, like a Python triple quoted string, in which case they are considered raw data.  What's an Env, anyway?  It's the \"environment\" your program was invoked with. That means it has command line arguments, environment variables,  stdin ,  stdout , and  stderr . Pony has no global variables, so these things are explicitly passed to your program.", 
            "title": "Line 3"
        }, 
        {
            "location": "/getting-started/how-it-works/#thats-it", 
            "text": "Really, that's it. The program begins by creating a  Main  actor, and in the constructor, we print \"Hello, world!\" to  stdout .", 
            "title": "That's it!"
        }, 
        {
            "location": "/getting-started/whitespace/", 
            "text": "Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn't significant.\n\n\nWell, it mostly isn't significant.\n\n\nMostly insignificant whitespace\n\n\nPony reads a bit like Python, which is a \nwhitespace significant\n language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\n\n\nThat means Pony programmers can format their code in whatever way suits them.\n\n\nThere are three exceptions:\n\n\n\n\nA \n-\n at the beginning of a line starts a new expression (unary negation), whereas a \n-\n in the middle of an expression is a binary operator (subtraction).\n\n\nA \n(\n at the beginning of a line starts a new expression (a tuple), whereas a \n(\n in the middle of an expression is a method call.\n\n\nA \n[\n at the beginning of a line starts a new expression (an array literal), whereas a \n[\n in the middle of an expression is generic formal parameters.\n\n\n\n\nThat stuff may seem a little esoteric right now, but we'll explain it all later. The \n-\n part should make sense though.\n\n\na - b\n\n\n\n\nThat means \"subtract b from a\".\n\n\na\n-b\n\n\n\n\nThat means \"first do a, then, in a new expression, do a unary negation of b\".\n\n\nSemicolons\n\n\nIn Pony, you don't end an expression with a \n;\n, unlike C, C++, Java, C#, etc. In fact, you don't need to end it at all! The compiler knows when an expression has finished, like Python or Ruby.\n\n\nHowever, sometimes it's convenient to put more than one expression on the same line. When you want to do that, you \nmust\n separate them with a \n;\n.\n\n\nWhy? Can't the compiler tell an expression has finished?\n Yes, it can. The compiler doesn't really need the \n;\n. However, it turns out the programmer does! By requiring a \n;\n between expressions on the same line, the compiler can catch some pretty common syntax errors for you.\n\n\nDocstrings\n\n\nIncluding documentation in your code makes you awesome. If you do it, everyone will love you.\n\n\nPony makes it easy by allowing you to put a \ndocstring\n on every type and on every method. Just put a string literal right after declaring the type, or right after the \n=\n of a method, before writing the body. The compiler will know what to do with them.\n\n\nFor traits and interfaces that have methods without bodies, you can put the docstring after the method declaration, even though there is no \n=\n.\n\n\nBy convention, a docstring should be a triple-quoted string, and it should use Markdown for any formatting.\n\n\nComments\n\n\nUse \ndocstrings\n first! But if you need to put some comments in the implementation of your methods, perhaps to explain what's happening on various lines, you can use C++ style comments. In Pony, block comments can be nested.\n\n\n// This is a line comment.\n/* This is a block comment. */\n/* This block comment /* has another block comment */ inside of it. */", 
            "title": "Whitespace"
        }, 
        {
            "location": "/getting-started/whitespace/#mostly-insignificant-whitespace", 
            "text": "Pony reads a bit like Python, which is a  whitespace significant  language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.  That means Pony programmers can format their code in whatever way suits them.  There are three exceptions:   A  -  at the beginning of a line starts a new expression (unary negation), whereas a  -  in the middle of an expression is a binary operator (subtraction).  A  (  at the beginning of a line starts a new expression (a tuple), whereas a  (  in the middle of an expression is a method call.  A  [  at the beginning of a line starts a new expression (an array literal), whereas a  [  in the middle of an expression is generic formal parameters.   That stuff may seem a little esoteric right now, but we'll explain it all later. The  -  part should make sense though.  a - b  That means \"subtract b from a\".  a\n-b  That means \"first do a, then, in a new expression, do a unary negation of b\".", 
            "title": "Mostly insignificant whitespace"
        }, 
        {
            "location": "/getting-started/whitespace/#semicolons", 
            "text": "In Pony, you don't end an expression with a  ; , unlike C, C++, Java, C#, etc. In fact, you don't need to end it at all! The compiler knows when an expression has finished, like Python or Ruby.  However, sometimes it's convenient to put more than one expression on the same line. When you want to do that, you  must  separate them with a  ; .  Why? Can't the compiler tell an expression has finished?  Yes, it can. The compiler doesn't really need the  ; . However, it turns out the programmer does! By requiring a  ;  between expressions on the same line, the compiler can catch some pretty common syntax errors for you.", 
            "title": "Semicolons"
        }, 
        {
            "location": "/getting-started/whitespace/#docstrings", 
            "text": "Including documentation in your code makes you awesome. If you do it, everyone will love you.  Pony makes it easy by allowing you to put a  docstring  on every type and on every method. Just put a string literal right after declaring the type, or right after the  =  of a method, before writing the body. The compiler will know what to do with them.  For traits and interfaces that have methods without bodies, you can put the docstring after the method declaration, even though there is no  = .  By convention, a docstring should be a triple-quoted string, and it should use Markdown for any formatting.", 
            "title": "Docstrings"
        }, 
        {
            "location": "/getting-started/whitespace/#comments", 
            "text": "Use  docstrings  first! But if you need to put some comments in the implementation of your methods, perhaps to explain what's happening on various lines, you can use C++ style comments. In Pony, block comments can be nested.  // This is a line comment.\n/* This is a block comment. */\n/* This block comment /* has another block comment */ inside of it. */", 
            "title": "Comments"
        }, 
        {
            "location": "/types/static-vs-dynamic/", 
            "text": "Pony is a \nstatically typed\n language, like Java, C#, C++, and many others. This means the compiler knows the type of everything in your program. This is different from \ndynamically typed\n languages, such as Python, Lua, JavaScript, and Ruby.\n\n\nWhat's the difference?\n\n\nIn both kinds of language, your data has a type. So what's the difference?\n\n\nWith a \ndynamically typed\n language, a variable can point to objects of different types at different times. This is flexible, because if you have a variable \nx\n, you can assign an integer to it, then assign a string to it, and your compiler or interpreter doesn't complain.\n\n\nBut what if I try to do a string operation on \nx\n after assigning an integer to it?\n Generally speaking, your program will raise an error. You might be able to handle the error in some way, depending on the language, but if you don't, your program will crash.\n\n\nWhen you use a \nstatically typed\n language, a variable has a type. That is, it can only point to objects of a certain type (although in Pony, a type can actually be a collection of types, as we'll see later). If you have an \nx\n that expects to point to an integer, you can't assign a string to it. Your compiler complains, and it complains \nbefore\n you ever try to run your program.\n\n\nTypes are guarantees\n\n\nWhen the compiler knows what types things are, it can make sure some things in your program work without you having to run it or test it. These things are the \nguarantees\n that a language's type system provides.\n\n\nThe more powerful a type system is, the more things it can prove about your program without having to run it.\n\n\nDo dynamic types make guarantees too?\n Yes, but they do it at runtime. For example, if you call a method that doesn't exist, you will usually get some kind of exception. But you'll only find out when you try to run your program.\n\n\nWhat guarantees does Pony's type system give me?\n\n\nThe Pony type system offers a lot of guarantees, even more than other statically typed languages.\n\n\n\n\nIf your program compiles, it won't crash.\n\n\nThere will never be an unhandled exception.\n\n\nThere's no such thing as \nnull\n, so your program will never try to dereference \nnull\n.\n\n\nThere will never be a data race.\n\n\nYour program will never deadlock.\n\n\nYour code will always be capabilities-secure.\n\n\nAll message passing is causal.\n\n\n\n\nSome of those will make sense right now. Some of them may not mean much to you yet (like capabilities-security and causal messaging), but we'll get to those concepts later on.\n\n\nIf I use Pony's FFI to call code written in another language, does Pony magically make the same guarantees for the code I call?\n Sadly, no. Pony's type system guarantees only apply to code written in Pony. Code written in other languages gets only the guarantees provided by that language.", 
            "title": "Static vs dynamic"
        }, 
        {
            "location": "/types/static-vs-dynamic/#whats-the-difference", 
            "text": "In both kinds of language, your data has a type. So what's the difference?  With a  dynamically typed  language, a variable can point to objects of different types at different times. This is flexible, because if you have a variable  x , you can assign an integer to it, then assign a string to it, and your compiler or interpreter doesn't complain.  But what if I try to do a string operation on  x  after assigning an integer to it?  Generally speaking, your program will raise an error. You might be able to handle the error in some way, depending on the language, but if you don't, your program will crash.  When you use a  statically typed  language, a variable has a type. That is, it can only point to objects of a certain type (although in Pony, a type can actually be a collection of types, as we'll see later). If you have an  x  that expects to point to an integer, you can't assign a string to it. Your compiler complains, and it complains  before  you ever try to run your program.", 
            "title": "What's the difference?"
        }, 
        {
            "location": "/types/static-vs-dynamic/#types-are-guarantees", 
            "text": "When the compiler knows what types things are, it can make sure some things in your program work without you having to run it or test it. These things are the  guarantees  that a language's type system provides.  The more powerful a type system is, the more things it can prove about your program without having to run it.  Do dynamic types make guarantees too?  Yes, but they do it at runtime. For example, if you call a method that doesn't exist, you will usually get some kind of exception. But you'll only find out when you try to run your program.", 
            "title": "Types are guarantees"
        }, 
        {
            "location": "/types/static-vs-dynamic/#what-guarantees-does-ponys-type-system-give-me", 
            "text": "The Pony type system offers a lot of guarantees, even more than other statically typed languages.   If your program compiles, it won't crash.  There will never be an unhandled exception.  There's no such thing as  null , so your program will never try to dereference  null .  There will never be a data race.  Your program will never deadlock.  Your code will always be capabilities-secure.  All message passing is causal.   Some of those will make sense right now. Some of them may not mean much to you yet (like capabilities-security and causal messaging), but we'll get to those concepts later on.  If I use Pony's FFI to call code written in another language, does Pony magically make the same guarantees for the code I call?  Sadly, no. Pony's type system guarantees only apply to code written in Pony. Code written in other languages gets only the guarantees provided by that language.", 
            "title": "What guarantees does Pony's type system give me?"
        }, 
        {
            "location": "/types/classes/", 
            "text": "Just like other object-oriented languages, Pony has \nclasses\n. A class is declared with the keyword \nclass\n, and it has to have a name that starts with a capital letter, like this:\n\n\nclass Wombat\n\n\n\n\nDo all types start with a capital letter?\n Yes! And nothing else starts with a capital letter. So when you see a name in Pony code, you will instantly know whether it's a type or not.\n\n\nWhat goes in a class?\n\n\nA class is composed of:\n\n\n\n\nFields.\n\n\nConstructors.\n\n\nFunctions.\n\n\n\n\nFields\n\n\nThese are just like fields in C structs or fields in classes in C++, C#, Java, Python, Ruby, or basically any language, really. There are two kinds of fields: var fields and let fields. A var field can be assigned to over and over again, but a let field is assigned to in the constructor and never again.\n\n\nclass Wombat\n  let name: String\n  var _hunger_level: U64\n\n\n\n\nHere, a \nWombat\n has a \nname\n, which is a \nString\n, and a \n_hunger_level\n, which is a \nU64\n (an unsigned 64 bit integer).\n\n\nWhat does the leading underscore mean?\n It means something is \nprivate\n. A \nprivate\n field can only be accessed by code in the same type. A \nprivate\n constructor, function, or behaviour can only be accessed by code in the same package. We'll talk more about packages later.\n\n\nConstructors\n\n\nPony constructors have names. Other than that, they are just like constructors in other languages. They can have parameters, and they always return a new instance of the type. Since they have names, you can have more than one constructor for a type.\n\n\nConstructors are introduced with the \nnew\n keyword.\n\n\nclass Wombat\n  let name: String\n  var _hunger_level: U64\n\n  new create(name': String) =\n\n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) =\n\n    name = name'\n    _hunger_level = hunger'\n\n\n\n\nHere, we have two constructors, one that creates a \nWombat\n that isn't hungry, and another that creates a \nWombat\n that might be hungry or might not.\n\n\nWhat's with the single quote thing, i.e. name'?\n You can use single quotes in parameter and local variable names. In mathematics, it's called a \nprime\n, and it's used to say \"another one of these, but not the same one\". Basically, it's just convenient.\n\n\nEverything has to get set in a constructor\n\n\nEvery constructor has to set every field in an object. If it doesn't, the compiler will give you an error. Since there is no \nnull\n in Pony, we can't do what Java, C# and many other languages do and just assign either \nnull\n or zero to every field before the constructor runs, and since we don't want random crashes, we don't leave fields undefined (unlike C or C++).\n\n\nField initialisers\n\n\nSometimes it's convenient to set a field the same way for all constructors.\n\n\nclass Wombat\n  let name: String\n  var _hunger_level: U64\n  var _thirst_level: U64 = 1\n\n  new create(name': String) =\n\n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) =\n\n    name = name'\n    _hunger_level = hunger'\n\n\n\n\nHere, every \nWombat\n begins a little bit thirsty, regardless of which constructor is called.\n\n\nFunctions\n\n\nFunctions in Pony are like methods in Java, C#, C++, Ruby, Python, or pretty much any other object oriented language. They are introduced with the keyword \nfun\n. They can have parameters, like constructors do, and they can also have a result type (if no result type is given, it defaults to \nNone\n).\n\n\nclass Wombat\n  let name: String\n  var _hunger_level: U64\n  var _thirst_level: U64 = 1\n\n  new create(name': String) =\n\n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) =\n\n    name = name'\n    _hunger_level = hunger'\n\n  fun hunger(): U64 =\n _hunger_level\n\n  fun ref set_hunger(to: U64 = 0): U64 =\n _hunger_level = to\n\n\n\n\nThe first function, \nhunger\n, is pretty straight forward. It has a result type of \nU64\n, and it returns \n_hunger_level\n, which is a \nU64\n. The only thing a bit different here is that no \nreturn\n keyword is used. This is because the result of a function is the result of the last expression in the function, in this case the value of \n_hunger_level\n.\n\n\nIs there a \nreturn\n keyword in Pony?\n Yes. It's used to return \"early\" from a function, i.e. to return something right away and not keep running until the last expression.\n\n\nThe second function, \nset_hunger\n, introduces a \nbunch\n of new concepts all at once. Let's go through them one by one.\n\n\nThe \nref\n keyword right after \nfun\n\n\nThis is a \nreference capability\n. In this case, it means the \nreceiver\n, i.e. the object on which the \nset_hunger\n function is being called, has to be a \nref\n type. A \nref\n type is a \nreference type\n, meaning that the object is \nmutable\n. We need this because we are writing a new value to the \n_hunger_level\n field.\n\n\nWhat's the receiver reference capability of the \nhunger\n method?\n The default receiver reference capability if none is specified is \nbox\n, which means \"I need to be able to read from this, but I won't write to it\".\n\n\nWhat would happen if we left the \nref\n keyword off the \nset_hunger\n method?\n The compiler would give you an error. It would see you were trying to modify a field and complain about it.\n\n\nThe \n= 0\n after the parameter \nto\n\n\nThis is a \ndefault argument\n. It means that if you don't include that argument at the call site, you will get the default argument. In this case, \nto\n will be zero if you don't specify it.\n\n\nWhat does the function return?\n\n\nIt returns the \nold\n value of \n_hunger_level\n.\n\n\nWait, seriously? The \nold\n value?\n Yes. In Pony, assignment is an expression rather than a statement. That means it has a result. This is true of a lot of languages, but they tend to return the \nnew\n value. In other words, given \na = b\n, in most languages, the value of that is the value of \nb\n. But in Pony, the value of that is the \nold\n value of \na\n.\n\n\n...why?\n It's called a \"destructive read\", and it lets you do awesome things with a capabilities-secure type system. We'll talk about that more later. For now, we'll just mention that you can also use it to implement a \nswap\n operation. In most languages, to swap the values of \na\n and \nb\n you need to do something like:\n\n\nvar temp = a\na = b\nb = temp\n\n\n\n\nIn Pony, you can just do:\n\n\na = b = a\n\n\n\n\nWhat about inheritance?\n\n\nIn some object-oriented languages, a type can \ninherit\n from another type, like how in Java something can \nextend\n something else. Pony doesn't do that. Instead, Pony prefers \ncomposition\n to \ninheritance\n. In other words, instead of getting code reuse by saying something \nis\n something else, you get it by saying something \nhas\n something else.\n\n\nOn the other hand, Pony has a powerful \ntrait\n system (similar to Java 8 interfaces that can have default implementations) and a powerful \ninterface\n system (similar to Go interfaces, i.e. structurally typed).\n\n\nWe'll talk about all that stuff in detail later.", 
            "title": "Classes"
        }, 
        {
            "location": "/types/classes/#what-goes-in-a-class", 
            "text": "A class is composed of:   Fields.  Constructors.  Functions.", 
            "title": "What goes in a class?"
        }, 
        {
            "location": "/types/classes/#fields", 
            "text": "These are just like fields in C structs or fields in classes in C++, C#, Java, Python, Ruby, or basically any language, really. There are two kinds of fields: var fields and let fields. A var field can be assigned to over and over again, but a let field is assigned to in the constructor and never again.  class Wombat\n  let name: String\n  var _hunger_level: U64  Here, a  Wombat  has a  name , which is a  String , and a  _hunger_level , which is a  U64  (an unsigned 64 bit integer).  What does the leading underscore mean?  It means something is  private . A  private  field can only be accessed by code in the same type. A  private  constructor, function, or behaviour can only be accessed by code in the same package. We'll talk more about packages later.", 
            "title": "Fields"
        }, 
        {
            "location": "/types/classes/#constructors", 
            "text": "Pony constructors have names. Other than that, they are just like constructors in other languages. They can have parameters, and they always return a new instance of the type. Since they have names, you can have more than one constructor for a type.  Constructors are introduced with the  new  keyword.  class Wombat\n  let name: String\n  var _hunger_level: U64\n\n  new create(name': String) = \n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) = \n    name = name'\n    _hunger_level = hunger'  Here, we have two constructors, one that creates a  Wombat  that isn't hungry, and another that creates a  Wombat  that might be hungry or might not.  What's with the single quote thing, i.e. name'?  You can use single quotes in parameter and local variable names. In mathematics, it's called a  prime , and it's used to say \"another one of these, but not the same one\". Basically, it's just convenient.  Everything has to get set in a constructor  Every constructor has to set every field in an object. If it doesn't, the compiler will give you an error. Since there is no  null  in Pony, we can't do what Java, C# and many other languages do and just assign either  null  or zero to every field before the constructor runs, and since we don't want random crashes, we don't leave fields undefined (unlike C or C++).  Field initialisers  Sometimes it's convenient to set a field the same way for all constructors.  class Wombat\n  let name: String\n  var _hunger_level: U64\n  var _thirst_level: U64 = 1\n\n  new create(name': String) = \n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) = \n    name = name'\n    _hunger_level = hunger'  Here, every  Wombat  begins a little bit thirsty, regardless of which constructor is called.", 
            "title": "Constructors"
        }, 
        {
            "location": "/types/classes/#functions", 
            "text": "Functions in Pony are like methods in Java, C#, C++, Ruby, Python, or pretty much any other object oriented language. They are introduced with the keyword  fun . They can have parameters, like constructors do, and they can also have a result type (if no result type is given, it defaults to  None ).  class Wombat\n  let name: String\n  var _hunger_level: U64\n  var _thirst_level: U64 = 1\n\n  new create(name': String) = \n    name = name'\n    _hunger_level = 0\n\n  new hungry(name': String, hunger': U64) = \n    name = name'\n    _hunger_level = hunger'\n\n  fun hunger(): U64 =  _hunger_level\n\n  fun ref set_hunger(to: U64 = 0): U64 =  _hunger_level = to  The first function,  hunger , is pretty straight forward. It has a result type of  U64 , and it returns  _hunger_level , which is a  U64 . The only thing a bit different here is that no  return  keyword is used. This is because the result of a function is the result of the last expression in the function, in this case the value of  _hunger_level .  Is there a  return  keyword in Pony?  Yes. It's used to return \"early\" from a function, i.e. to return something right away and not keep running until the last expression.  The second function,  set_hunger , introduces a  bunch  of new concepts all at once. Let's go through them one by one.  The  ref  keyword right after  fun  This is a  reference capability . In this case, it means the  receiver , i.e. the object on which the  set_hunger  function is being called, has to be a  ref  type. A  ref  type is a  reference type , meaning that the object is  mutable . We need this because we are writing a new value to the  _hunger_level  field.  What's the receiver reference capability of the  hunger  method?  The default receiver reference capability if none is specified is  box , which means \"I need to be able to read from this, but I won't write to it\".  What would happen if we left the  ref  keyword off the  set_hunger  method?  The compiler would give you an error. It would see you were trying to modify a field and complain about it.  The  = 0  after the parameter  to  This is a  default argument . It means that if you don't include that argument at the call site, you will get the default argument. In this case,  to  will be zero if you don't specify it.  What does the function return?  It returns the  old  value of  _hunger_level .  Wait, seriously? The  old  value?  Yes. In Pony, assignment is an expression rather than a statement. That means it has a result. This is true of a lot of languages, but they tend to return the  new  value. In other words, given  a = b , in most languages, the value of that is the value of  b . But in Pony, the value of that is the  old  value of  a .  ...why?  It's called a \"destructive read\", and it lets you do awesome things with a capabilities-secure type system. We'll talk about that more later. For now, we'll just mention that you can also use it to implement a  swap  operation. In most languages, to swap the values of  a  and  b  you need to do something like:  var temp = a\na = b\nb = temp  In Pony, you can just do:  a = b = a", 
            "title": "Functions"
        }, 
        {
            "location": "/types/classes/#what-about-inheritance", 
            "text": "In some object-oriented languages, a type can  inherit  from another type, like how in Java something can  extend  something else. Pony doesn't do that. Instead, Pony prefers  composition  to  inheritance . In other words, instead of getting code reuse by saying something  is  something else, you get it by saying something  has  something else.  On the other hand, Pony has a powerful  trait  system (similar to Java 8 interfaces that can have default implementations) and a powerful  interface  system (similar to Go interfaces, i.e. structurally typed).  We'll talk about all that stuff in detail later.", 
            "title": "What about inheritance?"
        }, 
        {
            "location": "/types/primitives/", 
            "text": "A \nprimitive\n is similar to a \nclass\n, but there are two critical differences:\n\n\n\n\nA \nprimitive\n has no fields.\n\n\nThere is only one instance of a user-defined \nprimitive\n.\n\n\n\n\nHaving no fields means primitives are never mutable. Having a single instance means that if your code calls a constructor on a \nprimitive\n type, it always gets the same result back (except for built-in \"machine word\" primitives, covered below).\n\n\nWhat can you use a \nprimitive\n for?\n\n\nThere are three main uses of primitives (four, if you count built-in \"machine word\" primitives).\n\n\n\n\nAs a \"marker value\". For example, Pony often uses the \nprimitive\n \nNone\n to indicate that something has \"no value\". Of course, it \ndoes\n have a value, so that you can check what it is, and the value is the single instance of \nNone\n.\n\n\nAs an \"enumeration\" type. By having a \nunion\n of \nprimitive\n types, you can have a type-safe enumeration. We'll cover \nunion\n types later.\n\n\nAs a \"collection of functions\". Since primitives can have functions, you can group functions together in a primitive type. You can see this in the standard library, where path handling functions are grouped in the \nprimitive\n \nPath\n, for example.\n\n\n\n\nPrimitives are quite powerful, particularly as enumerations. Unlike enumerations in other languages, each \"value\" in the enumeration is a complete type, which makes attaching data and functionality to enumeration values easy.\n\n\nBuilt-in primitive types\n\n\nThe \nprimitive\n keyword is also used to introduce certain built-in \"machine word\" types. Other than having a value associated with them, these work like user-defined primitives. These are:\n\n\n\n\nBool\n. This is a 1-bit value that is either \ntrue\n or \nfalse\n.\n\n\nISize, ILong, I8, I16, I32, I64, I128\n. Signed integers of various widths.\n\n\nUSize, ULong, U8, U16, U32, U64, U128\n. Unsigned integers of various widths.\n\n\nF32, F64\n. Floating point numbers of various widths.", 
            "title": "Primitives"
        }, 
        {
            "location": "/types/primitives/#what-can-you-use-a-primitive-for", 
            "text": "There are three main uses of primitives (four, if you count built-in \"machine word\" primitives).   As a \"marker value\". For example, Pony often uses the  primitive   None  to indicate that something has \"no value\". Of course, it  does  have a value, so that you can check what it is, and the value is the single instance of  None .  As an \"enumeration\" type. By having a  union  of  primitive  types, you can have a type-safe enumeration. We'll cover  union  types later.  As a \"collection of functions\". Since primitives can have functions, you can group functions together in a primitive type. You can see this in the standard library, where path handling functions are grouped in the  primitive   Path , for example.   Primitives are quite powerful, particularly as enumerations. Unlike enumerations in other languages, each \"value\" in the enumeration is a complete type, which makes attaching data and functionality to enumeration values easy.", 
            "title": "What can you use a primitive for?"
        }, 
        {
            "location": "/types/primitives/#built-in-primitive-types", 
            "text": "The  primitive  keyword is also used to introduce certain built-in \"machine word\" types. Other than having a value associated with them, these work like user-defined primitives. These are:   Bool . This is a 1-bit value that is either  true  or  false .  ISize, ILong, I8, I16, I32, I64, I128 . Signed integers of various widths.  USize, ULong, U8, U16, U32, U64, U128 . Unsigned integers of various widths.  F32, F64 . Floating point numbers of various widths.", 
            "title": "Built-in primitive types"
        }, 
        {
            "location": "/types/actors/", 
            "text": "An \nactor\n is similar to a \nclass\n, but with one critical difference: an actor can have \nbehaviours\n.\n\n\nBehaviours\n\n\nA \nbehaviour\n is like a \nfunction\n, except that functions are \nsynchronous\n and behaviours are \nasynchronous\n. In other words, when you call a function, the body of the function is executed immediately, and the result of the call is the result of the body of the function. This is just like method invocation in any other object-oriented language.\n\n\nBut when you call a behaviour, the body is \nnot\n executed immediately. Instead, the body of the behaviour will execute at some indeterminate time in the future.\n\n\nA behaviour looks like a function, but instead of being introduced with the keyword \nfun\n, it is introduced with the keyword \nbe\n.\n\n\nLike a function, a behaviour can have parameters. Unlike a function, it doesn't have a receiver capability (a behaviour can be called on a receiver of any capability) and you can't specify a return type.\n\n\nSo what does a behaviour return?\n All behaviours always return the receiver. They can't return something they calculate (since they haven't run yet), so returning the receiver is a convenience to allow chaining calls on the receiver.\n\n\nactor Aardvark\n  let name: String\n  var _hunger_level: U64 = 0\n\n  new create(name': String) =\n\n    name = name'\n\n  be eat(amount: U64) =\n\n    _hunger_level = _hunger_level - amount.min(_hunger_level)\n\n\n\n\nHere we have an \nAardvark\n that can eat asynchronously. Clever Aardvark.\n\n\nConcurrent\n\n\nSince behaviours are asynchronous, it's ok to run the body of a bunch of behaviours at the same time. This is exactly what Pony does. The Pony runtime has its own scheduler, which by default has a number of threads equal to the number of CPU cores on your machine. Each scheduler thread can be executing an actor behaviour at any given time, so Pony programs are naturally concurrent.\n\n\nSequential\n\n\nActors themselves, however, are sequential. That is, each actor will only execute one behaviour at a time. This means all the code in an actor can be written without caring about concurrency: no need for locks or semaphores or anything like that.\n\n\nWhen you're writing Pony code, it's nice to think of actors not as a unit of parallelism, but as a unit of sequentiality. That is, an actor should do only what \nhas\n to be done sequentially. Anything else can be broken out into another actor, making it automatically parallel.\n\n\nWhy is this safe?\n\n\nBecause of Pony's \ncapabilities secure type system\n. We've mentioned reference capabilities briefly before, when talking about function receiver reference capabilities. The short version is that they are annotations on a type that make all this parallelism safe without any runtime overhead.\n\n\nWe will cover reference capabilities in depth later.\n\n\nActors are cheap\n\n\nIf you've done concurrent programming before, you'll know that threads can be expensive. Context switches can cause problems, each thread needs a stack (which can be a lot of memory), and you need lots of locks and other mechanisms to write thread-safe code.\n\n\nBut actors are cheap. Really cheap. The extra cost of an actor as opposed to an object is about 256 bytes of memory. Bytes, not kilobytes! And there are no locks and no context switches. An actor that isn't executing consumes no resources other than the few extra bytes of memory.\n\n\nIt's pretty normal to write a Pony program that uses hundreds of thousands of actors.", 
            "title": "Actors"
        }, 
        {
            "location": "/types/actors/#behaviours", 
            "text": "A  behaviour  is like a  function , except that functions are  synchronous  and behaviours are  asynchronous . In other words, when you call a function, the body of the function is executed immediately, and the result of the call is the result of the body of the function. This is just like method invocation in any other object-oriented language.  But when you call a behaviour, the body is  not  executed immediately. Instead, the body of the behaviour will execute at some indeterminate time in the future.  A behaviour looks like a function, but instead of being introduced with the keyword  fun , it is introduced with the keyword  be .  Like a function, a behaviour can have parameters. Unlike a function, it doesn't have a receiver capability (a behaviour can be called on a receiver of any capability) and you can't specify a return type.  So what does a behaviour return?  All behaviours always return the receiver. They can't return something they calculate (since they haven't run yet), so returning the receiver is a convenience to allow chaining calls on the receiver.  actor Aardvark\n  let name: String\n  var _hunger_level: U64 = 0\n\n  new create(name': String) = \n    name = name'\n\n  be eat(amount: U64) = \n    _hunger_level = _hunger_level - amount.min(_hunger_level)  Here we have an  Aardvark  that can eat asynchronously. Clever Aardvark.", 
            "title": "Behaviours"
        }, 
        {
            "location": "/types/actors/#concurrent", 
            "text": "Since behaviours are asynchronous, it's ok to run the body of a bunch of behaviours at the same time. This is exactly what Pony does. The Pony runtime has its own scheduler, which by default has a number of threads equal to the number of CPU cores on your machine. Each scheduler thread can be executing an actor behaviour at any given time, so Pony programs are naturally concurrent.", 
            "title": "Concurrent"
        }, 
        {
            "location": "/types/actors/#sequential", 
            "text": "Actors themselves, however, are sequential. That is, each actor will only execute one behaviour at a time. This means all the code in an actor can be written without caring about concurrency: no need for locks or semaphores or anything like that.  When you're writing Pony code, it's nice to think of actors not as a unit of parallelism, but as a unit of sequentiality. That is, an actor should do only what  has  to be done sequentially. Anything else can be broken out into another actor, making it automatically parallel.", 
            "title": "Sequential"
        }, 
        {
            "location": "/types/actors/#why-is-this-safe", 
            "text": "Because of Pony's  capabilities secure type system . We've mentioned reference capabilities briefly before, when talking about function receiver reference capabilities. The short version is that they are annotations on a type that make all this parallelism safe without any runtime overhead.  We will cover reference capabilities in depth later.", 
            "title": "Why is this safe?"
        }, 
        {
            "location": "/types/actors/#actors-are-cheap", 
            "text": "If you've done concurrent programming before, you'll know that threads can be expensive. Context switches can cause problems, each thread needs a stack (which can be a lot of memory), and you need lots of locks and other mechanisms to write thread-safe code.  But actors are cheap. Really cheap. The extra cost of an actor as opposed to an object is about 256 bytes of memory. Bytes, not kilobytes! And there are no locks and no context switches. An actor that isn't executing consumes no resources other than the few extra bytes of memory.  It's pretty normal to write a Pony program that uses hundreds of thousands of actors.", 
            "title": "Actors are cheap"
        }, 
        {
            "location": "/types/traits-and-interfaces/", 
            "text": "Like other object-oriented languages, Pony has \nsubtyping\n. That is, some types serve as \ncategories\n that other types can be members of.\n\n\nThere are two kinds of \nsubtyping\n in programming languages: \nnominal\n and \nstructural\n. They're subtly different, and most programming languages only have one or the other. Pony has both!\n\n\nNominal subtyping\n\n\nThis kind of subtyping is called \nnominal\n because it is all about \nnames\n.\n\n\nIf you've done object-oriented programming before, you may have seen a lot of discussion about \nsingle inheritance\n, \nmultiple inheritance\n, \nmixins\n, \ntraits\n, and similar concepts. These are all examples of \nnominal subtyping\n.\n\n\nThe core idea is that you have a type that declares it has a relationship to some category type. In Java, for example, a \nclass\n (a concrete type) can \nimplement\n an \ninterface\n (a category type). In Java, this means the class is now in the category that the interface represents. The compiler will check that the class actually provides everything it needs to.\n\n\nTraits\n\n\nPony has nominal subtyping, using \ntraits\n. A \ntrait\n looks a bit like a \nclass\n, but it uses the keyword \ntrait\n and it can't have any fields.\n\n\ntrait Named\n  fun name(): String =\n \nBob\n\n\nclass Bob is Named\n\n\n\n\nHere, we have a trait \nNamed\n that has a single function \nname\n that returns a String. It also provides a default implementation of \nname\n that returns the string literal \"Bob\".\n\n\nWe also have a class \nBob\n that says it \nis Named\n. This means \nBob\n is in the \nNamed\n category. In Pony, we say \nBob provides Named\n, or sometimes simply \nBob is Named\n.\n\n\nSince \nBob\n doesn't have its own \nname\n function, it uses the one from the trait. If the trait's function didn't have a default implementation, the compiler would complain that \nBob\n had no implementation of \nname\n.\n\n\nclass Larry\n  fun name(): String =\n \nLarry\n\n\n\n\n\nHere, we have a class \nLarry\n that has a \nname\n function with the same signature. But \nLarry\n does \nnot\n provide \nNamed\n!\n\n\nWait, why not?\n Because \nLarry\n doesn't say it \nis Named\n. Remember, traits are \nnominal\n: a type that wants to provide a trait has to explicitly declare that it does. And \nLarry\n doesn't.\n\n\nStructural subtyping\n\n\nThere's another kind of subtyping, where the name doesn't matter. It's called \nstructural subtyping\n, which means that it's all about how a type is built, and nothing to do with names.\n\n\nA concrete type is a member of a structural category if it happens to have all the needed elements, no matter what it happens to be called.\n\n\nIf you've used Go, you'll recognise that Go interfaces are structural types.\n\n\nInterfaces\n\n\nPony has structural subtyping too, using \ninterfaces\n. Interfaces look like traits, but they use the keyword \ninterface\n.\n\n\ninterface HasName\n  fun name(): String\n\n\n\n\nHere, \nHasName\n looks a lot like \nNamed\n, except it's an interface instead of a trait. This means both \nBob\n and \nLarry\n provide \nHasName\n! The programmers that wrote \nBob\n and \nLarry\n don't even have to be aware that \nHasName\n exists.\n\n\nPony interfaces can have functions with default implementations as well. A type will only pick those up if it explicitly declares that it \nis\n that interface.\n\n\nShould I use traits or interfaces in my own code?\n Both! Interfaces are more flexible, so if you're not sure what you want, use an interface. But traits are a powerful tool as well: they stop \naccidental subtyping\n.", 
            "title": "Traits and interfaces"
        }, 
        {
            "location": "/types/traits-and-interfaces/#nominal-subtyping", 
            "text": "This kind of subtyping is called  nominal  because it is all about  names .  If you've done object-oriented programming before, you may have seen a lot of discussion about  single inheritance ,  multiple inheritance ,  mixins ,  traits , and similar concepts. These are all examples of  nominal subtyping .  The core idea is that you have a type that declares it has a relationship to some category type. In Java, for example, a  class  (a concrete type) can  implement  an  interface  (a category type). In Java, this means the class is now in the category that the interface represents. The compiler will check that the class actually provides everything it needs to.", 
            "title": "Nominal subtyping"
        }, 
        {
            "location": "/types/traits-and-interfaces/#traits", 
            "text": "Pony has nominal subtyping, using  traits . A  trait  looks a bit like a  class , but it uses the keyword  trait  and it can't have any fields.  trait Named\n  fun name(): String =   Bob \n\nclass Bob is Named  Here, we have a trait  Named  that has a single function  name  that returns a String. It also provides a default implementation of  name  that returns the string literal \"Bob\".  We also have a class  Bob  that says it  is Named . This means  Bob  is in the  Named  category. In Pony, we say  Bob provides Named , or sometimes simply  Bob is Named .  Since  Bob  doesn't have its own  name  function, it uses the one from the trait. If the trait's function didn't have a default implementation, the compiler would complain that  Bob  had no implementation of  name .  class Larry\n  fun name(): String =   Larry   Here, we have a class  Larry  that has a  name  function with the same signature. But  Larry  does  not  provide  Named !  Wait, why not?  Because  Larry  doesn't say it  is Named . Remember, traits are  nominal : a type that wants to provide a trait has to explicitly declare that it does. And  Larry  doesn't.", 
            "title": "Traits"
        }, 
        {
            "location": "/types/traits-and-interfaces/#structural-subtyping", 
            "text": "There's another kind of subtyping, where the name doesn't matter. It's called  structural subtyping , which means that it's all about how a type is built, and nothing to do with names.  A concrete type is a member of a structural category if it happens to have all the needed elements, no matter what it happens to be called.  If you've used Go, you'll recognise that Go interfaces are structural types.", 
            "title": "Structural subtyping"
        }, 
        {
            "location": "/types/traits-and-interfaces/#interfaces", 
            "text": "Pony has structural subtyping too, using  interfaces . Interfaces look like traits, but they use the keyword  interface .  interface HasName\n  fun name(): String  Here,  HasName  looks a lot like  Named , except it's an interface instead of a trait. This means both  Bob  and  Larry  provide  HasName ! The programmers that wrote  Bob  and  Larry  don't even have to be aware that  HasName  exists.  Pony interfaces can have functions with default implementations as well. A type will only pick those up if it explicitly declares that it  is  that interface.  Should I use traits or interfaces in my own code?  Both! Interfaces are more flexible, so if you're not sure what you want, use an interface. But traits are a powerful tool as well: they stop  accidental subtyping .", 
            "title": "Interfaces"
        }, 
        {
            "location": "/types/type-aliases/", 
            "text": "A \ntype alias\n is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.\n\n\nWe'll give a couple examples of using type aliases, just to get the feel of them.\n\n\nEnumerations\n\n\nOne way to use type aliases is to express an enumeration. For example, imagine we want to say something must either be Red, Blue or Green. We could write something like this:\n\n\nprimitive Red\nprimitive Blue\nprimitive Green\n\ntype Colour is (Red | Blue | Green)\n\n\n\n\nThere are two new concepts in there. The first is the type alias, introduced with the keyword \ntype\n. It just means that the name that comes after \ntype\n will be translated by the compiler to the type that comes after \nis\n.\n\n\nThe second new concept is the type that comes after \nis\n. It's not a single type! Instead, it's a \nunion\n type. You can read the \n|\n symbol as \nor\n in this context, so the type is \"Red or Blue or Green\".\n\n\nA union type is a form of \nclosed world\n type. That is, it says every type that can possibly be a member of it. In contrast, object-oriented subtyping is usually \nopen world\n, e.g. in Java, an interface can be implemented by any number of classes.\n\n\nYou can also declare constants like in C or Go like this,\n\n\nprimitive Red    fun apply(): U32 =\n 0xFF0000FF\nprimitive Green  fun apply(): U32 =\n 0x00FF00FF\nprimitive Blue   fun apply(): U32 =\n 0x0000FFFF\n\ntype Colour is (Red | Blue | Green)\n\n\n\n\nor namespace them like this\n\n\nprimitive Colours\n  fun red(): U32 =\n 0xFF0000FF\n  fun green(): U32 =\n 0x00FF00FF\n\n\n\n\nYou might also want to iterate over the enum like this to print its name for debugging purposes\n\n\nprimitive ColourList\n  fun tag apply(): Array[Colour] =\n\n    [Red, Green, Blue]\n\nfor colour in ColourList().values() do\nend\n\n\n\n\nComplex types\n\n\nIf a type is complicated, it can be nice to give it a mnemonic name. For example, if we want to say that a type must implement more than one trait, we could say:\n\n\ninterface HasName\n  fun name(): String\n\ninterface HasAge\n  fun age(): U32\n\ninterface HasAddress\n  fun address(): String\n\ntype Person is (HasName \n HasAge \n HasAddress)\n\n\n\n\nThere's another new concept here: the type has a \n in it. This is similar to the \n|\n of a \nunion\n type: it means this is an \nintersection\n type. That is, it's something that must be \nall\n of \nHasName\n, \nHasAge\n \nand\n \nHasAddress\n.\n\n\nBut the use of \ntype\n here is exactly the same as the enumeration example above, it's just providing a name for a type that is otherwise a bit tedious to type out over and over.\n\n\nAnother example, this time from the standard library, is \nSetIs\n. Here's the actual definition:\n\n\ntype SetIs[A] is HashSet[A, HashIs[A!]]\n\n\n\n\nAgain there's something new here. After the name \nSetIs\n comes the name \nA\n in square brackets. That's because \nSetIs\n is a \ngeneric type\n. That is, you can give a \nSetIs\n another type as a parameter, to make specific kinds of set. If you've used Java or C#, this will be pretty familiar. If you've used C++, the equivalent concept is templates, but they work quite differently.\n\n\nAnd again the use of \ntype\n just provides a more convenient way to refer to the type we're aliasing:\n\n\nHashSet[A, HashIs[A!]]\n\n\n\n\nThat's another \ngeneric type\n. It means a \nSetIs\n is really a kind of \nHashSet\n. Another concept has snuck in, which is \n!\n types. This is a type that is the \nalias\n of another type. That's tricky stuff that you only need when writing complex generic types, so we'll leave it for later.\n\n\nOne more example, again from the standard library, is the \nMap\n type that gets used a lot. It's actually a type alias. Here's the real definition of \nMap\n:\n\n\ntype Map[K: (Hashable box \n Comparable[K] box), V] is HashMap[K, V, HashEq[K]]\n\n\n\n\nUnlike our previous example, the first type parameter, \nK\n, has a type associated with it. This is a \nconstraint\n, which means when you parameterise a \nMap\n, the type you pass for \nK\n must be a subtype of the constraint.\n\n\nAlso notice that \nbox\n appears in the type. This is a \nreference capability\n. It means there is a certain class of operations we need to be able to do on a \nK\n. We'll cover this in more detail later.\n\n\nJust like our other examples, all this really means is that \nMap\n is really a kind of \nHashMap\n.\n\n\nOther stuff\n\n\nType aliases get used for a lot of things, but this gives you the general idea. Just remember that a type alias is always a convenience: you could replace every use of the type alias with the full type after the \nis\n.\n\n\nIn fact, that's exactly what the compiler does.", 
            "title": "Type aliases"
        }, 
        {
            "location": "/types/type-aliases/#enumerations", 
            "text": "One way to use type aliases is to express an enumeration. For example, imagine we want to say something must either be Red, Blue or Green. We could write something like this:  primitive Red\nprimitive Blue\nprimitive Green\n\ntype Colour is (Red | Blue | Green)  There are two new concepts in there. The first is the type alias, introduced with the keyword  type . It just means that the name that comes after  type  will be translated by the compiler to the type that comes after  is .  The second new concept is the type that comes after  is . It's not a single type! Instead, it's a  union  type. You can read the  |  symbol as  or  in this context, so the type is \"Red or Blue or Green\".  A union type is a form of  closed world  type. That is, it says every type that can possibly be a member of it. In contrast, object-oriented subtyping is usually  open world , e.g. in Java, an interface can be implemented by any number of classes.  You can also declare constants like in C or Go like this,  primitive Red    fun apply(): U32 =  0xFF0000FF\nprimitive Green  fun apply(): U32 =  0x00FF00FF\nprimitive Blue   fun apply(): U32 =  0x0000FFFF\n\ntype Colour is (Red | Blue | Green)  or namespace them like this  primitive Colours\n  fun red(): U32 =  0xFF0000FF\n  fun green(): U32 =  0x00FF00FF  You might also want to iterate over the enum like this to print its name for debugging purposes  primitive ColourList\n  fun tag apply(): Array[Colour] = \n    [Red, Green, Blue]\n\nfor colour in ColourList().values() do\nend", 
            "title": "Enumerations"
        }, 
        {
            "location": "/types/type-aliases/#complex-types", 
            "text": "If a type is complicated, it can be nice to give it a mnemonic name. For example, if we want to say that a type must implement more than one trait, we could say:  interface HasName\n  fun name(): String\n\ninterface HasAge\n  fun age(): U32\n\ninterface HasAddress\n  fun address(): String\n\ntype Person is (HasName   HasAge   HasAddress)  There's another new concept here: the type has a   in it. This is similar to the  |  of a  union  type: it means this is an  intersection  type. That is, it's something that must be  all  of  HasName ,  HasAge   and   HasAddress .  But the use of  type  here is exactly the same as the enumeration example above, it's just providing a name for a type that is otherwise a bit tedious to type out over and over.  Another example, this time from the standard library, is  SetIs . Here's the actual definition:  type SetIs[A] is HashSet[A, HashIs[A!]]  Again there's something new here. After the name  SetIs  comes the name  A  in square brackets. That's because  SetIs  is a  generic type . That is, you can give a  SetIs  another type as a parameter, to make specific kinds of set. If you've used Java or C#, this will be pretty familiar. If you've used C++, the equivalent concept is templates, but they work quite differently.  And again the use of  type  just provides a more convenient way to refer to the type we're aliasing:  HashSet[A, HashIs[A!]]  That's another  generic type . It means a  SetIs  is really a kind of  HashSet . Another concept has snuck in, which is  !  types. This is a type that is the  alias  of another type. That's tricky stuff that you only need when writing complex generic types, so we'll leave it for later.  One more example, again from the standard library, is the  Map  type that gets used a lot. It's actually a type alias. Here's the real definition of  Map :  type Map[K: (Hashable box   Comparable[K] box), V] is HashMap[K, V, HashEq[K]]  Unlike our previous example, the first type parameter,  K , has a type associated with it. This is a  constraint , which means when you parameterise a  Map , the type you pass for  K  must be a subtype of the constraint.  Also notice that  box  appears in the type. This is a  reference capability . It means there is a certain class of operations we need to be able to do on a  K . We'll cover this in more detail later.  Just like our other examples, all this really means is that  Map  is really a kind of  HashMap .", 
            "title": "Complex types"
        }, 
        {
            "location": "/types/type-aliases/#other-stuff", 
            "text": "Type aliases get used for a lot of things, but this gives you the general idea. Just remember that a type alias is always a convenience: you could replace every use of the type alias with the full type after the  is .  In fact, that's exactly what the compiler does.", 
            "title": "Other stuff"
        }, 
        {
            "location": "/types/type-expressions/", 
            "text": "The types we've talked about so far can also be combined in \ntype expressions\n. If you're used to object-oriented programming, you may not have seen these before, but they are common in functional programming. A \ntype expression\n is also called an \nalgebraic data type\n.\n\n\nThere are three kinds of type expression: \ntuples\n, \nunions\n, and \nintersections\n.\n\n\nTuples\n\n\nA \ntuple\n is a sequence of types. For example, if we wanted something that was a \nString\n followed by a \nU64\n, we would write this:\n\n\nvar x: (String, U64)\nx = (\nhi\n, 3)\nx = (\nbye\n, 7)\n\n\n\n\nAll type expressions are written in parentheses, and the elements of a tuple are separated by a comma. We can also destructure a tuple using assignment:\n\n\n(var y, var z) = x\n\n\n\n\nOr we can access the elements of a tuple directly:\n\n\nvar y = x._1\nvar z = x._2\n\n\n\n\nNote that there's no way to assign to an element of a tuple. Instead, you can just reassign the entire tuple, like this:\n\n\nx = (\nwombat\n, x._2)\n\n\n\n\nWhy use a tuple instead of a class?\n Tuples are a way to express a collection of values that doesn't have any associated code or expected behaviour. Basically, if you just need a quick collection of things, maybe to return more than one value from a function for example, you can use a tuple.\n\n\nUnions\n\n\nA \nunion\n type is written like a \ntuple\n, but it uses a \n|\n (pronounced \"or\" when reading the type) instead of a \n,\n between its elements. Where a tuple represents a collection of values, a union represents a \nsingle\n value that can be any of the specified types.\n\n\nUnions can be used for tons of stuff that require multiple concepts in other languages. For example, optional values, enumerations, marker values, and more.\n\n\nvar x: (String | None)\n\n\n\n\nHere we have an example of using a union to express an optional type, where \nx\n might be a \nString\n, but it also might be \nNone\n.\n\n\nIntersections\n\n\nAn \nintersection\n uses a \n (pronounced \"and\" when reading the type) between its elements. It represents the exact opposite of a union: it is a \nsingle\n value that is \nall\n of the specified types, at the same time!\n\n\nThis can be very useful for combining traits or interfaces, for example. Here's something from the standard library:\n\n\ntype Map[K: (Hashable box \n Comparable[K] box), V] is HashMap[K, V, HashEq[K]]\n\n\n\n\nThat's a fairly complex type alias, but let's look at the constraint of \nK\n. It's \n(Hashable box \n Comparable[K] box)\n, which means \nK\n is \nHashable\n \nand\n it is \nComparable[K]\n, at the same time.\n\n\nCombining type expressions\n\n\nType expressions can be combined into more complex types. Here's another example from the standard library:\n\n\nvar _array: Array[((K, V) | _MapEmpty | _MapDeleted)]\n\n\n\n\nHere we have an array where each element is either a tuple of \n(K, V)\n or a \n_MapEmpty\n or a \n_MapDeleted\n.\n\n\nBecause every type expression has parentheses around it, they are actually easy to read once you get the hang of it. However, if you use a complex type expression often, it can be nice to provide a type alias for it.\n\n\ntype Number is (Signed | Unsigned | Float)\n\ntype Signed is (I8 | I16 | I32 | I64 | I128)\n\ntype Unsigned is (U8 | U16 | U32 | U64 | U128)\n\ntype Float is (F32 | F64)\n\n\n\n\nThose are all type aliases used by the standard library.\n\n\nIs \nNumber\n a type alias for a type expression that contains other type aliases?\n Yes! Fun, and convenient.", 
            "title": "Type expressions"
        }, 
        {
            "location": "/types/type-expressions/#tuples", 
            "text": "A  tuple  is a sequence of types. For example, if we wanted something that was a  String  followed by a  U64 , we would write this:  var x: (String, U64)\nx = ( hi , 3)\nx = ( bye , 7)  All type expressions are written in parentheses, and the elements of a tuple are separated by a comma. We can also destructure a tuple using assignment:  (var y, var z) = x  Or we can access the elements of a tuple directly:  var y = x._1\nvar z = x._2  Note that there's no way to assign to an element of a tuple. Instead, you can just reassign the entire tuple, like this:  x = ( wombat , x._2)  Why use a tuple instead of a class?  Tuples are a way to express a collection of values that doesn't have any associated code or expected behaviour. Basically, if you just need a quick collection of things, maybe to return more than one value from a function for example, you can use a tuple.", 
            "title": "Tuples"
        }, 
        {
            "location": "/types/type-expressions/#unions", 
            "text": "A  union  type is written like a  tuple , but it uses a  |  (pronounced \"or\" when reading the type) instead of a  ,  between its elements. Where a tuple represents a collection of values, a union represents a  single  value that can be any of the specified types.  Unions can be used for tons of stuff that require multiple concepts in other languages. For example, optional values, enumerations, marker values, and more.  var x: (String | None)  Here we have an example of using a union to express an optional type, where  x  might be a  String , but it also might be  None .", 
            "title": "Unions"
        }, 
        {
            "location": "/types/type-expressions/#intersections", 
            "text": "An  intersection  uses a   (pronounced \"and\" when reading the type) between its elements. It represents the exact opposite of a union: it is a  single  value that is  all  of the specified types, at the same time!  This can be very useful for combining traits or interfaces, for example. Here's something from the standard library:  type Map[K: (Hashable box   Comparable[K] box), V] is HashMap[K, V, HashEq[K]]  That's a fairly complex type alias, but let's look at the constraint of  K . It's  (Hashable box   Comparable[K] box) , which means  K  is  Hashable   and  it is  Comparable[K] , at the same time.", 
            "title": "Intersections"
        }, 
        {
            "location": "/types/type-expressions/#combining-type-expressions", 
            "text": "Type expressions can be combined into more complex types. Here's another example from the standard library:  var _array: Array[((K, V) | _MapEmpty | _MapDeleted)]  Here we have an array where each element is either a tuple of  (K, V)  or a  _MapEmpty  or a  _MapDeleted .  Because every type expression has parentheses around it, they are actually easy to read once you get the hang of it. However, if you use a complex type expression often, it can be nice to provide a type alias for it.  type Number is (Signed | Unsigned | Float)\n\ntype Signed is (I8 | I16 | I32 | I64 | I128)\n\ntype Unsigned is (U8 | U16 | U32 | U64 | U128)\n\ntype Float is (F32 | F64)  Those are all type aliases used by the standard library.  Is  Number  a type alias for a type expression that contains other type aliases?  Yes! Fun, and convenient.", 
            "title": "Combining type expressions"
        }, 
        {
            "location": "/types/delegates/", 
            "text": "Like some other object-oriented languages, Pony has \ndelegates\n. That is, some types serve as \nmixins\n that other types can use.\n\n\nDelegates\n\n\nAny \ntrait\n or \ninterface\n can be used as a \nmixin\n by exploiting delegate type declarations.\n\n\ntrait Wombat\n  fun box battle_call() : String val =\n \n    \nHuzzah!\n\n\nclass SimpleWombat is Wombat\n\nactor Main is Wombat\n  let w : SimpleWombat delegate Wombat = SimpleWombat\n\n  new create(env : Env) =\n\n    env.out.print(\nBattle cry: \n + battle_call())\n\n\n\n\nIn this example, we have defined a trait named \nWombat\n with a function \nbattle_call\n that returns\na \nString\n value. A \ntrait\n looks a bit like a \nclass\n but it can't have any fields. It can\nhowever have a default implementation such as it does in this case.\n\n\nThe class \nSimpleWombat\n supports this trait and the actor \nMain\n, also supports the \nWombat\n\ntrait. The actor \nMain\n delegates its \nWombat\nness to the \nSimpleWombat\n class, which provides\na default implementation of \nbattle_call\n.\n\n\nOverrides\n\n\nWe can, of course, override this default behaviour simply by providing our own implementation of the\n\nbattle_call\n function ourselves, as below:\n\n\nclass KungFuWombat is Wombat\n  fun box battle_call() : String val =\n\n    \nBonzai!\n\n\n\n\n\nAnd adapting our delegate to use this alternative type of Wombat:\n\n\nactor Main is Wombat\n  let w : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) =\n\n    env.out.print(\nBattle cry: \n + battle_call())\n\n\n\n\nHowever, now that we have two choices of Wombat, we can tune the type declaration to allow\nmore flexibility at runtime:\n\n\nuse \ntime\n\n\n...pony\n\nactor Main is Wombat\n  let w : Wombat delegate Wombat\n\n  new create(env : Env) =\n\n    w = match (Time.nanos() and 1) == 1\n    | true =\n KungFuWombat\n    else SimpleWombat\n    end \n    env.out.print(\nBattle cry: \n + battle_call())\n\n\n\n\nDisambiguation\n\n\nAbove, we don't know what kind of \nWombat\n we're going to get. But we know we're going to\nget either a \nKungFuWombat\n or a \nSimpleWombat\n. Sometimes though, things get a little more\ncomplicated in real code:\n\n\ntrait Drone\n  fun box battle_call() : String val =\n \n    \nBeep Boop!\n\n\nclass DroneWombat is ( Drone \n Wombat)\n  fun box battle_call() : String val =\n\n    \nBeep boop Huzzah!\n\n\n\n\n\nHere, even though both \nDrone\n and \nWombat\n provide function \nbattle_call\n we explicitly\ndisambiguate that a \nDroneWombat\n's battle call, is like a mechanized \nSimpleWombat\n. So\nwe can use our \nDroneWombat\n just like a \nDrone\n or a \nWombat\n.\n\n\nactor Main is Wombat\n  let w : Wombat delegate Wombat = DroneWombat\n\n  new create(env : Env) =\n\n    env.out.print(\nBattle cry: \n + battle_call())\n\n\n\n\nSometimes though, we won't be so lucky:\n\n\n/WombatWars/troops.pony:26:1: clashing delegates for method battle_call, local disambiguation required\nactor Main is Wombat\n^\n/WombatWars/troops.pony:27:2: field d delegates to battle_call via $0\n let d : Wombat delegate Wombat = DroneWombat\n ^\n/WombatWars/troops.pony:28:2: field k delegates to battle_call via $0\n let k : Wombat delegate Wombat = KungFuWombat\n ^\n[Finished in 0.2s with exit code 255]\n\n\n\n\nWhat just happened? Our main actor has two battle_call functions available and\ncannot unambiguously choose one. So we need to make disambiguate explicitly:\n\n\nactor Main is Wombat\n let d : Wombat delegate Wombat = DroneWombat\n let k : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) =\n\n    env.out.print(\nBattle cry: \n + battle_call())\n\n  fun box battle_call() : String val =\n\n    \nBonzai! Beep boop! Huzzah!\n\n\n\n\n\nWe can also choose our wombat delegates based on custom logic in the constructor:\n\n\nactor Main is Wombat\n let d : Wombat delegate Wombat = DroneWombat\n let k : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) =\n\n    let x = Time.nanos() % 4\n\n    let chosen_wombat = match x\n    | 0 =\n SimpleWombat\n    | 1 =\n k\n    | 2 =\n d\n    else\n      this\n    end\n    env.out.print(\nBattle cry: \n + chosen_wombat.battle_call())\n\n  fun box battle_call() : String val =\n\n    \nBonzai! Beep boop! Huzzah!\n\n\n\n\n\nDelegates are a convenient and flexible way to reuse, mixin, and/or adapt\ncode to different strategies or polices allowing for a very high degree of\nflexibility in composing reasonably complex software components from relatively simple\nparts.\n\n\nIn pony, delegates can benefit from \nnominal\n ( via \ntraits\n ) or implicit or explicit \nstructural\n ( via \ninterfaces\n ) subtyping and local disambiguation where necessary, whilst sensible default\nimplementations allow for maximizing code reuse.", 
            "title": "Delegates"
        }, 
        {
            "location": "/types/delegates/#delegates", 
            "text": "Any  trait  or  interface  can be used as a  mixin  by exploiting delegate type declarations.  trait Wombat\n  fun box battle_call() : String val =  \n     Huzzah! \n\nclass SimpleWombat is Wombat\n\nactor Main is Wombat\n  let w : SimpleWombat delegate Wombat = SimpleWombat\n\n  new create(env : Env) = \n    env.out.print( Battle cry:   + battle_call())  In this example, we have defined a trait named  Wombat  with a function  battle_call  that returns\na  String  value. A  trait  looks a bit like a  class  but it can't have any fields. It can\nhowever have a default implementation such as it does in this case.  The class  SimpleWombat  supports this trait and the actor  Main , also supports the  Wombat \ntrait. The actor  Main  delegates its  Wombat ness to the  SimpleWombat  class, which provides\na default implementation of  battle_call .", 
            "title": "Delegates"
        }, 
        {
            "location": "/types/delegates/#overrides", 
            "text": "We can, of course, override this default behaviour simply by providing our own implementation of the battle_call  function ourselves, as below:  class KungFuWombat is Wombat\n  fun box battle_call() : String val = \n     Bonzai!   And adapting our delegate to use this alternative type of Wombat:  actor Main is Wombat\n  let w : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) = \n    env.out.print( Battle cry:   + battle_call())  However, now that we have two choices of Wombat, we can tune the type declaration to allow\nmore flexibility at runtime:  use  time \n\n...pony\n\nactor Main is Wombat\n  let w : Wombat delegate Wombat\n\n  new create(env : Env) = \n    w = match (Time.nanos() and 1) == 1\n    | true =  KungFuWombat\n    else SimpleWombat\n    end \n    env.out.print( Battle cry:   + battle_call())", 
            "title": "Overrides"
        }, 
        {
            "location": "/types/delegates/#disambiguation", 
            "text": "Above, we don't know what kind of  Wombat  we're going to get. But we know we're going to\nget either a  KungFuWombat  or a  SimpleWombat . Sometimes though, things get a little more\ncomplicated in real code:  trait Drone\n  fun box battle_call() : String val =  \n     Beep Boop! \n\nclass DroneWombat is ( Drone   Wombat)\n  fun box battle_call() : String val = \n     Beep boop Huzzah!   Here, even though both  Drone  and  Wombat  provide function  battle_call  we explicitly\ndisambiguate that a  DroneWombat 's battle call, is like a mechanized  SimpleWombat . So\nwe can use our  DroneWombat  just like a  Drone  or a  Wombat .  actor Main is Wombat\n  let w : Wombat delegate Wombat = DroneWombat\n\n  new create(env : Env) = \n    env.out.print( Battle cry:   + battle_call())  Sometimes though, we won't be so lucky:  /WombatWars/troops.pony:26:1: clashing delegates for method battle_call, local disambiguation required\nactor Main is Wombat\n^\n/WombatWars/troops.pony:27:2: field d delegates to battle_call via $0\n let d : Wombat delegate Wombat = DroneWombat\n ^\n/WombatWars/troops.pony:28:2: field k delegates to battle_call via $0\n let k : Wombat delegate Wombat = KungFuWombat\n ^\n[Finished in 0.2s with exit code 255]  What just happened? Our main actor has two battle_call functions available and\ncannot unambiguously choose one. So we need to make disambiguate explicitly:  actor Main is Wombat\n let d : Wombat delegate Wombat = DroneWombat\n let k : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) = \n    env.out.print( Battle cry:   + battle_call())\n\n  fun box battle_call() : String val = \n     Bonzai! Beep boop! Huzzah!   We can also choose our wombat delegates based on custom logic in the constructor:  actor Main is Wombat\n let d : Wombat delegate Wombat = DroneWombat\n let k : Wombat delegate Wombat = KungFuWombat\n\n  new create(env : Env) = \n    let x = Time.nanos() % 4\n\n    let chosen_wombat = match x\n    | 0 =  SimpleWombat\n    | 1 =  k\n    | 2 =  d\n    else\n      this\n    end\n    env.out.print( Battle cry:   + chosen_wombat.battle_call())\n\n  fun box battle_call() : String val = \n     Bonzai! Beep boop! Huzzah!   Delegates are a convenient and flexible way to reuse, mixin, and/or adapt\ncode to different strategies or polices allowing for a very high degree of\nflexibility in composing reasonably complex software components from relatively simple\nparts.  In pony, delegates can benefit from  nominal  ( via  traits  ) or implicit or explicit  structural  ( via  interfaces  ) subtyping and local disambiguation where necessary, whilst sensible default\nimplementations allow for maximizing code reuse.", 
            "title": "Disambiguation"
        }, 
        {
            "location": "/expressions/variables/", 
            "text": "Like most other programming languages Pony allows you to store data in variables. There are a few different kinds of variables which have different lifetimes and are used for slightly different purposes.\n\n\nLocal variables\n\n\nLocal variables in Pony work very much as they do in other languages, allowing you to store temporary values while you perform calculations. Local variables live within a chunk of code (they are \nlocal\n to that chunk) and are created every time that code chunk executes and disposed of when it completes.\n\n\nTo define a local variable the \nvar\n keyword is used (\nlet\n can also be used, but we'll get to that later). Right after the \nvar\n comes the variable's name, and then you can (optionally) put a \n:\n followed by the variable's type. For example:\n\n\nvar x: String = \nHello\n\n\n\n\n\nHere, we're assigning the \nstring literal\n \n\"Hello\"\n to \nx\n.\n\n\nYou don't have to give a value to the variable when you define it: you can assign one later if you prefer. If you try to read the value from a variable before you've assigned one, the compiler will complain instead of allowing the dreaded \nuninitialised variable\n bug.\n\n\nEvery variable has a type, but you don't have to specify it in the declaration if you provide an initial value. The compiler will automatically use the type of the initial value for the variable.\n\n\nThe following definitions of \nx\n, \ny\n and \nz\n are all effectively identical.\n\n\nvar x: String = \nHello\n\n\nvar y = \nHello\n\n\nvar z: String\nz = \nHello\n\n\n\n\n\nCan I miss out both the type and initial value for a variable?\n No. The compiler will complain that it can't figure out a type for that variable.\n\n\nAll local variable names start with a lower case letter. If you want to you can end them with a \nprime\n \n'\n (or more than one) which is useful when you need a second variable with almost the same meaning as the first. For example you might have one variable called \ntime\n and another called \ntime'\n.\n\n\nThe chunk of code that a variable lives in is known as its \nscope\n. Exactly what its scope is depends on where it is defined. For example, the scope of a variable defined within the \nthen\n expression of an \nif\n statement is that \nthen\n expression. We haven't looked at \nif\n statements yet, but they're very similar to every other language.\n\n\nif a \n b then\n  var x = \na is bigger\n\n  env.out.print(x)  // OK\nend\n\nenv.out.print(x)  // Illegal\n\n\n\n\nVariables only exists from when they are defined until the end of the current scope. For our variable \nx\n this is the \nend\n at the end of the then expression: after that it cannot be used.\n\n\nVar vs. let\n\n\nLocal variables are declared with either a \nvar\n or a \nlet\n. Using \nvar\n means the variable can be assigned and reassigned as many times as you like. Using \nlet\n means the variable can only be assigned once.\n\n\nvar x: U32 = 3\nlet y: U32 = 4\nx = 5  // OK\ny = 6  // Error, y is let\n\n\n\n\nYou never have to declare variables as \nlet\n, but if you know you're never going to change a variable then using \nlet\n is a good way to catch errors. It can also serve as a useful comment, indicating the value is not meant to be changed.\n\n\nFields\n\n\nIn Pony, fields are variables that live within objects. They work like fields in other object-oriented languages.\n\n\nFields have the same lifetime as the object they're in, rather than being scoped. They are set up by the object constructor and disposed of along with the object.\n\n\nIf the name of a field starts with \n_\n, it's \nprivate\n. That means only the type the field is in can have code that reads or writes that field. Otherwise, the field is \npublic\n, and can be read or written anywhere.\n\n\nJust like local variables, fields can be \nvar\n or \nlet\n. They can also have initial value assigned in their definition, just like local variables, or they can be given their initial value in a constructor.\n\n\nGlobals\n\n\nSome programming languages have \nglobal variables\n that can be accessed from anywhere in the code. What a bad idea! Pony doesn't have global variables at all.\n\n\nShadowing\n\n\nSome programming languages let you declare a variable with the same name as an existing variable, and then there are rules about which one you get. This is called \nshadowing\n, and it's a source of bugs. If you accidentally shadow a variable in Pony, the compiler will complain.\n\n\nIf you need a variable with \nnearly\n the same name, you can use a prime \n'\n.", 
            "title": "Variables"
        }, 
        {
            "location": "/expressions/variables/#local-variables", 
            "text": "Local variables in Pony work very much as they do in other languages, allowing you to store temporary values while you perform calculations. Local variables live within a chunk of code (they are  local  to that chunk) and are created every time that code chunk executes and disposed of when it completes.  To define a local variable the  var  keyword is used ( let  can also be used, but we'll get to that later). Right after the  var  comes the variable's name, and then you can (optionally) put a  :  followed by the variable's type. For example:  var x: String =  Hello   Here, we're assigning the  string literal   \"Hello\"  to  x .  You don't have to give a value to the variable when you define it: you can assign one later if you prefer. If you try to read the value from a variable before you've assigned one, the compiler will complain instead of allowing the dreaded  uninitialised variable  bug.  Every variable has a type, but you don't have to specify it in the declaration if you provide an initial value. The compiler will automatically use the type of the initial value for the variable.  The following definitions of  x ,  y  and  z  are all effectively identical.  var x: String =  Hello \n\nvar y =  Hello \n\nvar z: String\nz =  Hello   Can I miss out both the type and initial value for a variable?  No. The compiler will complain that it can't figure out a type for that variable.  All local variable names start with a lower case letter. If you want to you can end them with a  prime   '  (or more than one) which is useful when you need a second variable with almost the same meaning as the first. For example you might have one variable called  time  and another called  time' .  The chunk of code that a variable lives in is known as its  scope . Exactly what its scope is depends on where it is defined. For example, the scope of a variable defined within the  then  expression of an  if  statement is that  then  expression. We haven't looked at  if  statements yet, but they're very similar to every other language.  if a   b then\n  var x =  a is bigger \n  env.out.print(x)  // OK\nend\n\nenv.out.print(x)  // Illegal  Variables only exists from when they are defined until the end of the current scope. For our variable  x  this is the  end  at the end of the then expression: after that it cannot be used.", 
            "title": "Local variables"
        }, 
        {
            "location": "/expressions/variables/#var-vs-let", 
            "text": "Local variables are declared with either a  var  or a  let . Using  var  means the variable can be assigned and reassigned as many times as you like. Using  let  means the variable can only be assigned once.  var x: U32 = 3\nlet y: U32 = 4\nx = 5  // OK\ny = 6  // Error, y is let  You never have to declare variables as  let , but if you know you're never going to change a variable then using  let  is a good way to catch errors. It can also serve as a useful comment, indicating the value is not meant to be changed.", 
            "title": "Var vs. let"
        }, 
        {
            "location": "/expressions/variables/#fields", 
            "text": "In Pony, fields are variables that live within objects. They work like fields in other object-oriented languages.  Fields have the same lifetime as the object they're in, rather than being scoped. They are set up by the object constructor and disposed of along with the object.  If the name of a field starts with  _ , it's  private . That means only the type the field is in can have code that reads or writes that field. Otherwise, the field is  public , and can be read or written anywhere.  Just like local variables, fields can be  var  or  let . They can also have initial value assigned in their definition, just like local variables, or they can be given their initial value in a constructor.", 
            "title": "Fields"
        }, 
        {
            "location": "/expressions/variables/#globals", 
            "text": "Some programming languages have  global variables  that can be accessed from anywhere in the code. What a bad idea! Pony doesn't have global variables at all.", 
            "title": "Globals"
        }, 
        {
            "location": "/expressions/variables/#shadowing", 
            "text": "Some programming languages let you declare a variable with the same name as an existing variable, and then there are rules about which one you get. This is called  shadowing , and it's a source of bugs. If you accidentally shadow a variable in Pony, the compiler will complain.  If you need a variable with  nearly  the same name, you can use a prime  ' .", 
            "title": "Shadowing"
        }, 
        {
            "location": "/expressions/infix-ops/", 
            "text": "Infix operators take two operands and are written between those operands. Arithmetic and comparison operators are the most common:\n\n\n1 + 2\na \n b\n\n\n\n\nPony has pretty much the same set of infix operators as other languages.\n\n\nPrecedence\n\n\nWhen using infix operators in complex expressions a key question is the \nprecedence\n, i.e. which operator is evaluated first. Given this expression:\n\n\n1 + 2 * 3\n\n\n\n\nWe will get a value of 9 if we evaluate the addition first and 7 if we evaluate the multiplication first. In mathematics there are rules about the order in which to evaluate operators and most programming languages follow this approach.\n\n\nThe problem with this is that the programmer has to remember the order and people aren't very good at things like that. Most people will remember to do multiplication before addition, but what about left bit shifting versus bitwise and? Sometimes people misremember (or guess wrong) and that leads to bugs. Worse, those bugs are often very hard to spot.\n\n\nPony takes a different approach and outlaws infix precedence. Any expression where more than one infix operator is used \nmust\n use parentheses to remove the ambiguity. If you fail to do this the compiler will complain.\n\n\nThis means that the example above is illegal in Pony and should be rewritten as:\n\n\n1 + (2 * 3)\n\n\n\n\nRepeated use of a single operator however is fine:\n\n\n1 + 2 + 3\n\n\n\n\nOperator aliasing\n\n\nMost infix operators in Pony are actually aliases for functions. The left operand is the receiver the function is called on and the right operand is passed as an argument. For example the following expressions are equivalent:\n\n\nx + y\nx.add(y)\n\n\n\n\nThis means that \n+\n is not a special symbol that can only be applied to magic types. Any type can provide its own \nadd\n function and the programmer can then use \n+\n with that type, if they want to.\n\n\nWhen defining your own \nadd\n function there is no restriction on the types of the parameter or the return type. The right side of the \n+\n will have to match the parameter type and the whole \n+\n expression will have the type that \nadd\n returns.\n\n\nHere's a full example for defining a type which allows use of \n+\n. This is all you need:\n\n\n// Define a suitable type\nclass Pair\n  var _x: U32 = 0\n  var _y: U32 = 0\n\n  new create(x: U32, y: U32) =\n\n    _x = x\n    _y = y\n\n  // Define a + function\n  fun add(other: Pair): Pair =\n\n    Pair(_x + other._x, _y + other._y)\n\n// Now let's use it\nclass Foo\n  fun foo() =\n\n    var x = Pair(1, 2)\n    var y = Pair(3, 4)\n    var z = x + y\n\n\n\n\nSince Pony does not allow overloading of functions by argument type, each type can only have a single \nadd\n function. It is possible to overload infix operators to some degree using union types or f-bounded polymorphism, but this is beyond the scope of this tutorial. See the Pony standard library for further information.\n\n\nYou do not have to worry about any of this if you don't want to. You can simply use the existing infix operators for numbers just like any other language and not provide them for your own types.\n\n\nThe full list of infix operators that are aliases for functions is:\n\n\n\n\n\n\n\n\n\n\nOperator\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n+\n\n\nadd()\n\n\nAddition\n\n\n\n\n\n\n-\n\n\nsub()\n\n\nSubtraction\n\n\n\n\n\n\n*\n\n\nmul()\n\n\nMultiplication\n\n\n\n\n\n\n/\n\n\ndiv()\n\n\nDivision\n\n\n\n\n\n\n%\n\n\nmod()\n\n\nModulus\n\n\n\n\n\n\n\n\nshl()\n\n\nLeft bit shift\n\n\n\n\n\n\n\n\nshr()\n\n\nRight bit shift\n\n\n\n\n\n\nand\n\n\nop_and()\n\n\nAnd, both bitwise and logical\n\n\n\n\n\n\nor\n\n\nop_or()\n\n\nOr, both bitwise and logical\n\n\n\n\n\n\nxor\n\n\nop_xor()\n\n\nXor, both bitwise and logical\n\n\n\n\n\n\n==\n\n\neq()\n\n\nEquality\n\n\n\n\n\n\n!=\n\n\nne()\n\n\nNon-equality\n\n\n\n\n\n\n\n\nlt()\n\n\nLess then\n\n\n\n\n\n\n=\n\n\nle()\n\n\nLess than or equal\n\n\n\n\n\n\n=\n\n\nge()\n\n\nGreater than or equal\n\n\n\n\n\n\n\n\ngt()\n\n\nGreater than\n\n\n\n\n\n\n\n\n\n\nShort circuiting\n\n\nThe \nand\n and \nor\n operators use \nshort circuiting\n when used with Bool variables. This means that the first operand is always evaluated, but the second is only evaluated if it can affect the result.\n\n\nFor \nand\n, if the first operand is \nfalse\n then the second operand is not evaluated, since it cannot affect the result.\n\n\nFor \nor\n, if the first operand is \ntrue\n then the second operand is not evaluated, since it cannot affect the result.\n\n\nThis is a special feature built into the compiler, it cannot be used with operator aliasing for any other type.\n\n\nUnary operators\n\n\nThe unary operators are handled in the same manner, but with only one operand. For example the following expressions are equivalent:\n\n\n-x\nx.neg()\n\n\n\n\nThe full list of unary operators that are aliases for functions is:\n\n\n\n\n\n\n\n\n\n\nOperator\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\n\n\nneg()\n\n\nArithmetic negation\n\n\n\n\n\n\nnot\n\n\nop_not()\n\n\nNot, both bitwise and logical", 
            "title": "Infix ops"
        }, 
        {
            "location": "/expressions/infix-ops/#precedence", 
            "text": "When using infix operators in complex expressions a key question is the  precedence , i.e. which operator is evaluated first. Given this expression:  1 + 2 * 3  We will get a value of 9 if we evaluate the addition first and 7 if we evaluate the multiplication first. In mathematics there are rules about the order in which to evaluate operators and most programming languages follow this approach.  The problem with this is that the programmer has to remember the order and people aren't very good at things like that. Most people will remember to do multiplication before addition, but what about left bit shifting versus bitwise and? Sometimes people misremember (or guess wrong) and that leads to bugs. Worse, those bugs are often very hard to spot.  Pony takes a different approach and outlaws infix precedence. Any expression where more than one infix operator is used  must  use parentheses to remove the ambiguity. If you fail to do this the compiler will complain.  This means that the example above is illegal in Pony and should be rewritten as:  1 + (2 * 3)  Repeated use of a single operator however is fine:  1 + 2 + 3", 
            "title": "Precedence"
        }, 
        {
            "location": "/expressions/infix-ops/#operator-aliasing", 
            "text": "Most infix operators in Pony are actually aliases for functions. The left operand is the receiver the function is called on and the right operand is passed as an argument. For example the following expressions are equivalent:  x + y\nx.add(y)  This means that  +  is not a special symbol that can only be applied to magic types. Any type can provide its own  add  function and the programmer can then use  +  with that type, if they want to.  When defining your own  add  function there is no restriction on the types of the parameter or the return type. The right side of the  +  will have to match the parameter type and the whole  +  expression will have the type that  add  returns.  Here's a full example for defining a type which allows use of  + . This is all you need:  // Define a suitable type\nclass Pair\n  var _x: U32 = 0\n  var _y: U32 = 0\n\n  new create(x: U32, y: U32) = \n    _x = x\n    _y = y\n\n  // Define a + function\n  fun add(other: Pair): Pair = \n    Pair(_x + other._x, _y + other._y)\n\n// Now let's use it\nclass Foo\n  fun foo() = \n    var x = Pair(1, 2)\n    var y = Pair(3, 4)\n    var z = x + y  Since Pony does not allow overloading of functions by argument type, each type can only have a single  add  function. It is possible to overload infix operators to some degree using union types or f-bounded polymorphism, but this is beyond the scope of this tutorial. See the Pony standard library for further information.  You do not have to worry about any of this if you don't want to. You can simply use the existing infix operators for numbers just like any other language and not provide them for your own types.  The full list of infix operators that are aliases for functions is:      Operator  Method  Description      +  add()  Addition    -  sub()  Subtraction    *  mul()  Multiplication    /  div()  Division    %  mod()  Modulus     shl()  Left bit shift     shr()  Right bit shift    and  op_and()  And, both bitwise and logical    or  op_or()  Or, both bitwise and logical    xor  op_xor()  Xor, both bitwise and logical    ==  eq()  Equality    !=  ne()  Non-equality     lt()  Less then    =  le()  Less than or equal    =  ge()  Greater than or equal     gt()  Greater than", 
            "title": "Operator aliasing"
        }, 
        {
            "location": "/expressions/infix-ops/#short-circuiting", 
            "text": "The  and  and  or  operators use  short circuiting  when used with Bool variables. This means that the first operand is always evaluated, but the second is only evaluated if it can affect the result.  For  and , if the first operand is  false  then the second operand is not evaluated, since it cannot affect the result.  For  or , if the first operand is  true  then the second operand is not evaluated, since it cannot affect the result.  This is a special feature built into the compiler, it cannot be used with operator aliasing for any other type.", 
            "title": "Short circuiting"
        }, 
        {
            "location": "/expressions/infix-ops/#unary-operators", 
            "text": "The unary operators are handled in the same manner, but with only one operand. For example the following expressions are equivalent:  -x\nx.neg()  The full list of unary operators that are aliases for functions is:      Operator  Method  Description      -  neg()  Arithmetic negation    not  op_not()  Not, both bitwise and logical", 
            "title": "Unary operators"
        }, 
        {
            "location": "/expressions/control-structures/", 
            "text": "To do real work in a program you have to be able to make decisions, iterate through collections of items and perform actions repeatedly. For this you need control structures. Pony has control structures that will be familiar to programmers who have used most languages, such as \nif\n, \nwhile\n and \nfor\n, but in Pony they work slightly differently.\n\n\nConditionals\n\n\nThe simplest control-structure is the good old \nif\n. It allows you to perform some action only when a condition is true. In Pony it looks like this:\n\n\nif a \n b then\n  env.out.print(\na is bigger\n)\nend\n\n\n\n\nCan I use integers and pointers for the condition like I can in C?\n No. In Pony \nif\n conditions must have type Bool, i.e. they are always true or false. If you want to test whether a number \na\n is not 0, then you need to explicitly say \na != 0\n. This restriction removes a whole category of potential bugs from Pony programs.\n\n\nIf you want some alternative code for when the condition fails just add an \nelse\n:\n\n\nif a \n b then\n  env.out.print(\na is bigger\n)\nelse\n  env.out.print(\na is not bigger\n)\nend\n\n\n\n\nOften you want to test more than one condition in one go, giving you more than two possible outcomes. You can nest \nif\n statements, but this quickly gets ugly:\n\n\nif a == b then\n  env.out.print(\nthey are the same\n)\nelse\n  if a \n b then\n    env.out.print(\na is bigger\n)\n  else\n    env.out.print(\nb bigger\n)\n  end\nend\n\n\n\n\nAs an alternative Pony provides the \nelseif\n keyword that combines an \nelse\n and an \nif\n. This works the same as saying \nelse if\n in other languages and you can have as many \nelseif\ns as you like for each \nif\n.\n\n\nif a == b then\n  env.out.print(\nthey are the same\n)\nelseif a \n b then\n  env.out.print(\na is bigger\n)\nelse\n  env.out.print(\nb bigger\n)\nend\n\n\n\n\nWhy can't I just say \"else if\" like I do in C? Why the extra keyword?\n The relationship between \nif\n and \nelse\n in C, and other similar languages, is ambiguous. For example:\n\n\n// C code\nif(a)\n  if(b)\n    printf(\na and b\\n\n);\nelse\n  printf(\nnot a\\n\n);\n\n\n\n\nHere it is not obvious whether the \nelse\n is an alternative to the first or the second \nif\n. In fact here the \nelse\n relates to the \nif(b)\n so our example contains a bug. Pony avoids this type of bug by handling \nif\n and \nelse\n differently and the need for \nelseif\n comes out of that.\n\n\nEverything is an expression\n\n\nThe big difference for control structures between Pony and other languages is that in Pony everything is an expression. In languages like C++ and Java \nif\n is a statement, not an expression. This means that you can't have an \nif\n inside an expression, there has to be a separate conditional operator '?'.\n\n\nIn Pony there are no statements there are only expressions, everything hands back a value. Your \nif\n statement hands you back a value. Your \nfor\n loop (which we'll get to a bit later) hands you back a value. \n\n\nThis means you can use \nif\n directly in a calculation:\n\n\nx = 1 + if lots then 100 else 2 end\n\n\n\n\nThis will give \nx\n a value of either 3 or 101, depending on the variable \nlots\n.\n\n\nIf the \nthen\n and \nelse\n branches of an \nif\n produce different types then the \nif\n produces a \nunion\n of the two.\n\n\nvar x: (String | Bool) =\n  if friendly then\n    \nHello\n\n  else\n    false\n  end\n\n\n\n\nBut what if my if doesn't have an else?\n Any \nelse\n branch that doesn't exist gives an implicit \nNone\n.\n\n\nvar x: (String | None) =\n  if friendly then\n    \nHello\n\n  end\n\n\n\n\nDoes Pony still have the conditional operator \"?\"?\n No, it's not needed. Just use \nif\n.\n\n\nLoops\n\n\nif\n allows you to choose what to do, but to do something more than once you want a loop.\n\n\nWhile\n\n\nPony \nwhile\n loops are very similar to those in other languages. A condition expression is evaluated and if it's true we execute the code inside the loop. When we're done we evaluate the condition again and keep going until it's false.\n\n\nHere's an example that prints out the numbers 1 to 10:\n\n\nvar count: U32 = 1\n\nwhile count \n= 10 do\n  env.out.print(count)\n  count = count + 1\nend\n\n\n\n\nJust like \nif\n expressions \nwhile\n is also an expression. The value returned is just the value of the expression inside the loop the last time we go round it. For this example that will be the value given by \ncount = count + 1\n when count is incremented to 11. Since Pony assignments hand back the \nold\n value our \nwhile\n loop will return 10.\n\n\nBut what if the condition evaluates to false the first time we try, then we don't go round the loop at all?\n In Pony \nwhile\n expressions can also have an \nelse\n block. In general, Pony \nelse\n blocks provide a value when the expression they are attached to doesn't. A \nwhile\n doesn't have a value to give if the condition evaluates to false the first time, so the \nelse\n provides it instead.\n\n\nSo is this like an else block on a while loop in Python?\n No, this is very different. In Python the \nelse\n is run when the \nwhile\n completes. In Pony the \nelse\n is only run when the expression in the \nwhile\n isn't.\n\n\nBreak\n\n\nSometimes you want to stop part-way through a loop and give up altogether. Pony has the \nbreak\n keyword for this and it is very similar to its counterpart in languages like C++, C# and Python.\n\n\nbreak\n immediately exits from the innermost loop it's in. Since the loop has to return a value \nbreak\n can take an expression. This is optional and if it's missed out a value of \nNone\n is returned.\n\n\nLet's have an example. Suppose you want to go through a list of names you're getting from somewhere, looking for either \"Jack\" or \"Jill\". If neither of those appear you'll just take the last name you're given and if you're not given any names at all you'll use \"Herbert\".\n\n\nvar name =\n  while moreNames() do\n    var name' = getName()\n    if name' == \nJack\n or name' == \nJill\n then\n      break name'\n    end\n    name'\n  else\n    \nHerbert\n\n  end\n\n\n\n\nSo first we ask if there are any more names to get. If there are then we get a name and see if it's \"Jack\" or \"Jill\". If it is we're done and we break out of the loop, handing back the name we've found. If not we try again.\n\n\nThe line \nname'\n appears at the end of the loop so that will be our value returned from the last iteration, if neither \"Jack\" nor \"Jill\" is found.\n\n\nThe \nelse\n block provides our value of \"Herbert\" if there are no names available at all.\n\n\nCan I break out of multiple, nested loops like the Java labelled break?\n No, Pony does not support that. If you need to break out of multiple loops you should probably refactor your code or use a worker function.\n\n\nContinue\n\n\nSometimes you want to stop part-way through one loop iteration and move onto the next. Like other languages Pony uses the \ncontinue\n keyword for this.\n\n\ncontinue\n stops executing the current iteration of the innermost loop it's in and evaluates the condition ready for the next iteration.\n\n\nIf \ncontinue\n is executed during the last iteration of the loop then we have no value to return from the loop. In this case we use the loop's \nelse\n expression to get a value. As with the \nif\n expression if no \nelse\n expression is provided \nNone\n is returned.\n\n\nCan I continue an outer, nested loop like the Java labelled continue?\n No, Pony does not support that. If you need to continue an outer loop you should probably refactor your code.\n\n\nFor\n\n\nFor iterating over a collection of items Pony uses the \nfor\n keyword. This is very similar to \nforeach\n in C#, \nfor\n..\nin\n in Python and \nfor\n in Java when used with a collection. It is very different to \nfor\n in C and C++.\n\n\nThe Pony \nfor\n loop iterates over a collection of items using an iterator. On each iteration round the loop we ask the iterator if there are any more elements to process and if there are we ask it for the next one.\n\n\nFor example to print out all the strings in an array:\n\n\nfor name in [\nBob\n, \nFred\n, \nSarah\n].values() do\n  env.out.print(name)\nend\n\n\n\n\nNote the call to \nvalues()\n on the array, this is because the loop needs an iterator not an array.\n\n\nThe iterator does not have to be of any particular type, but needs to provide the following methods:\n\n\n  fun has_next(): Bool\n  fun next(): T?\n\n\n\n\nwhere T is the type of the objects in the collection. You don't need to worry about this unless you're writing your own iterators. To use existing collections, such as those provided in the standard library, you can just use \nfor\n and it will all work. If you do write your own iterators note that we use structural typing, so your iterator doesn't need to declare that it provides any particular type.\n\n\nYou can think of the above example as being equivalent to:\n\n\nlet iterator = [\nBob\n, \nFred\n, \nSarah\n].values()\nwhile iterator.has_next() do\n  let name = iterator.next()\n  env.out.print(name)\nend\n\n\n\n\nNote that the variable \nname\n is declared \nlet\n, you cannot assign to the control variable within the loop.\n\n\nCan I use break and continue with for loops?\n Yes, \nfor\n loops can have \nelse\n expressions attached and can use \nbreak\n and \ncontinue\n just as for \nwhile\n.\n\n\nRepeat\n\n\nThe final loop construct that Pony provides is \nrepeat\n \nuntil\n. Here we evaluate the expression in the loop and then evaluate a condition expression to see if we're done or we should go round again.\n\n\nThis is similar to \ndo\n \nwhile\n in C++, C# and Java except that the termination condition is reversed, i.e. those languages terminate the loop when the condition expression is false, Pony terminates the loop when the condition expression is true.\n\n\nThe differences between \nwhile\n and \nrepeat\n in Pony are:\n\n\n\n\nWe always go round the loop at least once with \nrepeat\n, whereas with \nwhile\n we may not go round at all.\n\n\nThe termination condition is reversed.\n\n\n\n\nSuppose we're trying to create something and we want to keep trying until it's good enough:\n\n\nrepeat\n  var present = makePresent()\nuntil present.marksOutOfTen() \n 7 end\n\n\n\n\nJust like \nwhile\n loops the value given by a \nrepeat\n loop is the value of the expression within the loop on the last iteration and \nbreak\n and \ncontinue\n can be used.\n\n\nSince you always go round a repeat loop at least once do you ever need to give it an else expression?\n Yes you may need to. A \ncontinue\n in the last iteration of a \nrepeat\n loop needs to get a value from somewhere and an \nelse\n expression is used for that.", 
            "title": "Control structures"
        }, 
        {
            "location": "/expressions/control-structures/#conditionals", 
            "text": "The simplest control-structure is the good old  if . It allows you to perform some action only when a condition is true. In Pony it looks like this:  if a   b then\n  env.out.print( a is bigger )\nend  Can I use integers and pointers for the condition like I can in C?  No. In Pony  if  conditions must have type Bool, i.e. they are always true or false. If you want to test whether a number  a  is not 0, then you need to explicitly say  a != 0 . This restriction removes a whole category of potential bugs from Pony programs.  If you want some alternative code for when the condition fails just add an  else :  if a   b then\n  env.out.print( a is bigger )\nelse\n  env.out.print( a is not bigger )\nend  Often you want to test more than one condition in one go, giving you more than two possible outcomes. You can nest  if  statements, but this quickly gets ugly:  if a == b then\n  env.out.print( they are the same )\nelse\n  if a   b then\n    env.out.print( a is bigger )\n  else\n    env.out.print( b bigger )\n  end\nend  As an alternative Pony provides the  elseif  keyword that combines an  else  and an  if . This works the same as saying  else if  in other languages and you can have as many  elseif s as you like for each  if .  if a == b then\n  env.out.print( they are the same )\nelseif a   b then\n  env.out.print( a is bigger )\nelse\n  env.out.print( b bigger )\nend  Why can't I just say \"else if\" like I do in C? Why the extra keyword?  The relationship between  if  and  else  in C, and other similar languages, is ambiguous. For example:  // C code\nif(a)\n  if(b)\n    printf( a and b\\n );\nelse\n  printf( not a\\n );  Here it is not obvious whether the  else  is an alternative to the first or the second  if . In fact here the  else  relates to the  if(b)  so our example contains a bug. Pony avoids this type of bug by handling  if  and  else  differently and the need for  elseif  comes out of that.", 
            "title": "Conditionals"
        }, 
        {
            "location": "/expressions/control-structures/#everything-is-an-expression", 
            "text": "The big difference for control structures between Pony and other languages is that in Pony everything is an expression. In languages like C++ and Java  if  is a statement, not an expression. This means that you can't have an  if  inside an expression, there has to be a separate conditional operator '?'.  In Pony there are no statements there are only expressions, everything hands back a value. Your  if  statement hands you back a value. Your  for  loop (which we'll get to a bit later) hands you back a value.   This means you can use  if  directly in a calculation:  x = 1 + if lots then 100 else 2 end  This will give  x  a value of either 3 or 101, depending on the variable  lots .  If the  then  and  else  branches of an  if  produce different types then the  if  produces a  union  of the two.  var x: (String | Bool) =\n  if friendly then\n     Hello \n  else\n    false\n  end  But what if my if doesn't have an else?  Any  else  branch that doesn't exist gives an implicit  None .  var x: (String | None) =\n  if friendly then\n     Hello \n  end  Does Pony still have the conditional operator \"?\"?  No, it's not needed. Just use  if .", 
            "title": "Everything is an expression"
        }, 
        {
            "location": "/expressions/control-structures/#loops", 
            "text": "if  allows you to choose what to do, but to do something more than once you want a loop.", 
            "title": "Loops"
        }, 
        {
            "location": "/expressions/control-structures/#while", 
            "text": "Pony  while  loops are very similar to those in other languages. A condition expression is evaluated and if it's true we execute the code inside the loop. When we're done we evaluate the condition again and keep going until it's false.  Here's an example that prints out the numbers 1 to 10:  var count: U32 = 1\n\nwhile count  = 10 do\n  env.out.print(count)\n  count = count + 1\nend  Just like  if  expressions  while  is also an expression. The value returned is just the value of the expression inside the loop the last time we go round it. For this example that will be the value given by  count = count + 1  when count is incremented to 11. Since Pony assignments hand back the  old  value our  while  loop will return 10.  But what if the condition evaluates to false the first time we try, then we don't go round the loop at all?  In Pony  while  expressions can also have an  else  block. In general, Pony  else  blocks provide a value when the expression they are attached to doesn't. A  while  doesn't have a value to give if the condition evaluates to false the first time, so the  else  provides it instead.  So is this like an else block on a while loop in Python?  No, this is very different. In Python the  else  is run when the  while  completes. In Pony the  else  is only run when the expression in the  while  isn't.", 
            "title": "While"
        }, 
        {
            "location": "/expressions/control-structures/#break", 
            "text": "Sometimes you want to stop part-way through a loop and give up altogether. Pony has the  break  keyword for this and it is very similar to its counterpart in languages like C++, C# and Python.  break  immediately exits from the innermost loop it's in. Since the loop has to return a value  break  can take an expression. This is optional and if it's missed out a value of  None  is returned.  Let's have an example. Suppose you want to go through a list of names you're getting from somewhere, looking for either \"Jack\" or \"Jill\". If neither of those appear you'll just take the last name you're given and if you're not given any names at all you'll use \"Herbert\".  var name =\n  while moreNames() do\n    var name' = getName()\n    if name' ==  Jack  or name' ==  Jill  then\n      break name'\n    end\n    name'\n  else\n     Herbert \n  end  So first we ask if there are any more names to get. If there are then we get a name and see if it's \"Jack\" or \"Jill\". If it is we're done and we break out of the loop, handing back the name we've found. If not we try again.  The line  name'  appears at the end of the loop so that will be our value returned from the last iteration, if neither \"Jack\" nor \"Jill\" is found.  The  else  block provides our value of \"Herbert\" if there are no names available at all.  Can I break out of multiple, nested loops like the Java labelled break?  No, Pony does not support that. If you need to break out of multiple loops you should probably refactor your code or use a worker function.", 
            "title": "Break"
        }, 
        {
            "location": "/expressions/control-structures/#continue", 
            "text": "Sometimes you want to stop part-way through one loop iteration and move onto the next. Like other languages Pony uses the  continue  keyword for this.  continue  stops executing the current iteration of the innermost loop it's in and evaluates the condition ready for the next iteration.  If  continue  is executed during the last iteration of the loop then we have no value to return from the loop. In this case we use the loop's  else  expression to get a value. As with the  if  expression if no  else  expression is provided  None  is returned.  Can I continue an outer, nested loop like the Java labelled continue?  No, Pony does not support that. If you need to continue an outer loop you should probably refactor your code.", 
            "title": "Continue"
        }, 
        {
            "location": "/expressions/control-structures/#for", 
            "text": "For iterating over a collection of items Pony uses the  for  keyword. This is very similar to  foreach  in C#,  for .. in  in Python and  for  in Java when used with a collection. It is very different to  for  in C and C++.  The Pony  for  loop iterates over a collection of items using an iterator. On each iteration round the loop we ask the iterator if there are any more elements to process and if there are we ask it for the next one.  For example to print out all the strings in an array:  for name in [ Bob ,  Fred ,  Sarah ].values() do\n  env.out.print(name)\nend  Note the call to  values()  on the array, this is because the loop needs an iterator not an array.  The iterator does not have to be of any particular type, but needs to provide the following methods:    fun has_next(): Bool\n  fun next(): T?  where T is the type of the objects in the collection. You don't need to worry about this unless you're writing your own iterators. To use existing collections, such as those provided in the standard library, you can just use  for  and it will all work. If you do write your own iterators note that we use structural typing, so your iterator doesn't need to declare that it provides any particular type.  You can think of the above example as being equivalent to:  let iterator = [ Bob ,  Fred ,  Sarah ].values()\nwhile iterator.has_next() do\n  let name = iterator.next()\n  env.out.print(name)\nend  Note that the variable  name  is declared  let , you cannot assign to the control variable within the loop.  Can I use break and continue with for loops?  Yes,  for  loops can have  else  expressions attached and can use  break  and  continue  just as for  while .", 
            "title": "For"
        }, 
        {
            "location": "/expressions/control-structures/#repeat", 
            "text": "The final loop construct that Pony provides is  repeat   until . Here we evaluate the expression in the loop and then evaluate a condition expression to see if we're done or we should go round again.  This is similar to  do   while  in C++, C# and Java except that the termination condition is reversed, i.e. those languages terminate the loop when the condition expression is false, Pony terminates the loop when the condition expression is true.  The differences between  while  and  repeat  in Pony are:   We always go round the loop at least once with  repeat , whereas with  while  we may not go round at all.  The termination condition is reversed.   Suppose we're trying to create something and we want to keep trying until it's good enough:  repeat\n  var present = makePresent()\nuntil present.marksOutOfTen()   7 end  Just like  while  loops the value given by a  repeat  loop is the value of the expression within the loop on the last iteration and  break  and  continue  can be used.  Since you always go round a repeat loop at least once do you ever need to give it an else expression?  Yes you may need to. A  continue  in the last iteration of a  repeat  loop needs to get a value from somewhere and an  else  expression is used for that.", 
            "title": "Repeat"
        }, 
        {
            "location": "/expressions/methods/", 
            "text": "All Pony code that actually does something, rather than defining types etc, appears in named blocks which are referred to as methods. There are three kinds of methods; functions, constructors and behaviours. All methods are attached to type definitions (e.g. classes), there are no global functions.\n\n\nBehaviours are used for handling asynchronous messages sent to actors. We'll look at those later.\n\n\nCan I have some code outside of any methods, like I do in Python?\n No. All Pony code must be within a method.\n\n\nFunctions\n\n\nPony functions are quite like functions (or methods) in other languages. They can have 0 or more parameters and 0 or 1 return values.\n\n\nclass C\n  fun add(x: U32, y: U32): U32 =\n\n    x + y\n\n  fun nop() =\n\n    add(1, 2)  // Pointless, we ignore the result\n\n\n\n\nThe function parameters (if any) are specified in parentheses after the function name. Functions that don't take any parameters still need to have the parentheses.\n\n\nEach parameter is given a name and a type. In our example function \nadd\n has 2 parameters, \nx\n and \ny\n, both of which are type \nU32\n. The values passed to a function call (the \n1\n and \n2\n in our example) are called arguments and when the call is made they are evaluated and assigned to the parameters. Parameters may not be assigned to within the function, they are effectively declared \nlet\n.\n\n\nAfter the parameters comes the return type. If nothing will be returned this is simply omitted.\n\n\nAfter the return value there's a \n=\n and then finally the function body. The value returned is simply the value of the function body (remember that everything is an expression), which is simply the value of the last command in the function.\n\n\nIf you want to exit a function early then use the \nreturn\n command. If the function has a return type then you need to provide a value to return. If the function does not have a return type then \nreturn\n should appear on its own, without a value.\n\n\nclass C\n  fun factorial(x: U32): U32 =\n\n    if x == 0 then\n      return 1\n    end\n\n    x * factorial(x - 1)\n\n\n\n\nCan I overload functions by argument type?\n No. There is no overloading of methods in Pony, each type may only have a single method of any given name.\n\n\nConstructors\n\n\nPony constructors are used to initialise newly created objects, as in many languages. However, unlike many languages, Pony constructors are named so you can have as many as you like, taking whatever parameters you like. By convention the main constructor of each type (if there is such a thing for any given type) is called \ncreate\n.\n\n\nclass Foo\n  var _x: U32\n\n  new create() =\n\n    _x = 0\n\n  new from_int(x: U32) =\n\n    _x = x\n\n\n\n\nThe purpose of a constructor is to set up the internal state of the object being created. To ensure this is done constructors must initialise all the fields in the object being constructed.\n\n\nCan I exit a constructor early?\n Yes. Just then use the \nreturn\n command without a value. The object must already be in a legal state to do this.\n\n\nCalling\n\n\nAs in many other languages, methods in Pony are called by providing the arguments within parentheses after the method name. The parentheses are required even if there are no arguments being passed to the method.\n\n\nclass Foo\n  fun hello(name: String): String =\n\n    \nhello \n + name\n\n  fun f() =\n\n    let a = hello(\nFred\n)\n\n\n\n\nConstructors are usually called \"on\" a type, by specifying the type that is to be created. To do this just specify the type, followed by a dot, followed by the name of the constructor you want to call.\n\n\nclass Foo\n  var _x: U32\n\n  new create() =\n\n    _x = 0\n\n  new from_int(x: U32) =\n\n    _x = x\n\nclass Bar\n  fun f() =\n\n    var a: Foo = Foo.create()\n    var b: Foo = Foo.from_int(3)\n\n\n\n\nFunctions are always called on an object. Again just specify the object, followed by a dot followed, by the name of the function to call. If the object to call on is omitted then the current object used (i.e. \nthis\n).\n\n\nclass Foo\n  var _x: U32\n\n  new create() =\n\n    _x = 0\n\n  new from_int(x: U32) =\n\n    _x = x\n\n  fun get(): U32 =\n\n    _x\n\nclass Bar\n  fun f() =\n\n    var a: Foo = Foo.from_int(3)\n    var b: U32 = a.get()\n    var c: U32 = g(b)\n\n  fun g(x: U32): U32 =\n\n    x + 1\n\n\n\n\n\nConstructors can also be called on an expression. Here an object is created of the same type as the specified expression, this is equivalent to directly specifying the type.\n\n\nclass Foo\n  var _x: U32\n\n  new create() =\n\n    _x = 0\n\n  new from_int(x: U32) =\n\n    _x = x\n\nclass Bar\n  fun f() =\n\n    var a: Foo = Foo.create()\n    var b: Foo = a.from_int(3)\n\n\n\n\nDefault arguments\n\n\nWhen defining a method you can provide default values for any of the arguments. The caller then has the choice to use the values you have provided or to provide their own. Default argument values are specified with a \n=\n after the parameter name.\n\n\nclass Coord\n  var _x: U32\n  var _y: U32\n\n  new create(x: U32 = 0, y: U32 = 0) =\n\n    _x = x\n    _y = y\n\nclass Bar\n  fun f() =\n\n    var a: Coord = Coord.create()     // Contains (0, 0)\n    var b: Coord = Coord.create(3)    // Contains (3, 0)\n    var b: Coord = Coord.create(3, 4) // Contains (3, 4)\n\n\n\n\nDo I have to provide default values for all of my arguments?\n No, you can provide defaults for as many, or as few, as you like.\n\n\nNamed arguments\n\n\nSo far, when calling methods we have always given all the arguments in order. This is known as using \npositional\n arguments. However, you can also specify the arguments in any order you like by specifying their names. This is known as using \nnamed\n arguments.\n\n\nTo call a method using named arguments use the \nwhere\n keyword, followed by the named arguments and their values.\n\n\nclass Coord\n  var _x: U32\n  var _y: U32\n\n  new create(x: U32 = 0, y: U32 = 0) =\n\n    _x = x\n    _y = y\n\nclass Bar\n  fun f() =\n\n    var a: Coord = Coord.create(where y = 4, x = 3)\n\n\n\n\nShould I specify \nwhere\n for each named argument?\n No. There must only be one \nwhere\n in each method call.\n\n\nNamed and positional arguments can be used together in a single call. Just start with the positional arguments you want to specify, then a \nwhere\n and finally the named arguments. But be careful, each argument must be specified only once.\n\n\nDefault arguments can also be used in combination with positional and named arguments, just miss out any for which you want to use the default.\n\n\nclass Foo\n  fun f(a:U32 = 1, b: U32 = 2, c: U32 = 3, d: U32 = 4, e: U32 = 5) =\n\n    0\n\n  fun g() =\n\n    f(6, 7 where d = 8)\n    // Equivalent to:\n    f(6, 7, 3, 8, 5)\n\n\n\n\nCan I call using positional arguments but miss out the first one?\n No. If you use positional arguments they must be the first ones in the call.\n\n\nPrivacy\n\n\nIn Pony method names start either with a lower case letter or with an underscore followed by a lower case letter. Methods with a leading underscore are private. This means they can only be called by code within the same package. Methods without a leading underscore are public and can be called by anyone.\n\n\nCan I start my method name with 2 (or more) underscores?\n No. If the first character is an underscore then the second one MUST be a lower case letter.", 
            "title": "Methods"
        }, 
        {
            "location": "/expressions/methods/#functions", 
            "text": "Pony functions are quite like functions (or methods) in other languages. They can have 0 or more parameters and 0 or 1 return values.  class C\n  fun add(x: U32, y: U32): U32 = \n    x + y\n\n  fun nop() = \n    add(1, 2)  // Pointless, we ignore the result  The function parameters (if any) are specified in parentheses after the function name. Functions that don't take any parameters still need to have the parentheses.  Each parameter is given a name and a type. In our example function  add  has 2 parameters,  x  and  y , both of which are type  U32 . The values passed to a function call (the  1  and  2  in our example) are called arguments and when the call is made they are evaluated and assigned to the parameters. Parameters may not be assigned to within the function, they are effectively declared  let .  After the parameters comes the return type. If nothing will be returned this is simply omitted.  After the return value there's a  =  and then finally the function body. The value returned is simply the value of the function body (remember that everything is an expression), which is simply the value of the last command in the function.  If you want to exit a function early then use the  return  command. If the function has a return type then you need to provide a value to return. If the function does not have a return type then  return  should appear on its own, without a value.  class C\n  fun factorial(x: U32): U32 = \n    if x == 0 then\n      return 1\n    end\n\n    x * factorial(x - 1)  Can I overload functions by argument type?  No. There is no overloading of methods in Pony, each type may only have a single method of any given name.", 
            "title": "Functions"
        }, 
        {
            "location": "/expressions/methods/#constructors", 
            "text": "Pony constructors are used to initialise newly created objects, as in many languages. However, unlike many languages, Pony constructors are named so you can have as many as you like, taking whatever parameters you like. By convention the main constructor of each type (if there is such a thing for any given type) is called  create .  class Foo\n  var _x: U32\n\n  new create() = \n    _x = 0\n\n  new from_int(x: U32) = \n    _x = x  The purpose of a constructor is to set up the internal state of the object being created. To ensure this is done constructors must initialise all the fields in the object being constructed.  Can I exit a constructor early?  Yes. Just then use the  return  command without a value. The object must already be in a legal state to do this.", 
            "title": "Constructors"
        }, 
        {
            "location": "/expressions/methods/#calling", 
            "text": "As in many other languages, methods in Pony are called by providing the arguments within parentheses after the method name. The parentheses are required even if there are no arguments being passed to the method.  class Foo\n  fun hello(name: String): String = \n     hello   + name\n\n  fun f() = \n    let a = hello( Fred )  Constructors are usually called \"on\" a type, by specifying the type that is to be created. To do this just specify the type, followed by a dot, followed by the name of the constructor you want to call.  class Foo\n  var _x: U32\n\n  new create() = \n    _x = 0\n\n  new from_int(x: U32) = \n    _x = x\n\nclass Bar\n  fun f() = \n    var a: Foo = Foo.create()\n    var b: Foo = Foo.from_int(3)  Functions are always called on an object. Again just specify the object, followed by a dot followed, by the name of the function to call. If the object to call on is omitted then the current object used (i.e.  this ).  class Foo\n  var _x: U32\n\n  new create() = \n    _x = 0\n\n  new from_int(x: U32) = \n    _x = x\n\n  fun get(): U32 = \n    _x\n\nclass Bar\n  fun f() = \n    var a: Foo = Foo.from_int(3)\n    var b: U32 = a.get()\n    var c: U32 = g(b)\n\n  fun g(x: U32): U32 = \n    x + 1  Constructors can also be called on an expression. Here an object is created of the same type as the specified expression, this is equivalent to directly specifying the type.  class Foo\n  var _x: U32\n\n  new create() = \n    _x = 0\n\n  new from_int(x: U32) = \n    _x = x\n\nclass Bar\n  fun f() = \n    var a: Foo = Foo.create()\n    var b: Foo = a.from_int(3)", 
            "title": "Calling"
        }, 
        {
            "location": "/expressions/methods/#default-arguments", 
            "text": "When defining a method you can provide default values for any of the arguments. The caller then has the choice to use the values you have provided or to provide their own. Default argument values are specified with a  =  after the parameter name.  class Coord\n  var _x: U32\n  var _y: U32\n\n  new create(x: U32 = 0, y: U32 = 0) = \n    _x = x\n    _y = y\n\nclass Bar\n  fun f() = \n    var a: Coord = Coord.create()     // Contains (0, 0)\n    var b: Coord = Coord.create(3)    // Contains (3, 0)\n    var b: Coord = Coord.create(3, 4) // Contains (3, 4)  Do I have to provide default values for all of my arguments?  No, you can provide defaults for as many, or as few, as you like.", 
            "title": "Default arguments"
        }, 
        {
            "location": "/expressions/methods/#named-arguments", 
            "text": "So far, when calling methods we have always given all the arguments in order. This is known as using  positional  arguments. However, you can also specify the arguments in any order you like by specifying their names. This is known as using  named  arguments.  To call a method using named arguments use the  where  keyword, followed by the named arguments and their values.  class Coord\n  var _x: U32\n  var _y: U32\n\n  new create(x: U32 = 0, y: U32 = 0) = \n    _x = x\n    _y = y\n\nclass Bar\n  fun f() = \n    var a: Coord = Coord.create(where y = 4, x = 3)  Should I specify  where  for each named argument?  No. There must only be one  where  in each method call.  Named and positional arguments can be used together in a single call. Just start with the positional arguments you want to specify, then a  where  and finally the named arguments. But be careful, each argument must be specified only once.  Default arguments can also be used in combination with positional and named arguments, just miss out any for which you want to use the default.  class Foo\n  fun f(a:U32 = 1, b: U32 = 2, c: U32 = 3, d: U32 = 4, e: U32 = 5) = \n    0\n\n  fun g() = \n    f(6, 7 where d = 8)\n    // Equivalent to:\n    f(6, 7, 3, 8, 5)  Can I call using positional arguments but miss out the first one?  No. If you use positional arguments they must be the first ones in the call.", 
            "title": "Named arguments"
        }, 
        {
            "location": "/expressions/methods/#privacy", 
            "text": "In Pony method names start either with a lower case letter or with an underscore followed by a lower case letter. Methods with a leading underscore are private. This means they can only be called by code within the same package. Methods without a leading underscore are public and can be called by anyone.  Can I start my method name with 2 (or more) underscores?  No. If the first character is an underscore then the second one MUST be a lower case letter.", 
            "title": "Privacy"
        }, 
        {
            "location": "/expressions/exceptions/", 
            "text": "Pony provides a simple exception mechanism to aid error handling. At any point the code may decide to declare an \nerror\n has occured. Code execution halts at that point and the call chain is unwound until the nearest enclosing error handler is found. This is all checked at compile time so errors cannot cause the whole program to crash.\n\n\nRaising and handling errors\n\n\nAn error is raised with the command \nerror\n. Error handlers are declared using the try-else syntax.\n\n\ntry\n  callA()\n  if not callB() then error end\n  callC()\nelse\n  callD()\nend\n\n\n\n\nIn the above code callA() will always be executed and so will callB(). If the result of callB() is true then we will proceed to callC() in the normal fashion and callD() will not then be executed.\n\n\nHowever, if callB() returns false, then an error will be raised. At this point execution will stop and the nearest enclosing error handler will be found and executed. In this example that is our else block and so callD() will be executed.\n\n\nIn either case execution will then carry on with whatever code comes after the try \nend\n.\n\n\nDo I have to provide an error handler?\n No. The try block will handle any errors regardless. If you don't provide an error handler then no error handling action will be taken - execution will simply continue after the try expression.\n\n\nIf you want to do something that might raise an error, but you don't care if it does you can just put in it a try block without an else.\n\n\ntry\n  call() // May raise an error\nend\n\n\n\n\nIs there anything my error handler has to do?\n No. If you provide an error handler then it must contain some code, but it is entirely up to you what it does.\n\n\nPartial functions\n\n\nPony does not require that all errors are handled immediately as in our previous examples. Instead functions can raise errors that are handled by whatever code calls them. These are called partial functions (this is a mathematical term meaning a function that does not have a defined result for all possible inputs, i.e. arguments). Partial functions \nmust\n be marked as such in Pony with a \n?\n.\n\n\nfun factorial(x: I32): I32 ? =\n\n  if x \n 0 then error end\n  if x == 0 then\n    1\n  else\n    x * factorial(x - 1)\n  end\n\n\n\n\nEverywhere that an error can be generated in Pony (an error command, a call to a partial function or certain built-in language constructs) must appear within a try block or a function that is marked as partial. This is checked at compile time, ensuring that an error cannot escape handling and crash the program.\n\n\nPartial constructors and behaviours\n\n\nConstructors may also be marked as partial. If a constructor raises an error then the construction is considered to have failed and the object under construction is discarded without ever being returned to the caller.\n\n\nWhen an actor constructor is called the actor is created and a reference to it is returned immediately. However the constructor code is executed asynchronously at some later time. If an actor constructor were to raise an error it would already be too late to report this to the caller. For this reason constructors for actors may not be partial.\n\n\nBehaviours are also executed asynchronously and so cannot be partial for the same reason.\n\n\nTry-then blocks\n\n\nIn addition to an \nelse\n error handler a try command can have a \nthen\n block. This is executed after the rest of the try, whether or not an error is raised or handled. Expanding our example from earlier:\n\n\ntry\n  callA()\n  if not callB() then error end\n  callC()\nelse\n  callD()\nthen\n  callE()\nend\n\n\n\n\nThe callE() will always be excuted. If callB() returns true then the sequence executed is callA(), callB(), callC(), callE(). If callB() returns false then the sequence executed is callA(), callB(), callD(), callE().\n\n\nDo I have to have an else error handler to have a then block?\n No. You can have a try-then block without an else if you like.\n\n\nWill my then block really always be executed, even if I return inside the try?\n Yes, your \nthen\n expression will \nalways\n be executed when the try block is complete. The only way it won't be is if the try never completes (due to an infinite loop), the machine is powered off or the process is killed (and then, maybe).\n\n\nLanguage constructs that can raise errors\n\n\nThe only language construct that can raise an error, other than the error command or calling a partial method, is the \nas\n command. This converts the given value to the specified type, if it can be. If it can't then an error is raised. This means that the \nas\n command can only be used inside a try block or a partial method.\n\n\nComparison to exceptions in other languages\n\n\nPony exceptions behave very much the same as those in C++, Java, C#, Python and Ruby. The key difference is that Pony exceptions do not have a type or instance associated with them. This makes them the same as C++ exceptions would be if a fixed literal was always thrown, eg \nthrow 3;\n. This difference simplifies exception handling for the programmer and allows for much better runtime error handling performance.\n\n\nThe \nelse\n handler in a \ntry\n expression is just like a \ncatch(...)\n in C++, \ncatch(Exception e)\n in Java or C#, \nexcept:\n in Python or \nrescue\n in Ruby. Since exceptions do not have types there is no need for handlers to specify types or to have multiple handlers in a single try block.\n\n\nThe \nthen\n block in a \ntry\n expression is just like a \nfinally\n in Java, C# or Python and \nensure\n in Ruby.\n\n\nIf required, error handlers can \"reraise\" by using the \nerror\n command within the handler.", 
            "title": "Exceptions"
        }, 
        {
            "location": "/expressions/exceptions/#raising-and-handling-errors", 
            "text": "An error is raised with the command  error . Error handlers are declared using the try-else syntax.  try\n  callA()\n  if not callB() then error end\n  callC()\nelse\n  callD()\nend  In the above code callA() will always be executed and so will callB(). If the result of callB() is true then we will proceed to callC() in the normal fashion and callD() will not then be executed.  However, if callB() returns false, then an error will be raised. At this point execution will stop and the nearest enclosing error handler will be found and executed. In this example that is our else block and so callD() will be executed.  In either case execution will then carry on with whatever code comes after the try  end .  Do I have to provide an error handler?  No. The try block will handle any errors regardless. If you don't provide an error handler then no error handling action will be taken - execution will simply continue after the try expression.  If you want to do something that might raise an error, but you don't care if it does you can just put in it a try block without an else.  try\n  call() // May raise an error\nend  Is there anything my error handler has to do?  No. If you provide an error handler then it must contain some code, but it is entirely up to you what it does.", 
            "title": "Raising and handling errors"
        }, 
        {
            "location": "/expressions/exceptions/#partial-functions", 
            "text": "Pony does not require that all errors are handled immediately as in our previous examples. Instead functions can raise errors that are handled by whatever code calls them. These are called partial functions (this is a mathematical term meaning a function that does not have a defined result for all possible inputs, i.e. arguments). Partial functions  must  be marked as such in Pony with a  ? .  fun factorial(x: I32): I32 ? = \n  if x   0 then error end\n  if x == 0 then\n    1\n  else\n    x * factorial(x - 1)\n  end  Everywhere that an error can be generated in Pony (an error command, a call to a partial function or certain built-in language constructs) must appear within a try block or a function that is marked as partial. This is checked at compile time, ensuring that an error cannot escape handling and crash the program.", 
            "title": "Partial functions"
        }, 
        {
            "location": "/expressions/exceptions/#partial-constructors-and-behaviours", 
            "text": "Constructors may also be marked as partial. If a constructor raises an error then the construction is considered to have failed and the object under construction is discarded without ever being returned to the caller.  When an actor constructor is called the actor is created and a reference to it is returned immediately. However the constructor code is executed asynchronously at some later time. If an actor constructor were to raise an error it would already be too late to report this to the caller. For this reason constructors for actors may not be partial.  Behaviours are also executed asynchronously and so cannot be partial for the same reason.", 
            "title": "Partial constructors and behaviours"
        }, 
        {
            "location": "/expressions/exceptions/#try-then-blocks", 
            "text": "In addition to an  else  error handler a try command can have a  then  block. This is executed after the rest of the try, whether or not an error is raised or handled. Expanding our example from earlier:  try\n  callA()\n  if not callB() then error end\n  callC()\nelse\n  callD()\nthen\n  callE()\nend  The callE() will always be excuted. If callB() returns true then the sequence executed is callA(), callB(), callC(), callE(). If callB() returns false then the sequence executed is callA(), callB(), callD(), callE().  Do I have to have an else error handler to have a then block?  No. You can have a try-then block without an else if you like.  Will my then block really always be executed, even if I return inside the try?  Yes, your  then  expression will  always  be executed when the try block is complete. The only way it won't be is if the try never completes (due to an infinite loop), the machine is powered off or the process is killed (and then, maybe).", 
            "title": "Try-then blocks"
        }, 
        {
            "location": "/expressions/exceptions/#language-constructs-that-can-raise-errors", 
            "text": "The only language construct that can raise an error, other than the error command or calling a partial method, is the  as  command. This converts the given value to the specified type, if it can be. If it can't then an error is raised. This means that the  as  command can only be used inside a try block or a partial method.", 
            "title": "Language constructs that can raise errors"
        }, 
        {
            "location": "/expressions/exceptions/#comparison-to-exceptions-in-other-languages", 
            "text": "Pony exceptions behave very much the same as those in C++, Java, C#, Python and Ruby. The key difference is that Pony exceptions do not have a type or instance associated with them. This makes them the same as C++ exceptions would be if a fixed literal was always thrown, eg  throw 3; . This difference simplifies exception handling for the programmer and allows for much better runtime error handling performance.  The  else  handler in a  try  expression is just like a  catch(...)  in C++,  catch(Exception e)  in Java or C#,  except:  in Python or  rescue  in Ruby. Since exceptions do not have types there is no need for handlers to specify types or to have multiple handlers in a single try block.  The  then  block in a  try  expression is just like a  finally  in Java, C# or Python and  ensure  in Ruby.  If required, error handlers can \"reraise\" by using the  error  command within the handler.", 
            "title": "Comparison to exceptions in other languages"
        }, 
        {
            "location": "/expressions/sugar/", 
            "text": "Pony allows you to omit certain small details from your code and will put them back in for you. This is done to help make your code less cluttered and more readable. Using sugar is entirely optional, you can always write out the full version if you prefer.\n\n\nApply\n\n\nMany Pony classes have a function called \napply\n which performs whatever action is most common for that type. Pony allows you to omit the word \napply\n and just attempt to do a call directly on the object. So:\n\n\nvar foo = Foo.create()\nfoo()\n\n\n\n\nbecomes:\n\n\nvar foo = Foo.create()\nfoo.apply()\n\n\n\n\nAny required arguments can be added just like normal method calls.\n\n\nvar foo = Foo.create()\nfoo(x, 37 where crash = false)\n\n\n\n\nbecomes:\n\n\nvar foo = Foo.create()\nfoo.apply(x, 37 where crash = false)\n\n\n\n\nDo I still need to provide the arguments to apply?\n Yes, only the \napply\n will be added for you, the correct number and type of arguments must be supplied. Default and named arguments can be used as normal.\n\n\nHow do I call a function foo if apply is added?\n The \napply\n sugar is only added when calling an object, not when calling a method. The compiler can tell the difference and only adds the \napply\n when appropriate.\n\n\nCreate\n\n\nTo create an object you need to specify the type and call a constructor. Pony allows you to miss out the constructor and will insert a call to \ncreate()\n for you. So:\n\n\nvar foo = Foo\n\n\n\n\nbecomes:\n\n\nvar foo = Foo.create()\n\n\n\n\nNormally types are not valid things to appear in expressions, so omitting the constructor call is not ambiguous. Remember that you can easily spot that a name is a type because it will start with a capital letter.\n\n\nIf arguments are needed for create these can be provided as if calling the type. Default and named arguments can be used as normal.\n\n\nvar foo = Foo(x, 37 where crash = false)\n\n\n\n\nbecomes:\n\n\nvar foo = Foo.create(x, 37 where crash = false)\n\n\n\n\nWhat if I want to use a constructor that isn't named create?\n Then the sugar can't help you and you have to write it out yourself.\n\n\nIf the create I want to call takes no arguments can I still put in the parentheses?\n No. Calls of the form \nType()\n use the combined create-apply sugar (see below). To get \nType.create()\n just use \nType\n.\n\n\nCombined create-apply\n\n\nIf a type has a create constructor that takes no arguments then the create and apply sugar can be used together. Just call on the type and calls to create and apply will be added. The call to create will take no arguments and the call to apply will take whatever arguments are supplied.\n\n\nvar foo = Foo()\nvar bar = Bar(x, 37 where crash = false)\n\n\n\n\nbecomes:\n\n\nvar foo = Foo.create().apply()\nvar bar = Bar.create().apply(x, 37 where crash = false)\n\n\n\n\nWhat if the create has default arguments? Do I get the combined create-apply sugar if I want to use the defaults?\n The combined create-apply sugar can only be used when the create constructor has no arguments. If there are default arguments then this sugar cannot be used.\n\n\nUpdate\n\n\nThe \nupdate\n sugar allows any class to use an assignment to accept data. Many languages allow this for assigning into collections, for example a simple C array, \na[3] = x;\n.\n\n\nIn any assignment where the left hand side is a function call, Pony will translate this to a call to update, with the value from the right hand side as an extra argument. So:\n\n\nfoo(37) = x\n\n\n\n\nbecomes:\n\n\nfoo.update(37 where value = x)\n\n\n\n\nThe value from the right hand side of the assignment is always passed to a parameter named \nvalue\n. Any object can allow this syntax simply by providing an appropriate function \nupdate\n with an argument \nvalue\n.\n\n\nDoes my update function have to have a single parameter that takes an integer?\n No, you can define update to take whatever parameters you like, as long as there is one called \nvalue\n. The following are all fine:\n\n\nfoo1(2, 3) = x\nfoo2() = x\nfoo3(37, \nHello\n, 3.5 where a = 2, b = 3) = x\n\n\n\n\nDoes it matter where \nvalue\n appears in my parameter list?\n Whilst it doesn't strictly matter it is good practice to put \nvalue\n as the last parameter. That way all of the others can be specified by position.", 
            "title": "Sugar"
        }, 
        {
            "location": "/expressions/sugar/#apply", 
            "text": "Many Pony classes have a function called  apply  which performs whatever action is most common for that type. Pony allows you to omit the word  apply  and just attempt to do a call directly on the object. So:  var foo = Foo.create()\nfoo()  becomes:  var foo = Foo.create()\nfoo.apply()  Any required arguments can be added just like normal method calls.  var foo = Foo.create()\nfoo(x, 37 where crash = false)  becomes:  var foo = Foo.create()\nfoo.apply(x, 37 where crash = false)  Do I still need to provide the arguments to apply?  Yes, only the  apply  will be added for you, the correct number and type of arguments must be supplied. Default and named arguments can be used as normal.  How do I call a function foo if apply is added?  The  apply  sugar is only added when calling an object, not when calling a method. The compiler can tell the difference and only adds the  apply  when appropriate.", 
            "title": "Apply"
        }, 
        {
            "location": "/expressions/sugar/#create", 
            "text": "To create an object you need to specify the type and call a constructor. Pony allows you to miss out the constructor and will insert a call to  create()  for you. So:  var foo = Foo  becomes:  var foo = Foo.create()  Normally types are not valid things to appear in expressions, so omitting the constructor call is not ambiguous. Remember that you can easily spot that a name is a type because it will start with a capital letter.  If arguments are needed for create these can be provided as if calling the type. Default and named arguments can be used as normal.  var foo = Foo(x, 37 where crash = false)  becomes:  var foo = Foo.create(x, 37 where crash = false)  What if I want to use a constructor that isn't named create?  Then the sugar can't help you and you have to write it out yourself.  If the create I want to call takes no arguments can I still put in the parentheses?  No. Calls of the form  Type()  use the combined create-apply sugar (see below). To get  Type.create()  just use  Type .", 
            "title": "Create"
        }, 
        {
            "location": "/expressions/sugar/#combined-create-apply", 
            "text": "If a type has a create constructor that takes no arguments then the create and apply sugar can be used together. Just call on the type and calls to create and apply will be added. The call to create will take no arguments and the call to apply will take whatever arguments are supplied.  var foo = Foo()\nvar bar = Bar(x, 37 where crash = false)  becomes:  var foo = Foo.create().apply()\nvar bar = Bar.create().apply(x, 37 where crash = false)  What if the create has default arguments? Do I get the combined create-apply sugar if I want to use the defaults?  The combined create-apply sugar can only be used when the create constructor has no arguments. If there are default arguments then this sugar cannot be used.", 
            "title": "Combined create-apply"
        }, 
        {
            "location": "/expressions/sugar/#update", 
            "text": "The  update  sugar allows any class to use an assignment to accept data. Many languages allow this for assigning into collections, for example a simple C array,  a[3] = x; .  In any assignment where the left hand side is a function call, Pony will translate this to a call to update, with the value from the right hand side as an extra argument. So:  foo(37) = x  becomes:  foo.update(37 where value = x)  The value from the right hand side of the assignment is always passed to a parameter named  value . Any object can allow this syntax simply by providing an appropriate function  update  with an argument  value .  Does my update function have to have a single parameter that takes an integer?  No, you can define update to take whatever parameters you like, as long as there is one called  value . The following are all fine:  foo1(2, 3) = x\nfoo2() = x\nfoo3(37,  Hello , 3.5 where a = 2, b = 3) = x  Does it matter where  value  appears in my parameter list?  Whilst it doesn't strictly matter it is good practice to put  value  as the last parameter. That way all of the others can be specified by position.", 
            "title": "Update"
        }, 
        {
            "location": "/expressions/object-literals/", 
            "text": "Sometimes it's really convenient to be able to write a whole object inline. In Pony, this is called an object literal, and it does pretty much exactly what an object literal in JavaScript does: it creates an object that you can use immediately.\n\n\nBut Pony is statically typed, so an object literal also creates an anonymous type that the object literal fulfills. This is similar to anonymous classes in Java and C#. In Pony, an anonymous type can provide any number of traits and interfaces.\n\n\nWhat's this look like, then?\n\n\nIt basically looks like any other type definition, but with some small differences. Here's a simple one:\n\n\nobject\n  fun apply(): String =\n \nhi\n\nend\n\n\n\n\nOk, that's pretty trivial. Let's extend it so that it explicitly provides an interface, so that the compiler will make sure the anonymous type fulfills that interface. You can use the same notation to provide traits as well.\n\n\nobject is Hashable\n  fun apply(): String =\n \nhi\n\n  fun hash(): U64 =\n this().hash()\nend\n\n\n\n\nWhat we can't do is specify constructors in an object literal, because literal \nis\n the constructor. So how do we assign to fields? Well, we just assign to them. For example:\n\n\nclass Foo\n  fun foo(str: String): Hashable =\n\n    object is Hashable\n      let s: String = str\n      fun apply(): String =\n s\n      fun hash(): U64 =\n s.hash()\n    end\n\n\n\n\nWhen we assign to a field in the constructor, we are \ncapturing\n from the lexical scope the object literal is in. Pretty fun stuff! It lets us have arbitrarily complex \nclosures\n that can even have multiple entry points (i.e. functions you can call on a closure).\n\n\nAn object literal is always returned as a \nref\n, like a default constructor on a class. To get another reference capability (\niso\n, \nval\n, etc.), you can wrap the object literal in a \nrecover\n expression.\n\n\nLambdas\n\n\nArbitrarily complex closures are nice, but sometimes we just want a simple closure. In Pony, you can use the \nlambda\n keyword for that.\n\n\nlambda(s: String): String =\n \nlambda: \n + s end\n\n\n\n\nThis produces the same code as:\n\n\nobject\n  fun apply(s: String): String =\n \nlambda: \n + s\nend\n\n\n\n\nActor literals\n\n\nNormally, an object literal is an instance of an anonymous class. To make it an instance of an anonymous actor, just include one or more behaviours in the object literal definition.\n\n\nobject\n  let stream: Stream = env.out\n  be apply() =\n stream.print(\nhi\n)\nend\n\n\n\n\nAn actor literal is always returned as a \ntag\n.\n\n\nPrimitive literals\n\n\nWhen an anonymous type has no fields and no behaviours (like, for example, an object literal declared with the \nlambda\n keyword), the compiler generates it as an anonymous primitive. This means no memory allocation is needed to generate an instance of that type.\n\n\nIn other words, a lambda in Pony has no memory allocation overhead. Nice.\n\n\nA primitive literal is always returned as a \nval\n.", 
            "title": "Object literals"
        }, 
        {
            "location": "/expressions/object-literals/#whats-this-look-like-then", 
            "text": "It basically looks like any other type definition, but with some small differences. Here's a simple one:  object\n  fun apply(): String =   hi \nend  Ok, that's pretty trivial. Let's extend it so that it explicitly provides an interface, so that the compiler will make sure the anonymous type fulfills that interface. You can use the same notation to provide traits as well.  object is Hashable\n  fun apply(): String =   hi \n  fun hash(): U64 =  this().hash()\nend  What we can't do is specify constructors in an object literal, because literal  is  the constructor. So how do we assign to fields? Well, we just assign to them. For example:  class Foo\n  fun foo(str: String): Hashable = \n    object is Hashable\n      let s: String = str\n      fun apply(): String =  s\n      fun hash(): U64 =  s.hash()\n    end  When we assign to a field in the constructor, we are  capturing  from the lexical scope the object literal is in. Pretty fun stuff! It lets us have arbitrarily complex  closures  that can even have multiple entry points (i.e. functions you can call on a closure).  An object literal is always returned as a  ref , like a default constructor on a class. To get another reference capability ( iso ,  val , etc.), you can wrap the object literal in a  recover  expression.", 
            "title": "What's this look like, then?"
        }, 
        {
            "location": "/expressions/object-literals/#lambdas", 
            "text": "Arbitrarily complex closures are nice, but sometimes we just want a simple closure. In Pony, you can use the  lambda  keyword for that.  lambda(s: String): String =   lambda:   + s end  This produces the same code as:  object\n  fun apply(s: String): String =   lambda:   + s\nend", 
            "title": "Lambdas"
        }, 
        {
            "location": "/expressions/object-literals/#actor-literals", 
            "text": "Normally, an object literal is an instance of an anonymous class. To make it an instance of an anonymous actor, just include one or more behaviours in the object literal definition.  object\n  let stream: Stream = env.out\n  be apply() =  stream.print( hi )\nend  An actor literal is always returned as a  tag .", 
            "title": "Actor literals"
        }, 
        {
            "location": "/expressions/object-literals/#primitive-literals", 
            "text": "When an anonymous type has no fields and no behaviours (like, for example, an object literal declared with the  lambda  keyword), the compiler generates it as an anonymous primitive. This means no memory allocation is needed to generate an instance of that type.  In other words, a lambda in Pony has no memory allocation overhead. Nice.  A primitive literal is always returned as a  val .", 
            "title": "Primitive literals"
        }, 
        {
            "location": "/expressions/partial-application/", 
            "text": "Partial application lets us supply \nsome\n of the arguments to a constructor, function, or behaviour, and get back something that lets us supply the rest of the arguments later.\n\n\nA simple case\n\n\nA simple case is to create a \"callback\" function. For example:\n\n\nclass Foo\n  var _f: F64 = 0\n\n  fun addmul(add: F64, mul: F64): F64 =\n\n    _f = (_f + add) * mul\n\nclass Bar\n  fun apply() =\n\n    let foo = Foo\n    let f = foo~addmul(3)\n    f(4)\n\n\n\n\nThis is a bit of a silly example, but hopefully the idea is clear. We partially apply the \naddmul\n function on \nfoo\n, binding the receiver to \nfoo\n and the \nadd\n argument to \n3\n. We get back an object, \nf\n, that has an \napply\n method that takes a \nmul\n argument. When it's called, it in turn calls \nfoo.addmul(3, mul)\n.\n\n\nWe can also bind all the arguments:\n\n\nlet f = foo~addmul(3, 4)\nf()\n\n\n\n\nOr even none of the arguments:\n\n\nlet f = foo~addmul()\nf(3, 4)\n\n\n\n\nOut of order arguments\n\n\nPartial application with named arguments allows binding arguments in any order, not just left to right. For example:\n\n\nlet f = foo~addmul(where mul = 4)\nf(3)\n\n\n\n\nHere, we bound the \nmul\n argument, but left \nadd\n unbound.\n\n\nPartially applying a partial application\n\n\nSince partial application results in an object with an apply method, we can partially apply the result!\n\n\nlet f = foo~addmul()\nlet f2 = f~apply(where mul = 4)\nf2(3)\n\n\n\n\nPartial application is an object literal\n\n\nUnder the hood, we're assembling an object literal for partial application. It captures some of the lexical scope as fields, and has an \napply\n method that takes some, possibly reduced, number of arguments. This is actually done as sugar, by rewriting the abstract syntax tree for partial application to be an object literal, before code generation.\n\n\nThat means partial application results in an anonymous class, and returns a \nref\n. If you need another reference capability, you can wrap partial application in a \nrecover\n expression.", 
            "title": "Partial application"
        }, 
        {
            "location": "/expressions/partial-application/#a-simple-case", 
            "text": "A simple case is to create a \"callback\" function. For example:  class Foo\n  var _f: F64 = 0\n\n  fun addmul(add: F64, mul: F64): F64 = \n    _f = (_f + add) * mul\n\nclass Bar\n  fun apply() = \n    let foo = Foo\n    let f = foo~addmul(3)\n    f(4)  This is a bit of a silly example, but hopefully the idea is clear. We partially apply the  addmul  function on  foo , binding the receiver to  foo  and the  add  argument to  3 . We get back an object,  f , that has an  apply  method that takes a  mul  argument. When it's called, it in turn calls  foo.addmul(3, mul) .  We can also bind all the arguments:  let f = foo~addmul(3, 4)\nf()  Or even none of the arguments:  let f = foo~addmul()\nf(3, 4)", 
            "title": "A simple case"
        }, 
        {
            "location": "/expressions/partial-application/#out-of-order-arguments", 
            "text": "Partial application with named arguments allows binding arguments in any order, not just left to right. For example:  let f = foo~addmul(where mul = 4)\nf(3)  Here, we bound the  mul  argument, but left  add  unbound.", 
            "title": "Out of order arguments"
        }, 
        {
            "location": "/expressions/partial-application/#partially-applying-a-partial-application", 
            "text": "Since partial application results in an object with an apply method, we can partially apply the result!  let f = foo~addmul()\nlet f2 = f~apply(where mul = 4)\nf2(3)", 
            "title": "Partially applying a partial application"
        }, 
        {
            "location": "/expressions/partial-application/#partial-application-is-an-object-literal", 
            "text": "Under the hood, we're assembling an object literal for partial application. It captures some of the lexical scope as fields, and has an  apply  method that takes some, possibly reduced, number of arguments. This is actually done as sugar, by rewriting the abstract syntax tree for partial application to be an object literal, before code generation.  That means partial application results in an anonymous class, and returns a  ref . If you need another reference capability, you can wrap partial application in a  recover  expression.", 
            "title": "Partial application is an object literal"
        }, 
        {
            "location": "/capabilities/object-capabilities/", 
            "text": "Pony's capabilities-secure type system is based on the object-capability model. That sounds complicated, but really it's elegant and simple. The core idea is this:\n\n\n\n\nA capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.\n\n\n\n\nSo what's that token? It's an address. A pointer. A reference. It's just... an object.\n\n\nHow is that unforgeable?\n\n\nSince Pony has no pointer arithmetic, and is both type-safe and memory-safe, object references can't be \"invented\" (i.e. forged) by the program. You can only get one by constructing an object, or being passed an object.\n\n\nWhat about the C FFI?\n Using the C FFI can break this guarantee. We'll talk about the \nC FFI trust boundary\n later, and how to control it.\n\n\nWhat about global variables?\n\n\nThey're bad! Because you can get them without either constructing them or being passed them.\n\n\nGlobal variables are a form of what is called \nambient authority\n. Another form of ambient authority is unfettered access to the file system.\n\n\nPony has no global variables and no global functions. That doesn't mean all ambient authority is magically gone - we still need to be careful about the file system, for example. Having no globals is necessary, but not sufficient, to eliminate ambient authority.\n\n\nIs this like referential transparency?\n Yes! It's similar. As long as you think of the receiver as being passed to a method as well (which it is).\n\n\nHow does this help?\n\n\nInstead of having permissions lists, access control lists, or other forms of security, the object-capabilities model means that if you have a reference to an object, you can do things with that object. Simple and effective.\n\n\nThere's a great paper on how the object-capability model works, and it's pretty easy reading:\n\n\nCapability Myths Demolished\n\n\nCapabilities and concurrency\n\n\nThe object-capability model on its own does not address concurrency. It makes clear \nwhat\n will happen if there is simultaneous access to an object, but it does not proscribe a single method of controlling this.\n\n\nCombining capabilities with the actor-model is a good start, and has been done before in languages such as \nE\n and Joule.\n\n\nPony does this and also uses a system of \nreference capabilities\n in the type system.", 
            "title": "Object capabilities"
        }, 
        {
            "location": "/capabilities/object-capabilities/#how-is-that-unforgeable", 
            "text": "Since Pony has no pointer arithmetic, and is both type-safe and memory-safe, object references can't be \"invented\" (i.e. forged) by the program. You can only get one by constructing an object, or being passed an object.  What about the C FFI?  Using the C FFI can break this guarantee. We'll talk about the  C FFI trust boundary  later, and how to control it.", 
            "title": "How is that unforgeable?"
        }, 
        {
            "location": "/capabilities/object-capabilities/#what-about-global-variables", 
            "text": "They're bad! Because you can get them without either constructing them or being passed them.  Global variables are a form of what is called  ambient authority . Another form of ambient authority is unfettered access to the file system.  Pony has no global variables and no global functions. That doesn't mean all ambient authority is magically gone - we still need to be careful about the file system, for example. Having no globals is necessary, but not sufficient, to eliminate ambient authority.  Is this like referential transparency?  Yes! It's similar. As long as you think of the receiver as being passed to a method as well (which it is).", 
            "title": "What about global variables?"
        }, 
        {
            "location": "/capabilities/object-capabilities/#how-does-this-help", 
            "text": "Instead of having permissions lists, access control lists, or other forms of security, the object-capabilities model means that if you have a reference to an object, you can do things with that object. Simple and effective.  There's a great paper on how the object-capability model works, and it's pretty easy reading:  Capability Myths Demolished", 
            "title": "How does this help?"
        }, 
        {
            "location": "/capabilities/object-capabilities/#capabilities-and-concurrency", 
            "text": "The object-capability model on its own does not address concurrency. It makes clear  what  will happen if there is simultaneous access to an object, but it does not proscribe a single method of controlling this.  Combining capabilities with the actor-model is a good start, and has been done before in languages such as  E  and Joule.  Pony does this and also uses a system of  reference capabilities  in the type system.", 
            "title": "Capabilities and concurrency"
        }, 
        {
            "location": "/capabilities/reference-capabilities/", 
            "text": "So if the object \nis\n the capability, what controls what we can do with the object? How do we express our \naccess rights\n on that object?\n\n\nIn Pony, we do it with \nreference capabilities\n.\n\n\nRights are part of a capability\n\n\nIf you open a file in UNIX, and get a file descriptor back, that file descriptor is token that designates an object - but it isn't a capability. To be a capability, we need to open that file with some permission - some access right. For example:\n\n\nint fd = open(\n/etc/passwd\n, O_RDWR);\n\n\n\n\nNow we have a token, and a set of rights.\n\n\nIn Pony, every reference has both a type and a reference capability. In fact, the reference capability is \npart\n of its type. These allow you to specify which of your objects can be shared with other actors and allow the compiler to check that what you're doing is concurrency safe.\n\n\nBasic concepts\n\n\nThere are a few simple concepts you need to understand before reference capabilities will make any sense. We've talked about some of these already, and some may already be obvious to you, but it's worth recapping here.\n\n\nShared mutable data is hard\n\n\nThe problem with concurrency is shared mutable data. If two different threads have access to the same piece of data then they might try to update it at the same time. At best this can lead to the two threads having different versions of the data. At worst the updates can interact badly resulting in the data being overwritten with garbage. The standard way to avoid these problems is to use locks to prevent data updates from happening at the same time. This causes big performance hits and is very difficult to get right, so it causes lots of bugs.\n\n\nImmutable data can be safely shared\n\n\nAny data that is immutable (i.e. it cannot be changed) is safe to use concurrently. Since it is immutable it is never updated and it's the updates that cause concurrency problems.\n\n\nIsolated data is safe\n\n\nIf a block of data has only one reference to it then we call it \nisolated\n. Since there is only one reference to it, isolated data cannot be \nshared\n by multiple threads, so there are no concurrency problems. Isolated data can be passed between multiple threads. As long as only one of them has a reference to it at a time then the data is still safe from concurrency problems.\n\n\nIsolated data may be complex\n\n\nAn isolated piece of data may be a single byte. But it can also be a large data structure with multiple references between the various objects in that structure. What matters for the data to be isolated is that there is only a single reference to that structure as a whole. We talk about the \nisolation boundary\n of a data structure. For the structure to be isolated:\n\n\n\n\nThere must only be a single reference outside the boundary that points to an object inside.\n\n\nThere can be any number of references inside the boundary, but none of them must point to an object outside.\n\n\n\n\nEvery actor is single threaded\n\n\nThe code within a single actor is never run concurrently. This means that, within a single actor, data updates cannot cause problems. It's only when we want to share data between actors that we have problems.\n\n\nOK, safely sharing data concurrently is tricky. How do reference capabilities help?\n\n\nBy sharing only immutable data and exchanging only isolated data we can have safe concurrent programs without locks. The problem is that it's very difficult to do that correctly. If you accidentally hang on to a reference to some isolated data you've handed over or change something you've shared as immutable then everything goes wrong. What you need is for the compiler to force you to live up to your promises. Pony reference capabilities allow the compiler to do just that.\n\n\nType qualifiers\n\n\nIf you've used C/C++, you may be familiar with \nconst\n, which is a \ntype qualifier\n that tells the compiler not to allow the programmer to \nmutate\n something.\n\n\nA reference capability is a form of \ntype qualifier\n and provides a lot more guarantees than \nconst\n does!\n\n\nIn Pony, every use of a type has a reference capability. These capabilities apply to variables, rather than to the type as a whole. In other words, when you define a \nclass Wombat\n, you don't pick a reference capability for it. Instead, \nWombat\n variables each have their own reference capability.\n\n\nAs an example, in some languages you have to define a type that represents a mutable \nString\n and another type that represents an immutable \nString\n. For example, in Java there is a \nString\n and a \nStringBuilder\n. In Pony, you can define a single \nclass String\n and have some variables that are \nString ref\n (which are mutable) and other variables that are \nString val\n (which are immutable).\n\n\nThe list of reference capabilities\n\n\nThere are six reference capabilities in Pony and they all have strict definitions and rules on how they can be used. We'll get to all of that later, but for now here are their names and what you use them for:\n\n\nIsolated\n, written \niso\n. This is for references to isolated data structures. If you have an \niso\n variable then you know that there are no other variables that can access that data. So you can change it however you like and give it to another actor.\n\n\nValue\n, written \nval\n. This is for references to immutable data structures. If you have a \nval\n variable then you know that no-one can change the data. So you can read it and share it with other actors.\n\n\nReference\n, written \nref\n. This is for references to mutable data structures that are not isolated, in other words \"normal\" data. If you have a \nref\n variable then you can read and write the data however you like and you can have multiple variables that can access the same data. But you can't share it with other actors.\n\n\nBox\n. This is for references to data that is read-only to you. That data might be immutable and shared with other actors or there may be other variables using it in your actor that can change the data. Either way the \nbox\n variable can be used to safely read the data. This may sound a little pointless, but it allows you to write code that can work for both \nval\n and \nref\n variables, as long as it doesn't write to the object.\n\n\nTransition\n, written \ntrn\n. This is used for data structures that you want to write to and give out read-only (\nbox\n) variables to. You can also convert the \ntrn\n variable to a \nval\n variable later if you wish, which stops anyone from changing the data and allows it be shared with other actors.\n\n\nTag\n. This is for references used only for identification. You cannot read or write data using a \ntag\n variable. But you can store and compare \ntag\ns to check object identity and share \ntag\n variables with other actors.\n\n\nNote that if you have a variable referring to an actor then you can send messages to that actor regardless of what reference capability that variable has.\n\n\nHow to write a reference capability\n\n\nA reference capability comes at the end of a type. So, for example:\n\n\nString iso // An isolated string\nString trn // A transition string\nString ref // A string reference\nString val // A string value\nString box // A string box\nString tag // A string tag\n\n\n\n\nWhat does it mean when a type doesn't specify a reference capability?\n It means you are using the \ndefault\n reference capability for that type, which is defined along with the type. Here's an example from the standard library:\n\n\nclass String val\n\n\n\n\nWhen we use a \nString\n we usually mean a string value, so we make \nval\n the default reference capability for \nString\n.\n\n\nSo do I have to specify a reference capability when I define a type?\n Only if you want to. There are sensible defaults that most types will use. These are \nref\n for classes, \nval\n for primitives (i.e. immutable references) and \ntag\n for actors.\nSo the default for any mutable reference capability is \niso\n and the default for any immutable reference capability is \nval\n.", 
            "title": "Reference capabilities"
        }, 
        {
            "location": "/capabilities/reference-capabilities/#rights-are-part-of-a-capability", 
            "text": "If you open a file in UNIX, and get a file descriptor back, that file descriptor is token that designates an object - but it isn't a capability. To be a capability, we need to open that file with some permission - some access right. For example:  int fd = open( /etc/passwd , O_RDWR);  Now we have a token, and a set of rights.  In Pony, every reference has both a type and a reference capability. In fact, the reference capability is  part  of its type. These allow you to specify which of your objects can be shared with other actors and allow the compiler to check that what you're doing is concurrency safe.", 
            "title": "Rights are part of a capability"
        }, 
        {
            "location": "/capabilities/reference-capabilities/#basic-concepts", 
            "text": "There are a few simple concepts you need to understand before reference capabilities will make any sense. We've talked about some of these already, and some may already be obvious to you, but it's worth recapping here.  Shared mutable data is hard  The problem with concurrency is shared mutable data. If two different threads have access to the same piece of data then they might try to update it at the same time. At best this can lead to the two threads having different versions of the data. At worst the updates can interact badly resulting in the data being overwritten with garbage. The standard way to avoid these problems is to use locks to prevent data updates from happening at the same time. This causes big performance hits and is very difficult to get right, so it causes lots of bugs.  Immutable data can be safely shared  Any data that is immutable (i.e. it cannot be changed) is safe to use concurrently. Since it is immutable it is never updated and it's the updates that cause concurrency problems.  Isolated data is safe  If a block of data has only one reference to it then we call it  isolated . Since there is only one reference to it, isolated data cannot be  shared  by multiple threads, so there are no concurrency problems. Isolated data can be passed between multiple threads. As long as only one of them has a reference to it at a time then the data is still safe from concurrency problems.  Isolated data may be complex  An isolated piece of data may be a single byte. But it can also be a large data structure with multiple references between the various objects in that structure. What matters for the data to be isolated is that there is only a single reference to that structure as a whole. We talk about the  isolation boundary  of a data structure. For the structure to be isolated:   There must only be a single reference outside the boundary that points to an object inside.  There can be any number of references inside the boundary, but none of them must point to an object outside.   Every actor is single threaded  The code within a single actor is never run concurrently. This means that, within a single actor, data updates cannot cause problems. It's only when we want to share data between actors that we have problems.  OK, safely sharing data concurrently is tricky. How do reference capabilities help?  By sharing only immutable data and exchanging only isolated data we can have safe concurrent programs without locks. The problem is that it's very difficult to do that correctly. If you accidentally hang on to a reference to some isolated data you've handed over or change something you've shared as immutable then everything goes wrong. What you need is for the compiler to force you to live up to your promises. Pony reference capabilities allow the compiler to do just that.", 
            "title": "Basic concepts"
        }, 
        {
            "location": "/capabilities/reference-capabilities/#type-qualifiers", 
            "text": "If you've used C/C++, you may be familiar with  const , which is a  type qualifier  that tells the compiler not to allow the programmer to  mutate  something.  A reference capability is a form of  type qualifier  and provides a lot more guarantees than  const  does!  In Pony, every use of a type has a reference capability. These capabilities apply to variables, rather than to the type as a whole. In other words, when you define a  class Wombat , you don't pick a reference capability for it. Instead,  Wombat  variables each have their own reference capability.  As an example, in some languages you have to define a type that represents a mutable  String  and another type that represents an immutable  String . For example, in Java there is a  String  and a  StringBuilder . In Pony, you can define a single  class String  and have some variables that are  String ref  (which are mutable) and other variables that are  String val  (which are immutable).", 
            "title": "Type qualifiers"
        }, 
        {
            "location": "/capabilities/reference-capabilities/#the-list-of-reference-capabilities", 
            "text": "There are six reference capabilities in Pony and they all have strict definitions and rules on how they can be used. We'll get to all of that later, but for now here are their names and what you use them for:  Isolated , written  iso . This is for references to isolated data structures. If you have an  iso  variable then you know that there are no other variables that can access that data. So you can change it however you like and give it to another actor.  Value , written  val . This is for references to immutable data structures. If you have a  val  variable then you know that no-one can change the data. So you can read it and share it with other actors.  Reference , written  ref . This is for references to mutable data structures that are not isolated, in other words \"normal\" data. If you have a  ref  variable then you can read and write the data however you like and you can have multiple variables that can access the same data. But you can't share it with other actors.  Box . This is for references to data that is read-only to you. That data might be immutable and shared with other actors or there may be other variables using it in your actor that can change the data. Either way the  box  variable can be used to safely read the data. This may sound a little pointless, but it allows you to write code that can work for both  val  and  ref  variables, as long as it doesn't write to the object.  Transition , written  trn . This is used for data structures that you want to write to and give out read-only ( box ) variables to. You can also convert the  trn  variable to a  val  variable later if you wish, which stops anyone from changing the data and allows it be shared with other actors.  Tag . This is for references used only for identification. You cannot read or write data using a  tag  variable. But you can store and compare  tag s to check object identity and share  tag  variables with other actors.  Note that if you have a variable referring to an actor then you can send messages to that actor regardless of what reference capability that variable has.", 
            "title": "The list of reference capabilities"
        }, 
        {
            "location": "/capabilities/reference-capabilities/#how-to-write-a-reference-capability", 
            "text": "A reference capability comes at the end of a type. So, for example:  String iso // An isolated string\nString trn // A transition string\nString ref // A string reference\nString val // A string value\nString box // A string box\nString tag // A string tag  What does it mean when a type doesn't specify a reference capability?  It means you are using the  default  reference capability for that type, which is defined along with the type. Here's an example from the standard library:  class String val  When we use a  String  we usually mean a string value, so we make  val  the default reference capability for  String .  So do I have to specify a reference capability when I define a type?  Only if you want to. There are sensible defaults that most types will use. These are  ref  for classes,  val  for primitives (i.e. immutable references) and  tag  for actors.\nSo the default for any mutable reference capability is  iso  and the default for any immutable reference capability is  val .", 
            "title": "How to write a reference capability"
        }, 
        {
            "location": "/capabilities/guarantees/", 
            "text": "Since types are guarantees, it's useful to talk about what guarantees a reference capability makes.\n\n\nWhat is denied\n\n\nWe're going to talk about reference capability guarantees in terms of what's \ndenied\n. By this, we mean: what can other variables \nnot\n do when you have a variable with a certain reference capability?\n\n\nWe need to distinguish between the actor that contains the variable in question and \nother\n actors.\n\n\nThis is important because data reads and writes from other actors may occur concurrently. If two actors can both read the same data and one of them changes it then it will change under the feet of the other actor. This leads to data-races and the need for locks. By ensuring this situation can never occur Pony eliminates the need for locks.\n\n\nAll code within any one actor always executes sequentially. This means that data accesses from multiple variables within a single actor do not suffer from data-races.\n\n\nMutable reference capabilities\n\n\nThe \nmutable\n reference capabilities are \niso\n, \ntrn\n and \nref\n. These reference capabilities are \nmutable\n because they can be used to both read from and write to an object.\n\n\n\n\nIf an actor has an \niso\n variable, no other variable can be used by \nany\n actor to read from or write to that object. This means an \niso\n variable is the only variable anywhere in the program that can read from or write to that object. It is \nread and write unique\n.\n\n\nIf an actor has a \ntrn\n variable, no other variable can be used by \nany\n actor to write to that object, and no other variable can be used by \nother\n actors to read from or write to that object. This means a \ntrn\n variable is the only variable anywhere in the program that can write to that object, but other variables held by the the same actor may be able to read from it. It is \nwrite unique\n.\n\n\nIf an actor has a \nref\n variable, no other variable can be used by \nother\n actors to read from or write to that object. This means that other variables can be used to read from and write to the object, but only from within the same actor.\n\n\n\n\nWhy can they be used to write?\n Because they all stop \nother\n actors from reading from or writing to the object. Since we know no other actor will be reading, it's safe for us to write to the object, without having to worry about data-races. And since we know no other actor will be writing, it's safe for us to read from the object, too.\n\n\nImmutable reference capabilities\n\n\nThe \nimmutable\n reference capabilities are \nval\n and \nbox\n. These reference capabilities are \nimmutable\n because they can be used to read from an object, but not to write to it.\n\n\n\n\nIf an actor has a \nval\n variable, no other variable can be used by \nany\n actor to write to that object. This means that the object can't \never\n change. It is \nglobally immutable\n.\n\n\nIf an actor has a \nbox\n variable, no other variable can be used by \nother\n actors to write to that object. This means that other actors may be able to read the object and other variables in the same actor may be able to write to it (although not both). In either case it is safe for us to read. The object is \nlocally immutable\n.\n\n\n\n\nWhy can they be used to read but not write?\n Because these reference capabilities only stop \nother\n actors from writing to the object. That means there is no guarantee that \nother\n actors aren't reading from the object, which means it's not safe for us to write to it. It's safe for more than one actor to read from an object at the same time though, so we're allowed to do that.\n\n\nOpaque reference capabilities\n\n\nThere's only one \nopaque\n reference capability, which is \ntag\n. A \ntag\n variable makes no guarantees about other variables at all. As a result, it can't be used to either read from or write to the object.\n\n\nIt's still useful though: you can do identity comparison with it, you can call behaviours on it, and you can call functions on it that only need a \ntag\n receiver.\n\n\nWhy can't \ntag\n be used to read or write?\n Because \ntag\n doesn't stop \nother\n actors from writing to the object. That means if we tried to read, we would have no guarantee that there wasn't some other actor writing to the object, so we might get a race condition.", 
            "title": "Guarantees"
        }, 
        {
            "location": "/capabilities/guarantees/#what-is-denied", 
            "text": "We're going to talk about reference capability guarantees in terms of what's  denied . By this, we mean: what can other variables  not  do when you have a variable with a certain reference capability?  We need to distinguish between the actor that contains the variable in question and  other  actors.  This is important because data reads and writes from other actors may occur concurrently. If two actors can both read the same data and one of them changes it then it will change under the feet of the other actor. This leads to data-races and the need for locks. By ensuring this situation can never occur Pony eliminates the need for locks.  All code within any one actor always executes sequentially. This means that data accesses from multiple variables within a single actor do not suffer from data-races.", 
            "title": "What is denied"
        }, 
        {
            "location": "/capabilities/guarantees/#mutable-reference-capabilities", 
            "text": "The  mutable  reference capabilities are  iso ,  trn  and  ref . These reference capabilities are  mutable  because they can be used to both read from and write to an object.   If an actor has an  iso  variable, no other variable can be used by  any  actor to read from or write to that object. This means an  iso  variable is the only variable anywhere in the program that can read from or write to that object. It is  read and write unique .  If an actor has a  trn  variable, no other variable can be used by  any  actor to write to that object, and no other variable can be used by  other  actors to read from or write to that object. This means a  trn  variable is the only variable anywhere in the program that can write to that object, but other variables held by the the same actor may be able to read from it. It is  write unique .  If an actor has a  ref  variable, no other variable can be used by  other  actors to read from or write to that object. This means that other variables can be used to read from and write to the object, but only from within the same actor.   Why can they be used to write?  Because they all stop  other  actors from reading from or writing to the object. Since we know no other actor will be reading, it's safe for us to write to the object, without having to worry about data-races. And since we know no other actor will be writing, it's safe for us to read from the object, too.", 
            "title": "Mutable reference capabilities"
        }, 
        {
            "location": "/capabilities/guarantees/#immutable-reference-capabilities", 
            "text": "The  immutable  reference capabilities are  val  and  box . These reference capabilities are  immutable  because they can be used to read from an object, but not to write to it.   If an actor has a  val  variable, no other variable can be used by  any  actor to write to that object. This means that the object can't  ever  change. It is  globally immutable .  If an actor has a  box  variable, no other variable can be used by  other  actors to write to that object. This means that other actors may be able to read the object and other variables in the same actor may be able to write to it (although not both). In either case it is safe for us to read. The object is  locally immutable .   Why can they be used to read but not write?  Because these reference capabilities only stop  other  actors from writing to the object. That means there is no guarantee that  other  actors aren't reading from the object, which means it's not safe for us to write to it. It's safe for more than one actor to read from an object at the same time though, so we're allowed to do that.", 
            "title": "Immutable reference capabilities"
        }, 
        {
            "location": "/capabilities/guarantees/#opaque-reference-capabilities", 
            "text": "There's only one  opaque  reference capability, which is  tag . A  tag  variable makes no guarantees about other variables at all. As a result, it can't be used to either read from or write to the object.  It's still useful though: you can do identity comparison with it, you can call behaviours on it, and you can call functions on it that only need a  tag  receiver.  Why can't  tag  be used to read or write?  Because  tag  doesn't stop  other  actors from writing to the object. That means if we tried to read, we would have no guarantee that there wasn't some other actor writing to the object, so we might get a race condition.", 
            "title": "Opaque reference capabilities"
        }, 
        {
            "location": "/capabilities/aliasing/", 
            "text": "Aliasing\n means having more than one variable that points to the same object.\n\n\nIn most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what's being assigned to it, and everything is fine.\n\n\nIn Pony, that works for some reference capabilities, but not all.\n\n\nAliasing and deny guarantees\n\n\nThe reason for this is that the \niso\n reference capability denies other \niso\n variables that point to the same object. That is, you can only have one \niso\n variable pointing to any given object. The same goes for \ntrn\n.\n\n\nfun test(a: Wombat iso) =\n\n  var b: Wombat iso = a // Not allowed!\n\n\n\n\nHere we have some function that gets passed an isolated Wombat. If we try to alias \na\n by assigning it to \nb\n, we'll be breaking reference capability guarantees so the compiler will stop us.\n\n\nWhat can I alias an \niso\n as?\n Since an \niso\n says no other variable can be used by \nany\n actor to read from or write to that object, we can only create aliases to an \niso\n that can neither read nor write. Fortunately, we've got a reference capability that does exactly that: \ntag\n. So we can do this and the compiler will be happy:\n\n\nfun test(a: Wombat iso) =\n\n  var b: Wombat tag = a // Allowed!\n\n\n\n\nWhat about aliasing \ntrn\n?\n Since a \ntrn\n says no other variable can be used by \nany\n actor to write to that object, we need something that doesn't allow writing, but also doesn't prevent our \ntrn\n variable from writing. Fortunately, weve got a reference capability that does that too: \nbox\n. So we can do this and the compiler will be happy:\n\n\nfun test(a: Wombat trn) =\n\n  var b: Wombat box = a // Allowed!\n\n\n\n\nWhat about aliasing other stuff?\n Everything else can be aliased as itself. So \nref\n can be aliased as \nref\n, \nval\n can be aliased as \nval\n, \nbox\n can be aliased as \nbox\n and \ntag\n can be aliased as \ntag\n.\n\n\nWhat counts as making an alias?\n\n\nThere are two things that count as making an alias:\n\n\n\n\nWhen you \nassign\n a value to a variable. This could be a local variable or a field.\n\n\nWhen you \npass\n a value as an argument to a method.\n\n\n\n\nIn both cases, you are making a new \nname\n for the object. This might be the name of a local variable, the name of a field, or the name of a parameter to a method.\n\n\nEphemeral types\n\n\nIn Pony, every expression has a type. So what's the type of \nconsume a\n? It's not the same type as \na\n, because it might not be possible to alias \na\n. Instead, it's an \nephemeral\n type. That is, it's a type for a value that currently has no name (it might have a name through some other alias, but not the one we just consumed or destructively read).\n\n\nTo show a type is ephemeral, we put a \n^\n at the end. For example:\n\n\nfun test(a: Wombat iso): Wombat iso^ =\n\n  consume a\n\n\n\n\nHere, our function takes an isolated Wombat as a parameter, and returns an ephemeral isolated Wombat.\n\n\nThis is useful for dealing with \niso\n and \ntrn\n types, and for generic types, but it's also important for constructors. A constructor always returns an ephemeral type, because it's a new object.\n\n\nAlias types\n\n\nFor the same reason Pony has ephemeral types, it also has alias types. An alias type is a way of saying \"whatever we can safely alias this thing as\". It's only needed when dealing with generic types, which we'll discuss later.\n\n\nWe indicate an alias type by putting a \n!\n at the end. Here's an example:\n\n\nfun test(a: A) =\n\n  var b: A! = a\n\n\n\n\nHere, we're using \nA\n as a \ntype variable\n, which we'll cover later. So \nA!\n means \"an alias of whatever type \nA\n is\".", 
            "title": "Aliasing"
        }, 
        {
            "location": "/capabilities/aliasing/#aliasing-and-deny-guarantees", 
            "text": "The reason for this is that the  iso  reference capability denies other  iso  variables that point to the same object. That is, you can only have one  iso  variable pointing to any given object. The same goes for  trn .  fun test(a: Wombat iso) = \n  var b: Wombat iso = a // Not allowed!  Here we have some function that gets passed an isolated Wombat. If we try to alias  a  by assigning it to  b , we'll be breaking reference capability guarantees so the compiler will stop us.  What can I alias an  iso  as?  Since an  iso  says no other variable can be used by  any  actor to read from or write to that object, we can only create aliases to an  iso  that can neither read nor write. Fortunately, we've got a reference capability that does exactly that:  tag . So we can do this and the compiler will be happy:  fun test(a: Wombat iso) = \n  var b: Wombat tag = a // Allowed!  What about aliasing  trn ?  Since a  trn  says no other variable can be used by  any  actor to write to that object, we need something that doesn't allow writing, but also doesn't prevent our  trn  variable from writing. Fortunately, weve got a reference capability that does that too:  box . So we can do this and the compiler will be happy:  fun test(a: Wombat trn) = \n  var b: Wombat box = a // Allowed!  What about aliasing other stuff?  Everything else can be aliased as itself. So  ref  can be aliased as  ref ,  val  can be aliased as  val ,  box  can be aliased as  box  and  tag  can be aliased as  tag .", 
            "title": "Aliasing and deny guarantees"
        }, 
        {
            "location": "/capabilities/aliasing/#what-counts-as-making-an-alias", 
            "text": "There are two things that count as making an alias:   When you  assign  a value to a variable. This could be a local variable or a field.  When you  pass  a value as an argument to a method.   In both cases, you are making a new  name  for the object. This might be the name of a local variable, the name of a field, or the name of a parameter to a method.", 
            "title": "What counts as making an alias?"
        }, 
        {
            "location": "/capabilities/aliasing/#ephemeral-types", 
            "text": "In Pony, every expression has a type. So what's the type of  consume a ? It's not the same type as  a , because it might not be possible to alias  a . Instead, it's an  ephemeral  type. That is, it's a type for a value that currently has no name (it might have a name through some other alias, but not the one we just consumed or destructively read).  To show a type is ephemeral, we put a  ^  at the end. For example:  fun test(a: Wombat iso): Wombat iso^ = \n  consume a  Here, our function takes an isolated Wombat as a parameter, and returns an ephemeral isolated Wombat.  This is useful for dealing with  iso  and  trn  types, and for generic types, but it's also important for constructors. A constructor always returns an ephemeral type, because it's a new object.", 
            "title": "Ephemeral types"
        }, 
        {
            "location": "/capabilities/aliasing/#alias-types", 
            "text": "For the same reason Pony has ephemeral types, it also has alias types. An alias type is a way of saying \"whatever we can safely alias this thing as\". It's only needed when dealing with generic types, which we'll discuss later.  We indicate an alias type by putting a  !  at the end. Here's an example:  fun test(a: A) = \n  var b: A! = a  Here, we're using  A  as a  type variable , which we'll cover later. So  A!  means \"an alias of whatever type  A  is\".", 
            "title": "Alias types"
        }, 
        {
            "location": "/capabilities/consume-and-destructive-read/", 
            "text": "Consuming a variable\n\n\nSometimes, you want to \nmove\n an object from one variable to another. In other words, you don't want to make a \nnew\n name for the object, exactly, you want to move the object from some existing name to a different one.\n\n\nYou can do this by using \nconsume\n. When you \nconsume\n a variable you take the value out of it, effectively leaving the variable empty. No code can read from that variable again until a new value is written to it. Consuming a local variable or a parameter allows you to make an alias with the same type, even if it's an \niso\n or \ntrn\n. For example:\n\n\nfun test(a: Wombat iso) =\n\n  var b: Wombat iso = consume a // Allowed!\n\n\n\n\nThe compiler is happy with that, because by consuming \na\n, you've said the value can't be used again and the compiler will complain if you try to.\n\n\nfun test(a: Wombat iso) =\n\n  var b: Wombat iso = consume a // Allowed!\n  var c: Wombat tag = a // Not allowed!\n\n\n\n\nHere's an example of that. When you try to assign \na\n to \nc\n, the compiler will complain.\n\n\nCan I \nconsume\n a field?\n Definitely not! Consuming something means it is empty, that is, it has no value. There's no way to be sure no other alias to the object will access that field. If we tried to access a field that was empty, we would crash. But there's a way to do what you want to do: \ndestructive read\n.\n\n\nDestructive read\n\n\nThere's another way to \nmove\n a value from one name to another. Earlier, we talked about how assignment in Pony returns the \nold\n value of the left-hand side, rather than the new value. This is called \ndestructive read\n, and we can use it to do what we want to do, even with fields.\n\n\nclass Aardvark\n  var buddy: Wombat iso\n\n  fun test(a: Wombat iso) =\n\n    var b: Wombat iso = buddy = consume a // Allowed!\n\n\n\n\nHere, we consume \na\n, assign it to the field \nbuddy\n, and assign the \nold\n value of \nbuddy\n to \nb\n.\n\n\nWhy is it ok to destructively read fields when we can't consume them?\n Because when we do a destructive read, we assign to the field so it always has a value. Unlike \nconsume\n, there's no time when the field is empty. That means it's safe and the compiler doesn't complain.", 
            "title": "Consume and destructive read"
        }, 
        {
            "location": "/capabilities/consume-and-destructive-read/#consuming-a-variable", 
            "text": "Sometimes, you want to  move  an object from one variable to another. In other words, you don't want to make a  new  name for the object, exactly, you want to move the object from some existing name to a different one.  You can do this by using  consume . When you  consume  a variable you take the value out of it, effectively leaving the variable empty. No code can read from that variable again until a new value is written to it. Consuming a local variable or a parameter allows you to make an alias with the same type, even if it's an  iso  or  trn . For example:  fun test(a: Wombat iso) = \n  var b: Wombat iso = consume a // Allowed!  The compiler is happy with that, because by consuming  a , you've said the value can't be used again and the compiler will complain if you try to.  fun test(a: Wombat iso) = \n  var b: Wombat iso = consume a // Allowed!\n  var c: Wombat tag = a // Not allowed!  Here's an example of that. When you try to assign  a  to  c , the compiler will complain.  Can I  consume  a field?  Definitely not! Consuming something means it is empty, that is, it has no value. There's no way to be sure no other alias to the object will access that field. If we tried to access a field that was empty, we would crash. But there's a way to do what you want to do:  destructive read .", 
            "title": "Consuming a variable"
        }, 
        {
            "location": "/capabilities/consume-and-destructive-read/#destructive-read", 
            "text": "There's another way to  move  a value from one name to another. Earlier, we talked about how assignment in Pony returns the  old  value of the left-hand side, rather than the new value. This is called  destructive read , and we can use it to do what we want to do, even with fields.  class Aardvark\n  var buddy: Wombat iso\n\n  fun test(a: Wombat iso) = \n    var b: Wombat iso = buddy = consume a // Allowed!  Here, we consume  a , assign it to the field  buddy , and assign the  old  value of  buddy  to  b .  Why is it ok to destructively read fields when we can't consume them?  Because when we do a destructive read, we assign to the field so it always has a value. Unlike  consume , there's no time when the field is empty. That means it's safe and the compiler doesn't complain.", 
            "title": "Destructive read"
        }, 
        {
            "location": "/capabilities/recovering-capabilities/", 
            "text": "A \nrecover\n expression let's you \"lift\" the reference capability of the result. A mutable reference capability (\niso\n, \ntrn\n, or \nref\n) can become \nany\n reference capability, and an immutable reference capability (\nval\n or \nbox\n) can become any immutable or opaque reference capability.\n\n\nWhy is this useful?\n\n\nThis most straightforward use of \nrecover\n is to get an \niso\n that you can pass to another actor. But it can be used for many other things as well, such as:\n\n\n\n\nCreating a cyclic immutable data structure. That is, you can create a complex mutable data structure inside a \nrecover\n expression, \"lift\" the resulting \nref\n to a \nval\n.\n\n\n\"Borrow\" an \niso\n as a \nref\n, do a series of complex mutable operations on it, and return it as an \niso\n again.\n\n\n\"Extract\" a mutable field from an \niso\n and return it as an \niso\n.\n\n\n\n\nWhat does this look like?\n\n\nrecover Array[String] end\n\n\n\n\nThat's a simple one: it returns an \nArray[String] iso\n, instead of the usual \nArray[String] ref\n you would get.\n\n\nHere's a more complicated example from the standard library:\n\n\nrecover\n  var s = String((prec' + 1).max(width.max(31)))\n  var value = x\n\n  try\n    if value == 0 then\n      s.push(table(0))\n    else\n      while value != 0 do\n        let index = (value = value / base) - (value * base)\n        s.push(table(index.usize()))\n      end\n    end\n  end\n\n  s.append(typestring)\n  _extend_digits(s, prec')\n  s.append(prestring)\n  _pad(s, width, align, fill)\n  s\nend\n\n\n\n\nThat's from \nToString\n. It creates a \nString ref\n, does a bunch of stuff with it, and finally returns it as a \nString iso\n.\n\n\nBoth of those examples use the default reference capability for a \nrecover\n expression, since they don't specify one. The default for any mutable reference capability is \niso\n and the default for any immutable reference capability is \nval\n. You can also give an explicit one:\n\n\nlet key = recover val line.substring(0, i).strip() end\n\n\n\n\nThat's from \nnet/http/_PayloadBuilder\n. We get a substring of \nline\n, which is a \nString iso^\n, then we call trim on it, which returns itself. But since trim is a \nref\n function, it returns itself as a \nString ref^\n - so we use a \nrecover val\n to end up with a \nString val\n.\n\n\nHow does this work?\n\n\nInside the \nrecover\n expression, your code only has access to \nsendable\n values from the enclosing lexical scope. In other words, you can only use \niso\n, \nval\n and \ntag\n things from outside the \nrecover\n expression.\n\n\nThis means that when the \nrecover\n expression finishes, any aliases to the result of the expression other than \niso\n, \nval\n and \ntag\n ones won't exist any more. That makes it safe to \"lift\" the reference capability of the result of the expression.\n\n\nIf the \nrecover\n expression could access \nnon-sendable\n values from the enclosing lexical scope, \"lifting\" the reference capability of the result wouldn't be safe. Some of those values could \"leak\" into an \niso\n or \nval\n result, and result in data-races.\n\n\nAutomatic receiver recovery\n\n\nWhen you have an \niso\n or \ntrn\n receiver, you normally can't call \nref\n methods on it. That's because the receiver is also an argument to a method, which means both the method body and the caller have access to the receiver at the same time. And \nthat\n means we have to alias the receiver when we call a method on it. The alias of an \niso\n is a \ntag\n (which isn't a subtype of \nref\n) and the alias of a \ntrn\n is a \nbox\n (also not a subtype of \nref\n).\n\n\nBut we can get around this! If all the arguments to the method \nat the call-site\n are \nsendable\n, and the return type of the method is either \nsendable\n or isn't used \nat the call-site\n, then we can \"automatically recover\" the receiver. That just means we don't have to alias the receiver - and \nthat\n means we can call \nref\n methods on an \niso\n or \ntrn\n, since \niso\n and \ntrn\n are both subtypes of \nref\n.\n\n\nNotice that this technique looks mostly at the call-site, rather than at the definition of the method being called. That makes it more flexible. For example, if the method being called wants a \nref\n argument, and we pass it an \niso\n argument, that's \nsendable\n at the call-site, so we can still do automatic receiver recovery.\n\n\nThis may sound a little complicated, but in practice it means you can write code that treats an \niso\n mostly like a \nref\n, and the compiler will complain when it's wrong. For example:\n\n\nlet s = recover String end\ns.append(\nhi\n)\n\n\n\n\nHere, we create a \nString iso\n and then append some text to it. The append method takes a \nref\n receiver and a \nbox\n parameter. We can automatically recover the \niso\n receiver, since we pass a \nval\n parameter, so everything is fine.", 
            "title": "Recovering capabilities"
        }, 
        {
            "location": "/capabilities/recovering-capabilities/#why-is-this-useful", 
            "text": "This most straightforward use of  recover  is to get an  iso  that you can pass to another actor. But it can be used for many other things as well, such as:   Creating a cyclic immutable data structure. That is, you can create a complex mutable data structure inside a  recover  expression, \"lift\" the resulting  ref  to a  val .  \"Borrow\" an  iso  as a  ref , do a series of complex mutable operations on it, and return it as an  iso  again.  \"Extract\" a mutable field from an  iso  and return it as an  iso .", 
            "title": "Why is this useful?"
        }, 
        {
            "location": "/capabilities/recovering-capabilities/#what-does-this-look-like", 
            "text": "recover Array[String] end  That's a simple one: it returns an  Array[String] iso , instead of the usual  Array[String] ref  you would get.  Here's a more complicated example from the standard library:  recover\n  var s = String((prec' + 1).max(width.max(31)))\n  var value = x\n\n  try\n    if value == 0 then\n      s.push(table(0))\n    else\n      while value != 0 do\n        let index = (value = value / base) - (value * base)\n        s.push(table(index.usize()))\n      end\n    end\n  end\n\n  s.append(typestring)\n  _extend_digits(s, prec')\n  s.append(prestring)\n  _pad(s, width, align, fill)\n  s\nend  That's from  ToString . It creates a  String ref , does a bunch of stuff with it, and finally returns it as a  String iso .  Both of those examples use the default reference capability for a  recover  expression, since they don't specify one. The default for any mutable reference capability is  iso  and the default for any immutable reference capability is  val . You can also give an explicit one:  let key = recover val line.substring(0, i).strip() end  That's from  net/http/_PayloadBuilder . We get a substring of  line , which is a  String iso^ , then we call trim on it, which returns itself. But since trim is a  ref  function, it returns itself as a  String ref^  - so we use a  recover val  to end up with a  String val .", 
            "title": "What does this look like?"
        }, 
        {
            "location": "/capabilities/recovering-capabilities/#how-does-this-work", 
            "text": "Inside the  recover  expression, your code only has access to  sendable  values from the enclosing lexical scope. In other words, you can only use  iso ,  val  and  tag  things from outside the  recover  expression.  This means that when the  recover  expression finishes, any aliases to the result of the expression other than  iso ,  val  and  tag  ones won't exist any more. That makes it safe to \"lift\" the reference capability of the result of the expression.  If the  recover  expression could access  non-sendable  values from the enclosing lexical scope, \"lifting\" the reference capability of the result wouldn't be safe. Some of those values could \"leak\" into an  iso  or  val  result, and result in data-races.", 
            "title": "How does this work?"
        }, 
        {
            "location": "/capabilities/recovering-capabilities/#automatic-receiver-recovery", 
            "text": "When you have an  iso  or  trn  receiver, you normally can't call  ref  methods on it. That's because the receiver is also an argument to a method, which means both the method body and the caller have access to the receiver at the same time. And  that  means we have to alias the receiver when we call a method on it. The alias of an  iso  is a  tag  (which isn't a subtype of  ref ) and the alias of a  trn  is a  box  (also not a subtype of  ref ).  But we can get around this! If all the arguments to the method  at the call-site  are  sendable , and the return type of the method is either  sendable  or isn't used  at the call-site , then we can \"automatically recover\" the receiver. That just means we don't have to alias the receiver - and  that  means we can call  ref  methods on an  iso  or  trn , since  iso  and  trn  are both subtypes of  ref .  Notice that this technique looks mostly at the call-site, rather than at the definition of the method being called. That makes it more flexible. For example, if the method being called wants a  ref  argument, and we pass it an  iso  argument, that's  sendable  at the call-site, so we can still do automatic receiver recovery.  This may sound a little complicated, but in practice it means you can write code that treats an  iso  mostly like a  ref , and the compiler will complain when it's wrong. For example:  let s = recover String end\ns.append( hi )  Here, we create a  String iso  and then append some text to it. The append method takes a  ref  receiver and a  box  parameter. We can automatically recover the  iso  receiver, since we pass a  val  parameter, so everything is fine.", 
            "title": "Automatic receiver recovery"
        }, 
        {
            "location": "/capabilities/combining-capabilities/", 
            "text": "When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the \norigin\n, that is, the object the field is being read from.\n\n\nThis is because all the guarantees that the \norigin\n reference capability makes have to be maintained for its fields as well.\n\n\nViewpoint adaptation\n\n\nThe process of combining origin and field capabilties is called \nviewpoint adaptation\n. That is, the \norigin\n has a \nviewpoint\n, and can \"see\" its fields only from that \nviewpoint\n.\n\n\nLet's start with a table. This shows how \nfields\n of each capability \"look\" to \norigins\n of each capability.\n\n\n\n\n\n\n\n\n\n\n\n\niso field\n\n\ntrn field\n\n\nref field\n\n\nval field\n\n\nbox field\n\n\ntag field\n\n\n\n\n\n\n\n\n\n\niso origin\n\n\niso\n\n\ntag\n\n\ntag\n\n\nval\n\n\ntag\n\n\ntag\n\n\n\n\n\n\ntrn origin\n\n\niso\n\n\ntrn\n\n\nbox\n\n\nval\n\n\nbox\n\n\ntag\n\n\n\n\n\n\nref origin\n\n\niso\n\n\ntrn\n\n\nref\n\n\nval\n\n\nbox\n\n\ntag\n\n\n\n\n\n\nval origin\n\n\nval\n\n\nval\n\n\nval\n\n\nval\n\n\nval\n\n\ntag\n\n\n\n\n\n\nbox origin\n\n\ntag\n\n\nbox\n\n\nbox\n\n\nval\n\n\nbox\n\n\ntag\n\n\n\n\n\n\ntag origin\n\n\nn/a\n\n\nn/a\n\n\nn/a\n\n\nn/a\n\n\nn/a\n\n\nn/a\n\n\n\n\n\n\n\n\n\n\nFor example, if you have a \ntrn\n origin and you read a \nref\n field, you get a \nbox\n result:\n\n\nclass Foo\n  var x: String ref\n\nclass Bar\n  fun f() =\n\n    var y: Foo trn = getTrnFoo()\n    var z: String box = y.x\n\n\n\n\nExplaining why\n\n\nThat table will seem totally natural to you, eventually. But probably not yet. To help it seem natural, let's walk through each cell in the table and explain why it is the way it is.\n\n\nReading from an \niso\n variable\n\n\nAnything read through an \niso\n origin has to maintain the isolation guarantee that the origin has. The key thing to remember is that the \niso\n can be sent to another actor and it can also become any other reference capability. So when we read a field, we need to get a result that won't ever break the isolation guarantees that the origin makes, that is, \nread and write uniqueness\n.\n\n\nAn \niso\n field makes the same guarantees as an \niso\n origin, so that's fine to read. A \nval\n field is \nglobally immutable\n, which means it's always ok to read it, no matter what the origin is (well, other than \ntag\n).\n\n\nEverything else, though, can break our isolation guarantees. That's why other reference capabilities are seen as \ntag\n: it's the only type that is neither readable nor writeable.\n\n\nReading from a \ntrn\n variable\n\n\nThis is like \niso\n, but with a weaker guarantee (\nwrite uniqueness\n as opposed to \nread and write uniqueness\n). That makes a big difference, since now we can return something readable when we enforce our guarantees.\n\n\nAn \niso\n field makes stronger guarantees than a \ntrn\n origin, and a \ntrn\n field makes the same guarantees, so they're fine to read. A \nval\n field is \nglobally immutable\n, so that's fine too. A \nbox\n field is readable, and we only guarantee \nwrite uniqueness\n, so that's fine too.\n\n\nA \nref\n field, though, would allow writing. So instead we return a \nbox\n.\n\n\nReading from a \nref\n variable\n\n\nA \nref\n origin doesn't modify its fields at all. This is because a \nref\n origin doesn't make any guarantees that are incompatible with its fields.\n\n\nReading from a \nval\n variable\n\n\nA \nval\n origin is deeply and globally immutable, so all of its fields are also \nval\n. The only exception is a \ntag\n field. Since we can't read from it, we also can't guarantee that nobody can write to it, so it stays \ntag\n.\n\n\nReading from a \nbox\n variable\n\n\nA \nbox\n variable is locally immutable. This means it's possible that it may be mutated through some other variable (a \ntrn\n or a \nref\n), but it's also possible that our \nbox\n variable is an alias of some \nval\n variable.\n\n\nWhen we read a field, we need to return a reference capability that is compatible with the field, but is also locally immutable.\n\n\nAn \niso\n field is returned as a \ntag\n because no locally immutable reference capability can maintain its isolation guarantees. A \nval\n field is returned as a \nval\n because global immutability is a stronger guarantee than local immutability. A \nbox\n field makes the same local immutability guarantee as its origin, so that's also fine.\n\n\nFor \ntrn\n and \nref\n we need to return a locally immutable reference capability that doesn't violate any guarantees the field makes. In both cases, we can return \nbox\n.\n\n\nReading from a \ntag\n variable\n\n\nThis one is easy: \ntag\n variables are opaque! They can't be read from.", 
            "title": "Combining capabilities"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#viewpoint-adaptation", 
            "text": "The process of combining origin and field capabilties is called  viewpoint adaptation . That is, the  origin  has a  viewpoint , and can \"see\" its fields only from that  viewpoint .  Let's start with a table. This shows how  fields  of each capability \"look\" to  origins  of each capability.       iso field  trn field  ref field  val field  box field  tag field      iso origin  iso  tag  tag  val  tag  tag    trn origin  iso  trn  box  val  box  tag    ref origin  iso  trn  ref  val  box  tag    val origin  val  val  val  val  val  tag    box origin  tag  box  box  val  box  tag    tag origin  n/a  n/a  n/a  n/a  n/a  n/a      For example, if you have a  trn  origin and you read a  ref  field, you get a  box  result:  class Foo\n  var x: String ref\n\nclass Bar\n  fun f() = \n    var y: Foo trn = getTrnFoo()\n    var z: String box = y.x", 
            "title": "Viewpoint adaptation"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#explaining-why", 
            "text": "That table will seem totally natural to you, eventually. But probably not yet. To help it seem natural, let's walk through each cell in the table and explain why it is the way it is.", 
            "title": "Explaining why"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-an-iso-variable", 
            "text": "Anything read through an  iso  origin has to maintain the isolation guarantee that the origin has. The key thing to remember is that the  iso  can be sent to another actor and it can also become any other reference capability. So when we read a field, we need to get a result that won't ever break the isolation guarantees that the origin makes, that is,  read and write uniqueness .  An  iso  field makes the same guarantees as an  iso  origin, so that's fine to read. A  val  field is  globally immutable , which means it's always ok to read it, no matter what the origin is (well, other than  tag ).  Everything else, though, can break our isolation guarantees. That's why other reference capabilities are seen as  tag : it's the only type that is neither readable nor writeable.", 
            "title": "Reading from an iso variable"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-a-trn-variable", 
            "text": "This is like  iso , but with a weaker guarantee ( write uniqueness  as opposed to  read and write uniqueness ). That makes a big difference, since now we can return something readable when we enforce our guarantees.  An  iso  field makes stronger guarantees than a  trn  origin, and a  trn  field makes the same guarantees, so they're fine to read. A  val  field is  globally immutable , so that's fine too. A  box  field is readable, and we only guarantee  write uniqueness , so that's fine too.  A  ref  field, though, would allow writing. So instead we return a  box .", 
            "title": "Reading from a trn variable"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-a-ref-variable", 
            "text": "A  ref  origin doesn't modify its fields at all. This is because a  ref  origin doesn't make any guarantees that are incompatible with its fields.", 
            "title": "Reading from a ref variable"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-a-val-variable", 
            "text": "A  val  origin is deeply and globally immutable, so all of its fields are also  val . The only exception is a  tag  field. Since we can't read from it, we also can't guarantee that nobody can write to it, so it stays  tag .", 
            "title": "Reading from a val variable"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-a-box-variable", 
            "text": "A  box  variable is locally immutable. This means it's possible that it may be mutated through some other variable (a  trn  or a  ref ), but it's also possible that our  box  variable is an alias of some  val  variable.  When we read a field, we need to return a reference capability that is compatible with the field, but is also locally immutable.  An  iso  field is returned as a  tag  because no locally immutable reference capability can maintain its isolation guarantees. A  val  field is returned as a  val  because global immutability is a stronger guarantee than local immutability. A  box  field makes the same local immutability guarantee as its origin, so that's also fine.  For  trn  and  ref  we need to return a locally immutable reference capability that doesn't violate any guarantees the field makes. In both cases, we can return  box .", 
            "title": "Reading from a box variable"
        }, 
        {
            "location": "/capabilities/combining-capabilities/#reading-from-a-tag-variable", 
            "text": "This one is easy:  tag  variables are opaque! They can't be read from.", 
            "title": "Reading from a tag variable"
        }, 
        {
            "location": "/capabilities/passing-and-sharing/", 
            "text": "Reference capabilities make it safe to both \npass\n mutable data between actors and to \nshare\n immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact no runtime overhead at all.\n\n\nPassing\n\n\nFor an object to be mutable, we need to be sure that no \nother\n actor can read from or write to that object. The three mutable reference capabilities (\niso\n, \ntrn\n, and \nref\n) all make that guarantee.\n\n\nBut what if we want to pass a mutable object from one actor to another? To do that, we need to be sure that the actor that is \nsending\n the mutable object also \ngives up\n the ability to both read from and write to that object.\n\n\nThis is exactly what \niso\n does. It is \nread and write unique\n, there can only be one reference at a time that can be used for reading or writing. If you send an \niso\n object to another actor, you will be giving up the ability to read from or write to that object.\n\n\nSo I should use \niso\n when I want to pass a mutable object between actors?\n Yes! If you don't need to pass it, you can just use \nref\n instead.\n\n\nSharing\n\n\nIf you want to \nshare\n an object amongst actors, then we have to make one of the following guarantees:\n\n\n\n\nEither \nno\n actor can write to the object, in which case \nany\n actor can read from it, or\n\n\nOnly \none\n actor can write to the object, in which case \nother\n actors can neither read from or write to the object.\n\n\n\n\nThe first guarantee is exactly what \nval\n does. It is \nglobally immutable\n, so we know that \nno\n actor can ever write to that object. As a result, you can freely send \nval\n objects to other actors, without needing to give up the ability to read from that object.\n\n\nSo I should use \nval\n when I want to share an immutable object amongst actors?\n Yes! If you don't need to share it, you can just use \nref\n instead, or \nbox\n if you want it to be immutable.\n\n\nThe second guarantee is what \ntag\n does. Not the part about only one actor writing (that's guaranteed by any mutable reference capability), but the part about not being able to read from or write to an object. That means you can freely pass \ntag\n objects to other actors, without needing to give up the ability to read from or write to that object.\n\n\nWhat's the point in sending a tag reference to another actor if it can't then read of write the fields?\n Because \ntag\n \ncan\n be used to \nidentify\n objects and sometimes that's all you need. Also, if the object is an actor you can call behaviours on it even though you only have a \ntag\n.\n\n\nSo I should use \ntag\n when I want to share the identity of a mutable object amongst actors?\n Yes! Or, really, the identity of anything, whether it's mutable, immutable, or even an actor.\n\n\nReference capabilities that can't be sent\n\n\nYou may have noticed we didn't mention \ntrn\n, \nref\n, or \nbox\n as things you can send to other actors. That's because you can't do it. They don't make the guarantees we need in order to be safe.\n\n\nSo when should you use those reference capabilities?\n\n\n\n\nUse \nref\n when you need to be able to change an object over time. On the other hand, if your program wouldn't be any slower if you used an immutable type instead, you may want to use a \nval\n anyway.\n\n\nUse \nbox\n when you don't care whether the object is mutable or immutable. In other words, you want to be able to read from it, but you don't need to write to it or share it with other actors.\n\n\nUse \ntrn\n when you want to be able to change an object for a while, but you also want to be able to make it \nglobally immutable\n later.", 
            "title": "Passing and sharing"
        }, 
        {
            "location": "/capabilities/passing-and-sharing/#passing", 
            "text": "For an object to be mutable, we need to be sure that no  other  actor can read from or write to that object. The three mutable reference capabilities ( iso ,  trn , and  ref ) all make that guarantee.  But what if we want to pass a mutable object from one actor to another? To do that, we need to be sure that the actor that is  sending  the mutable object also  gives up  the ability to both read from and write to that object.  This is exactly what  iso  does. It is  read and write unique , there can only be one reference at a time that can be used for reading or writing. If you send an  iso  object to another actor, you will be giving up the ability to read from or write to that object.  So I should use  iso  when I want to pass a mutable object between actors?  Yes! If you don't need to pass it, you can just use  ref  instead.", 
            "title": "Passing"
        }, 
        {
            "location": "/capabilities/passing-and-sharing/#sharing", 
            "text": "If you want to  share  an object amongst actors, then we have to make one of the following guarantees:   Either  no  actor can write to the object, in which case  any  actor can read from it, or  Only  one  actor can write to the object, in which case  other  actors can neither read from or write to the object.   The first guarantee is exactly what  val  does. It is  globally immutable , so we know that  no  actor can ever write to that object. As a result, you can freely send  val  objects to other actors, without needing to give up the ability to read from that object.  So I should use  val  when I want to share an immutable object amongst actors?  Yes! If you don't need to share it, you can just use  ref  instead, or  box  if you want it to be immutable.  The second guarantee is what  tag  does. Not the part about only one actor writing (that's guaranteed by any mutable reference capability), but the part about not being able to read from or write to an object. That means you can freely pass  tag  objects to other actors, without needing to give up the ability to read from or write to that object.  What's the point in sending a tag reference to another actor if it can't then read of write the fields?  Because  tag   can  be used to  identify  objects and sometimes that's all you need. Also, if the object is an actor you can call behaviours on it even though you only have a  tag .  So I should use  tag  when I want to share the identity of a mutable object amongst actors?  Yes! Or, really, the identity of anything, whether it's mutable, immutable, or even an actor.", 
            "title": "Sharing"
        }, 
        {
            "location": "/capabilities/passing-and-sharing/#reference-capabilities-that-cant-be-sent", 
            "text": "You may have noticed we didn't mention  trn ,  ref , or  box  as things you can send to other actors. That's because you can't do it. They don't make the guarantees we need in order to be safe.  So when should you use those reference capabilities?   Use  ref  when you need to be able to change an object over time. On the other hand, if your program wouldn't be any slower if you used an immutable type instead, you may want to use a  val  anyway.  Use  box  when you don't care whether the object is mutable or immutable. In other words, you want to be able to read from it, but you don't need to write to it or share it with other actors.  Use  trn  when you want to be able to change an object for a while, but you also want to be able to make it  globally immutable  later.", 
            "title": "Reference capabilities that can't be sent"
        }, 
        {
            "location": "/capabilities/capability-subtyping/", 
            "text": "Subtyping is about \nsubstitutability\n. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.\n\n\nSimple substitution\n\n\nFirst, let's cover substitution without worrying about ephemeral types (\n^\n) or alias types (\n!\n). The \n:\n symbol means \"is a subtype of\" or alternatively \"can be substituted for\".\n\n\n\n\niso \n: trn\n. An \niso\n is \nread and write unique\n, and a \ntrn\n is just \nwrite unique\n, so it's safe to substitute an \niso\n for a \ntrn\n.\n\n\ntrn \n: ref\n. A \ntrn\n is mutable and also \nwrite unique\n. A \nref\n is mutable, but makes no uniqueness guarantees. It's safe to substitute a \ntrn\n for a \nref\n.\n\n\ntrn \n: val\n. This one is interesting. A \ntrn\n is \nwrite unique\n and a \nval\n is \nglobally immutable\n, so why is it safe to substitute a \ntrn\n for a \nval\n? The key is that, in order to do so, you have to \ngive up\n the \ntrn\n you have. If you give up the \nonly\n variable that can write to an object, you know that no variable can write to it. That means it's safe to consider it \nglobally immutable\n.\n\n\nref \n: box\n. A \nref\n guarantees no \nother\n actor can read from or write to the object. A \nbox\n just guarantees no \nother\n actor can write to the object, so it's safe to substitute a \nref\n for a \nbox\n.\n\n\nval \n: box\n. A \nval\n guarantees \nno\n actor, not even this one, can write to the object. A \nbox\n just guarantees no \nother\n actor can write to the object, so it's safe to substitute a \nval\n for a \nbox\n.\n\n\nbox \n: tag\n. A \nbox\n guarantees no other actor can write to the object, and a \ntag\n makes no guarantees at all, so it's safe to substitute a \nbox\n for a \ntag\n.\n\n\n\n\nSubtyping is \ntransitive\n. That means that since \niso \n: trn\n and \ntrn \n: ref\n and \nref \n: box\n, we also get \niso \n: box\n.\n\n\nAliased substitution\n\n\nNow let's consider what happens when we have an alias of a reference capability. For example, if we have some \niso\n and we alias it (without doing a \nconsume\n or a destructive read), the type we get is \niso!\n, not \niso\n.\n\n\n\n\niso! \n: tag\n. This is a pretty big change. Instead of being a subtype of everything like \niso\n, the only thing an \niso!\n is a subtype of is \ntag\n. This is because the \niso\n still exists, and is still \nread and write unique\n. Any alias can neither read from nor write to the object. That means an \niso!\n can only be a subtype of \ntag\n.\n\n\ntrn! \n: box\n. This is a change too, but not as big a change. Since \ntrn\n is only \nwrite unique\n, it's ok for aliases to read from the object, but it's not ok for aliases to write to the object. That means we could have \nbox\n or \nval\n aliases - except \nval\n guarantees that \nno\n alias can write the the object! Since our \ntrn\n still exists, and can write to the object, a \nval\n alias would break the guarantees that \nval\n makes. So a \ntrn!\n can only be a subtype of \nbox\n (and, transitively, \ntag\n as well).\n\n\nref! \n: ref\n. Since a \nref\n only guarantees that \nother\n actors can neither read from nor write to the object, it's ok to make more \nref\n aliases within the same actor.\n\n\nval! \n: val\n. Since a \nval\n only guarantees that \nno\n actor can write to the object, its ok to make more \nval\n aliases, since they can't write to the object wither.\n\n\nbox! \n: box\n. A \nbox\n only guarantees that \nother\n actors can't write to the object. Both \nval\n and \nref\n make that guarantee too, so why can \nbox\n only alias as \nbox\n? It's because we can't make \nmore\n guarantees when we alias something. That means \nbox\n can only alias as \nbox\n.\n\n\ntag! \n: tag\n. A \ntag\n doesn't make any guarantees at all. Just like with a \nbox\n, we can't make more guarantees when we make a new alias, so a \ntag\n can only alias as a \ntag\n.\n\n\n\n\nEphemeral substitution\n\n\nThe last case to consider is when we have an ephemeral reference capability. For example, if we have some \niso\n and we \nconsume\n it or do a destructive read, the type we get is \niso^\n, not \niso\n.\n\n\n\n\niso^ \n: iso\n. This is pretty simple. When we givean \niso^\n a name, by assigning it to something or passing it as an argument to a method, it loses the \n^\n and becomes a plain old \niso\n. We know we gave up our previous \niso\n, so it's safe to have a new one.\n\n\ntrn^ \n: trn\n. This works exactly like \niso^\n. The guarantee is weaker (\nwrite uniqueness\n instead of \nread and write uniqueness\n), but it works the same way.\n\n\nref^ \n: ref^\n and \nref^ \n: ref\n and \nref \n: ref^\n. Here, we have another case. Not only is a \nref^\n a subtype of a \nref\n, it's also a subtype of a \nref^\n. What's going on here? The reason is that an ephemeral reference capability is a way of saying \"a reference capability that, when aliased, results in the base reference capability\". Since a \nref\n can be aliased as a \nref\n, that means \nref\n and \nref^\n are completely interchangeable.\n\n\nval^\n, \nbox^\n, \ntag^\n. These all work the same way as \nref\n, that is, they are interchangeable with the base reference capability. It's for the same reason: all of these reference capabilities can be aliased as themselves.\n\n\n\n\nWhy do \nref^\n, \nval^\n, \nbox^\n, and \ntag^\n exist if they are interchangeable with their base reference capabilities?\n It's for two reasons: \nreference capability recovery\n and \ngenerics\n. We'll cover both of those later.", 
            "title": "Capability subtyping"
        }, 
        {
            "location": "/capabilities/capability-subtyping/#simple-substitution", 
            "text": "First, let's cover substitution without worrying about ephemeral types ( ^ ) or alias types ( ! ). The  :  symbol means \"is a subtype of\" or alternatively \"can be substituted for\".   iso  : trn . An  iso  is  read and write unique , and a  trn  is just  write unique , so it's safe to substitute an  iso  for a  trn .  trn  : ref . A  trn  is mutable and also  write unique . A  ref  is mutable, but makes no uniqueness guarantees. It's safe to substitute a  trn  for a  ref .  trn  : val . This one is interesting. A  trn  is  write unique  and a  val  is  globally immutable , so why is it safe to substitute a  trn  for a  val ? The key is that, in order to do so, you have to  give up  the  trn  you have. If you give up the  only  variable that can write to an object, you know that no variable can write to it. That means it's safe to consider it  globally immutable .  ref  : box . A  ref  guarantees no  other  actor can read from or write to the object. A  box  just guarantees no  other  actor can write to the object, so it's safe to substitute a  ref  for a  box .  val  : box . A  val  guarantees  no  actor, not even this one, can write to the object. A  box  just guarantees no  other  actor can write to the object, so it's safe to substitute a  val  for a  box .  box  : tag . A  box  guarantees no other actor can write to the object, and a  tag  makes no guarantees at all, so it's safe to substitute a  box  for a  tag .   Subtyping is  transitive . That means that since  iso  : trn  and  trn  : ref  and  ref  : box , we also get  iso  : box .", 
            "title": "Simple substitution"
        }, 
        {
            "location": "/capabilities/capability-subtyping/#aliased-substitution", 
            "text": "Now let's consider what happens when we have an alias of a reference capability. For example, if we have some  iso  and we alias it (without doing a  consume  or a destructive read), the type we get is  iso! , not  iso .   iso!  : tag . This is a pretty big change. Instead of being a subtype of everything like  iso , the only thing an  iso!  is a subtype of is  tag . This is because the  iso  still exists, and is still  read and write unique . Any alias can neither read from nor write to the object. That means an  iso!  can only be a subtype of  tag .  trn!  : box . This is a change too, but not as big a change. Since  trn  is only  write unique , it's ok for aliases to read from the object, but it's not ok for aliases to write to the object. That means we could have  box  or  val  aliases - except  val  guarantees that  no  alias can write the the object! Since our  trn  still exists, and can write to the object, a  val  alias would break the guarantees that  val  makes. So a  trn!  can only be a subtype of  box  (and, transitively,  tag  as well).  ref!  : ref . Since a  ref  only guarantees that  other  actors can neither read from nor write to the object, it's ok to make more  ref  aliases within the same actor.  val!  : val . Since a  val  only guarantees that  no  actor can write to the object, its ok to make more  val  aliases, since they can't write to the object wither.  box!  : box . A  box  only guarantees that  other  actors can't write to the object. Both  val  and  ref  make that guarantee too, so why can  box  only alias as  box ? It's because we can't make  more  guarantees when we alias something. That means  box  can only alias as  box .  tag!  : tag . A  tag  doesn't make any guarantees at all. Just like with a  box , we can't make more guarantees when we make a new alias, so a  tag  can only alias as a  tag .", 
            "title": "Aliased substitution"
        }, 
        {
            "location": "/capabilities/capability-subtyping/#ephemeral-substitution", 
            "text": "The last case to consider is when we have an ephemeral reference capability. For example, if we have some  iso  and we  consume  it or do a destructive read, the type we get is  iso^ , not  iso .   iso^  : iso . This is pretty simple. When we givean  iso^  a name, by assigning it to something or passing it as an argument to a method, it loses the  ^  and becomes a plain old  iso . We know we gave up our previous  iso , so it's safe to have a new one.  trn^  : trn . This works exactly like  iso^ . The guarantee is weaker ( write uniqueness  instead of  read and write uniqueness ), but it works the same way.  ref^  : ref^  and  ref^  : ref  and  ref  : ref^ . Here, we have another case. Not only is a  ref^  a subtype of a  ref , it's also a subtype of a  ref^ . What's going on here? The reason is that an ephemeral reference capability is a way of saying \"a reference capability that, when aliased, results in the base reference capability\". Since a  ref  can be aliased as a  ref , that means  ref  and  ref^  are completely interchangeable.  val^ ,  box^ ,  tag^ . These all work the same way as  ref , that is, they are interchangeable with the base reference capability. It's for the same reason: all of these reference capabilities can be aliased as themselves.   Why do  ref^ ,  val^ ,  box^ , and  tag^  exist if they are interchangeable with their base reference capabilities?  It's for two reasons:  reference capability recovery  and  generics . We'll cover both of those later.", 
            "title": "Ephemeral substitution"
        }, 
        {
            "location": "/capabilities/arrow-types/", 
            "text": "When we talked about \nreference capability composition\n and \nviewpoint adaptation\n, we dealt with cases where we know the reference capability of the origin. However, sometimes we don't know the precise reference capability of the origin.\n\n\nWhen that happens, we can write a \nviewpoint adapted type\n, which we call an \narrow type\n because we write it with an \n-\n.\n\n\nUsing \nthis-\n as a viewpoint\n\n\nA function with a \nbox\n receiver can be called with a \nref\n receiver or a \nval\n receiver as well, since those are both subtypes of \nbox\n. Sometimes, we want to be able to talk about a type to take this into account. For example:\n\n\nclass Wombat\n  var _friend: Wombat\n\n  fun friend(): this-\nWombat =\n _friend\n\n\n\n\nHere, we have a \nWombat\n, and every \nWombat\n has a friend that's also a \nWombat\n (lucky \nWombat\n). In fact, it's a \nWombat ref\n, since \nref\n is the default reference capability for a \nWombat\n (since we didn't specify one). We also have a function that returns that friend. It's got a \nbox\n receiver (because \nbox\n is the default receiver reference capability for a function if we don't specify it).\n\n\nSo the return type would normally be a \nWombat box\n. Why's that? Because, as we saw earlier, when we read a \nref\n field from a \nbox\n origin, we get a \nbox\n. In this case, the origin is the receiver, which is a \nbox\n.\n\n\nBut wait! What if we want a function that can return a \nWombat ref\n when the receiver is a \nref\n, a \nWombat val\n when the receiver is a \nval\n, and a \nWombat box\n when the receiver is a \nbox\n? We don't want to have to write the function three times.\n\n\nWe use \nthis-\n! In this case, \nthis-\nWombat\n. It means \"a \nWombat ref\n as seen by the receiver\".\n\n\nWe know at the \ncall site\n what the real reference capability of the receiver is. So when the function is called, the compiler knows everything it needs to know to get this right.\n\n\nUsing a type parameter as a viewpoint\n\n\nWe haven't covered generics yet, so this may seem a little weird. We'll cover this again when we talk about generics (i.e. parameterised types), but we're mentioning it here for completeness.\n\n\nAnother time we don't know the precise reference capability of something is if we are using a type parameter. Here's an example from the standard library:\n\n\nclass ListValues[A, N: ListNode[A] box] is Iterator[N-\nA]\n\n\n\n\nHere, we have a \nListValues\n type that has two type parameters, \nA\n and \nN\n. In addition, \nN\n has a constraint: it has to be a subtype of \nListNode[A] box\n. That's all fine and well, but we also say the \nListValues[A, N]\n provides \nIterator[N-\nA]\n. That's the interesting bit: we provide an interface that let's us iterate over values of the type \nN-\nA\n.\n\n\nThat means we'll be returning objects of the type \nA\n, but the reference capability will be the same as an object of type \nN\n would see an object of type \nA\n.\n\n\nUsing \nbox-\n as a viewpoint\n\n\nThere's one more way we use arrow types, and it's also related to generics. Sometimes we want to talk about a type parameter as it is seen by some unknown type, \nas long as that type can read the type parameter\n.\n\n\nIn other words, the unknown type will be a subtype of \nbox\n, but that's all we know. Here's an example from the standard library:\n\n\ninterface Comparable[A: Comparable[A] box]\n  fun eq(that: box-\nA): Bool =\n this is that\n  fun ne(that: box-\nA): Bool =\n not eq(that)\n\n\n\n\nHere, we say that something is \nComparable[A]\n if and only if it has functions \neq\n and \nne\n and those functions have a single parameter of type \nbox-\nA\n and return a \nBool\n. In other words, whatever \nA\n is bound to, we only need to be able to read it.", 
            "title": "Arrow types"
        }, 
        {
            "location": "/capabilities/arrow-types/#using-this-as-a-viewpoint", 
            "text": "A function with a  box  receiver can be called with a  ref  receiver or a  val  receiver as well, since those are both subtypes of  box . Sometimes, we want to be able to talk about a type to take this into account. For example:  class Wombat\n  var _friend: Wombat\n\n  fun friend(): this- Wombat =  _friend  Here, we have a  Wombat , and every  Wombat  has a friend that's also a  Wombat  (lucky  Wombat ). In fact, it's a  Wombat ref , since  ref  is the default reference capability for a  Wombat  (since we didn't specify one). We also have a function that returns that friend. It's got a  box  receiver (because  box  is the default receiver reference capability for a function if we don't specify it).  So the return type would normally be a  Wombat box . Why's that? Because, as we saw earlier, when we read a  ref  field from a  box  origin, we get a  box . In this case, the origin is the receiver, which is a  box .  But wait! What if we want a function that can return a  Wombat ref  when the receiver is a  ref , a  Wombat val  when the receiver is a  val , and a  Wombat box  when the receiver is a  box ? We don't want to have to write the function three times.  We use  this- ! In this case,  this- Wombat . It means \"a  Wombat ref  as seen by the receiver\".  We know at the  call site  what the real reference capability of the receiver is. So when the function is called, the compiler knows everything it needs to know to get this right.", 
            "title": "Using this-&gt; as a viewpoint"
        }, 
        {
            "location": "/capabilities/arrow-types/#using-a-type-parameter-as-a-viewpoint", 
            "text": "We haven't covered generics yet, so this may seem a little weird. We'll cover this again when we talk about generics (i.e. parameterised types), but we're mentioning it here for completeness.  Another time we don't know the precise reference capability of something is if we are using a type parameter. Here's an example from the standard library:  class ListValues[A, N: ListNode[A] box] is Iterator[N- A]  Here, we have a  ListValues  type that has two type parameters,  A  and  N . In addition,  N  has a constraint: it has to be a subtype of  ListNode[A] box . That's all fine and well, but we also say the  ListValues[A, N]  provides  Iterator[N- A] . That's the interesting bit: we provide an interface that let's us iterate over values of the type  N- A .  That means we'll be returning objects of the type  A , but the reference capability will be the same as an object of type  N  would see an object of type  A .", 
            "title": "Using a type parameter as a viewpoint"
        }, 
        {
            "location": "/capabilities/arrow-types/#using-box-as-a-viewpoint", 
            "text": "There's one more way we use arrow types, and it's also related to generics. Sometimes we want to talk about a type parameter as it is seen by some unknown type,  as long as that type can read the type parameter .  In other words, the unknown type will be a subtype of  box , but that's all we know. Here's an example from the standard library:  interface Comparable[A: Comparable[A] box]\n  fun eq(that: box- A): Bool =  this is that\n  fun ne(that: box- A): Bool =  not eq(that)  Here, we say that something is  Comparable[A]  if and only if it has functions  eq  and  ne  and those functions have a single parameter of type  box- A  and return a  Bool . In other words, whatever  A  is bound to, we only need to be able to read it.", 
            "title": "Using box-&gt; as a viewpoint"
        }, 
        {
            "location": "/capabilities/trust-boundary/", 
            "text": "We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you've called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.\n\n\nTrust boundaries\n\n\nWhen we talk about trust, we don't mean things you trust because you think they are perfect. Instead, we mean things you \nhave\n to trust in order to get things done, even though you know they are \nimperfect\n.\n\n\nIn Pony, when you use the C FFI, you are basically declaring that you trust the C code that's being executed. That's fine, because you may need it to get work done. But what about trusting someone else's code to use the C FFI? You may need to, but you definitely want to know that it's happening.\n\n\nSafe packages\n\n\nThe normal way to handle that is to be sure you're using just the code you need to use in your program. Pretty simple! Don't use some random package off the internet without looking at the code and making sure it doesn't do nasty FFI stuff.\n\n\nBut we can do better than that.\n\n\nIn Pony, you can optionally declare a set of \nsafe\n packages on the \nponyc\n command line, like this:\n\n\nponyc --safe=files:net:net/ssl my_project\n\n\n\n\nHere, we are declaring that only the \nfiles\n, \nnet\n and \nnet/ssl\n packages are allowed to use C FFI calls. We've established our trust boundary: any other packages that try to use C FFI calls will result in a compile-time error.\n\n\nExample of use\n\n\nOn the \nPony sandbox\n, we are compiling and executing arbitrary code that users input. That could be dangerous. So we limit the use of the C FFI to the \ntime\n package. We don't allow access to the file system, or to the network, or anything else dangerous.", 
            "title": "Trust boundary"
        }, 
        {
            "location": "/capabilities/trust-boundary/#trust-boundaries", 
            "text": "When we talk about trust, we don't mean things you trust because you think they are perfect. Instead, we mean things you  have  to trust in order to get things done, even though you know they are  imperfect .  In Pony, when you use the C FFI, you are basically declaring that you trust the C code that's being executed. That's fine, because you may need it to get work done. But what about trusting someone else's code to use the C FFI? You may need to, but you definitely want to know that it's happening.", 
            "title": "Trust boundaries"
        }, 
        {
            "location": "/capabilities/trust-boundary/#safe-packages", 
            "text": "The normal way to handle that is to be sure you're using just the code you need to use in your program. Pretty simple! Don't use some random package off the internet without looking at the code and making sure it doesn't do nasty FFI stuff.  But we can do better than that.  In Pony, you can optionally declare a set of  safe  packages on the  ponyc  command line, like this:  ponyc --safe=files:net:net/ssl my_project  Here, we are declaring that only the  files ,  net  and  net/ssl  packages are allowed to use C FFI calls. We've established our trust boundary: any other packages that try to use C FFI calls will result in a compile-time error.", 
            "title": "Safe packages"
        }, 
        {
            "location": "/capabilities/trust-boundary/#example-of-use", 
            "text": "On the  Pony sandbox , we are compiling and executing arbitrary code that users input. That could be dangerous. So we limit the use of the C FFI to the  time  package. We don't allow access to the file system, or to the network, or anything else dangerous.", 
            "title": "Example of use"
        }, 
        {
            "location": "/generics/polymorphic-types/", 
            "text": "", 
            "title": "Polymorphic types"
        }, 
        {
            "location": "/generics/polymorphic-methods/", 
            "text": "", 
            "title": "Polymorphic methods"
        }, 
        {
            "location": "/composition-inheritance/code-sharing/", 
            "text": "", 
            "title": "Code sharing"
        }, 
        {
            "location": "/pattern-matching/match/", 
            "text": "If we want to compare an expression to a value then we use an \nif\n. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\n\n\nMatch expressions\n\n\nHere's a simple example of a match expression that produces a string.\n\n\nmatch x\n| 2 =\n \nint\n\n| 2.0 =\n \nfloat\n\n| \n2\n =\n \nstring\n\nelse\n  \nsomething else\n\nend\n\n\n\n\nIf you're used to functional languages this should be very familiar.\n\n\nFor those readers more familiar with the C and Java family of languages, think of this like a switch statement. But you can switch on values other than just integers, like Strings. In fact you can switch on any type that provides a comparison function, including your own classes. And you can also switch on the runtime type of an expression.\n\n\nA match starts with the keyword \nmatch\n, followed by the expression to match, which is known as the match \noperand\n. In this example the operand is just the variable \nx\n, but it can be any expression.\n\n\nMost of the match expression consists of a series of \ncases\n that we match against. Each case consists of a pipe symbol ('|'), the \npattern\n to match against, an arrow ('=\n') and the expression to evaluate if the case matches.\n\n\nWe go through the cases one by one until we find one that matches. (Actually, in practice the compiler is a lot more intelligent than that and uses a combination of sequential checks and jump tables to be as efficient as possible.)\n\n\nNote that each match case has an expression to evaluate and these are all independent. There is no \"fall through\" between cases as there is in languages such as C.\n\n\nIf the value produced by the match expression isn't used then the cases can omit the arrow and expression to evaluate. This can be useful for excluding specific cases before a more general case.\n\n\nElse cases\n\n\nAs with all Pony control structures the else case for a match expression is used if we have no other value, i.e. if none of our cases match. The else case, if there is one, \nmust\n come at the end of the match, after all of the specific cases.\n\n\nIf the value the match expression results in is used then you need to have an else case, even if it can never actually be reached. If you omit it a default will be added which evaluates to \nNone\n. The compiler currently isn't clever enough to spot when the other cases are exhaustive and so the else is not needed. This will be changed later.\n\n\nMatching on values\n\n\nThe simplest match expression just matches on value.\n\n\nfun f(x: U32): String =\n\n  match x\n  | 1 =\n \none\n\n  | 2 =\n \ntwo\n\n  | 3 =\n \nthree\n\n  | 5 =\n \nnot four\n\n  else\n    \nsomething else\n\n  end\n\n\n\n\nFor value matching the pattern is simply the value we want to match to, just like a C switch statement. The case with the same value as the operand wins and we use its expression.\n\n\nThe compiler calls the eq() function on the operand, passing the pattern as the argument. This means that you can use your own types as match operands and patterns, as long as you define an eq() function.\n\n\nclass Foo\n  var _x: U32\n\n  new create(x: U32) =\n\n    _x = x\n\n  fun eq(that: Foo): Bool =\n\n    _x == that._x\n\nactor Main\n  fun f(x: Foo): String =\n\n    match x\n    | Foo(1) =\n \none\n\n    | Foo(2) =\n \ntwo\n\n    | Foo(3) =\n \nthree\n\n    | Foo(5) =\n \nnot four\n\n    else\n      \nsomething else\n\n    end\n\n\n\n\nMatching on type and value\n\n\nMatching on value is fine if the match operand and case patterns have all the same type. However match can cope with multiple different types. Each case pattern is first checked to see if it is the same type as the runtime type of the operand. Only then will the values be compared.\n\n\nfun f(x: (U32 | String | None)): String =\n\n  match x\n  | None =\n \nnone\n\n  | 2 =\n \ntwo\n\n  | 3 =\n \nthree\n\n  | \n5\n =\n \nnot four\n\n  else\n    \nsomething else\n\n  end\n\n\n\n\nIn many languages using runtime type information is very expensive and so it is generally avoided whenever possible.\n\n\nIn Pony it's cheap. Really cheap. Pony's \"whole program\" approach to compilation means the compiler can work out as much as possible at compile time. The runtime cost of each type check is generally a single pointer comparison. Plus of course, any checks which can be fully determined at compile time are. So for up casts there's no runtime cost at all.\n\n\nCaptures\n\n\nSometimes you want to be able to match on type, for any value of that type. For this you use a \ncapture\n. This defines a local variable, valid only within the case, containing the value of the operand. If the operand is not of the specified type then the case doesn't match.\n\n\nCaptures look just like variable declarations within the pattern. Like normal variables they can be declared as var or let. If you're not going to reassign them within the case expression it is good practice to use let.\n\n\nfun f(x: (U32 | String | None)): String =\n\n  match x\n  | None =\n \nnone\n\n  | 2 =\n \ntwo\n\n  | 3 =\n \nthree\n\n  | let u: U32 =\n \nother integer\n\n  | let s: String =\n s\n  else\n    \nsomething else\n\n  end\n\n\n\n\nCan I omit the type from a capture, like I can from a local variable?\n Unfortunately no. Since we match on type and value the compiler has to know what type the pattern is, so it can't be inferred.\n\n\nMatching tuples\n\n\nIf you want to match on more than one operand at once then you can simply use a tuple. Cases will only match if \nall\n the tuple elements match.\n\n\nfun f(x: (String | None), y: U32): String =\n\n  match (x, y)\n  | (None, let y: U32) =\n \nnone\n\n  | (let s: String, 2) =\n s + \n two\n\n  | (let s: String, 3) =\n s + \n three\n\n  | (let s: String, let u: U32) =\n s + \n other integer\n\n  else\n    \nsomething else\n\n  end\n\n\n\n\nDo I have to specify all the elements in a tuple?\n No you don't. Any tuple elements in a pattern can be marked as \"don't care\" by using an underscore ('_'). The first and fourth cases in our example don't actually care about the U32 element, so we can ignore it.\n\n\nfun f(x: (String | None), y: U32): String =\n\n  match (x, y)\n  | (None, _) =\n \nnone\n\n  | (let s: String, 2) =\n s + \n two\n\n  | (let s: String, 3) =\n s + \n three\n\n  | (let s: String, _) =\n s + \n other integer\n\n  else\n    \nsomething else\n\n  end\n\n\n\n\nGuards\n\n\nIn addition to matching on types and values each case in a match can also have a guard condition. This is simply an expression, evaluated \nafter\n type and value matching has occurred, that must give the value true for the case to match. If the guard is false then the case doesn't match and we move onto the next in the usual way.\n\n\nGuards are introduced with the \nwhere\n keyword.\n\n\nA guard expression may use any captured variables from that case, which allows for handling ranges and complex functions.\n\n\nfun f(x: (String | None), y: U32): String =\n\n  match (x, y)\n  | (None, _) =\n \nnone\n\n  | (let s: String, 2) =\n s + \n two\n\n  | (let s: String, 3) =\n s + \n three\n\n  | (let s: String, let u: U32) where u \n 14 =\n s + \n other big integer\n\n  | (let s: String, _) =\n s + \n other small integer\n\n  else\n    \nsomething else\n\n  end", 
            "title": "Match"
        }, 
        {
            "location": "/pattern-matching/match/#match-expressions", 
            "text": "Here's a simple example of a match expression that produces a string.  match x\n| 2 =   int \n| 2.0 =   float \n|  2  =   string \nelse\n   something else \nend  If you're used to functional languages this should be very familiar.  For those readers more familiar with the C and Java family of languages, think of this like a switch statement. But you can switch on values other than just integers, like Strings. In fact you can switch on any type that provides a comparison function, including your own classes. And you can also switch on the runtime type of an expression.  A match starts with the keyword  match , followed by the expression to match, which is known as the match  operand . In this example the operand is just the variable  x , but it can be any expression.  Most of the match expression consists of a series of  cases  that we match against. Each case consists of a pipe symbol ('|'), the  pattern  to match against, an arrow ('= ') and the expression to evaluate if the case matches.  We go through the cases one by one until we find one that matches. (Actually, in practice the compiler is a lot more intelligent than that and uses a combination of sequential checks and jump tables to be as efficient as possible.)  Note that each match case has an expression to evaluate and these are all independent. There is no \"fall through\" between cases as there is in languages such as C.  If the value produced by the match expression isn't used then the cases can omit the arrow and expression to evaluate. This can be useful for excluding specific cases before a more general case.", 
            "title": "Match expressions"
        }, 
        {
            "location": "/pattern-matching/match/#else-cases", 
            "text": "As with all Pony control structures the else case for a match expression is used if we have no other value, i.e. if none of our cases match. The else case, if there is one,  must  come at the end of the match, after all of the specific cases.  If the value the match expression results in is used then you need to have an else case, even if it can never actually be reached. If you omit it a default will be added which evaluates to  None . The compiler currently isn't clever enough to spot when the other cases are exhaustive and so the else is not needed. This will be changed later.", 
            "title": "Else cases"
        }, 
        {
            "location": "/pattern-matching/match/#matching-on-values", 
            "text": "The simplest match expression just matches on value.  fun f(x: U32): String = \n  match x\n  | 1 =   one \n  | 2 =   two \n  | 3 =   three \n  | 5 =   not four \n  else\n     something else \n  end  For value matching the pattern is simply the value we want to match to, just like a C switch statement. The case with the same value as the operand wins and we use its expression.  The compiler calls the eq() function on the operand, passing the pattern as the argument. This means that you can use your own types as match operands and patterns, as long as you define an eq() function.  class Foo\n  var _x: U32\n\n  new create(x: U32) = \n    _x = x\n\n  fun eq(that: Foo): Bool = \n    _x == that._x\n\nactor Main\n  fun f(x: Foo): String = \n    match x\n    | Foo(1) =   one \n    | Foo(2) =   two \n    | Foo(3) =   three \n    | Foo(5) =   not four \n    else\n       something else \n    end", 
            "title": "Matching on values"
        }, 
        {
            "location": "/pattern-matching/match/#matching-on-type-and-value", 
            "text": "Matching on value is fine if the match operand and case patterns have all the same type. However match can cope with multiple different types. Each case pattern is first checked to see if it is the same type as the runtime type of the operand. Only then will the values be compared.  fun f(x: (U32 | String | None)): String = \n  match x\n  | None =   none \n  | 2 =   two \n  | 3 =   three \n  |  5  =   not four \n  else\n     something else \n  end  In many languages using runtime type information is very expensive and so it is generally avoided whenever possible.  In Pony it's cheap. Really cheap. Pony's \"whole program\" approach to compilation means the compiler can work out as much as possible at compile time. The runtime cost of each type check is generally a single pointer comparison. Plus of course, any checks which can be fully determined at compile time are. So for up casts there's no runtime cost at all.", 
            "title": "Matching on type and value"
        }, 
        {
            "location": "/pattern-matching/match/#captures", 
            "text": "Sometimes you want to be able to match on type, for any value of that type. For this you use a  capture . This defines a local variable, valid only within the case, containing the value of the operand. If the operand is not of the specified type then the case doesn't match.  Captures look just like variable declarations within the pattern. Like normal variables they can be declared as var or let. If you're not going to reassign them within the case expression it is good practice to use let.  fun f(x: (U32 | String | None)): String = \n  match x\n  | None =   none \n  | 2 =   two \n  | 3 =   three \n  | let u: U32 =   other integer \n  | let s: String =  s\n  else\n     something else \n  end  Can I omit the type from a capture, like I can from a local variable?  Unfortunately no. Since we match on type and value the compiler has to know what type the pattern is, so it can't be inferred.", 
            "title": "Captures"
        }, 
        {
            "location": "/pattern-matching/match/#matching-tuples", 
            "text": "If you want to match on more than one operand at once then you can simply use a tuple. Cases will only match if  all  the tuple elements match.  fun f(x: (String | None), y: U32): String = \n  match (x, y)\n  | (None, let y: U32) =   none \n  | (let s: String, 2) =  s +   two \n  | (let s: String, 3) =  s +   three \n  | (let s: String, let u: U32) =  s +   other integer \n  else\n     something else \n  end  Do I have to specify all the elements in a tuple?  No you don't. Any tuple elements in a pattern can be marked as \"don't care\" by using an underscore ('_'). The first and fourth cases in our example don't actually care about the U32 element, so we can ignore it.  fun f(x: (String | None), y: U32): String = \n  match (x, y)\n  | (None, _) =   none \n  | (let s: String, 2) =  s +   two \n  | (let s: String, 3) =  s +   three \n  | (let s: String, _) =  s +   other integer \n  else\n     something else \n  end", 
            "title": "Matching tuples"
        }, 
        {
            "location": "/pattern-matching/match/#guards", 
            "text": "In addition to matching on types and values each case in a match can also have a guard condition. This is simply an expression, evaluated  after  type and value matching has occurred, that must give the value true for the case to match. If the guard is false then the case doesn't match and we move onto the next in the usual way.  Guards are introduced with the  where  keyword.  A guard expression may use any captured variables from that case, which allows for handling ranges and complex functions.  fun f(x: (String | None), y: U32): String = \n  match (x, y)\n  | (None, _) =   none \n  | (let s: String, 2) =  s +   two \n  | (let s: String, 3) =  s +   three \n  | (let s: String, let u: U32) where u   14 =  s +   other big integer \n  | (let s: String, _) =  s +   other small integer \n  else\n     something else \n  end", 
            "title": "Guards"
        }, 
        {
            "location": "/pattern-matching/as/", 
            "text": "", 
            "title": "As"
        }, 
        {
            "location": "/packages/package-system/", 
            "text": "Pony code is organised into \npackages\n. Each program and library is a single package, possibly using other packages.\n\n\nThe package structure\n\n\nThe package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\n\n\nEvery source file is within exactly one package. Hence all Pony code is in packages.\n\n\nA package is usually split into several source files, although it does not have to be. This is purely a convenience to allow better code organisation and the compiler treats all the code within a package as if it were from a single file.\n\n\nThe package is the privacy boundary for types and methods. That is:\n\n\n\n\nPrivate types (those whose name starts with an underscore) can be used only within the package in which they are defined.\n\n\nPrivate methods (those whose name starts with an underscore) can be called only from code within the package in which they are defined.\n\n\n\n\nIt follows that all code within a package is assumed to know of, and trust, all the rest of the code in the package.\n\n\nThere is no such concept as a sub-package in Pony. For example the packages \"foo/bar\" and \"foo/bar/wombat\" will, presumably, perform related tasks but they are two independent packages. Package \"foo/bar\" does not contain package \"foo/bar/wombat\" and neither has access to the private elements of the other.", 
            "title": "Package system"
        }, 
        {
            "location": "/packages/package-system/#the-package-structure", 
            "text": "The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.  Every source file is within exactly one package. Hence all Pony code is in packages.  A package is usually split into several source files, although it does not have to be. This is purely a convenience to allow better code organisation and the compiler treats all the code within a package as if it were from a single file.  The package is the privacy boundary for types and methods. That is:   Private types (those whose name starts with an underscore) can be used only within the package in which they are defined.  Private methods (those whose name starts with an underscore) can be called only from code within the package in which they are defined.   It follows that all code within a package is assumed to know of, and trust, all the rest of the code in the package.  There is no such concept as a sub-package in Pony. For example the packages \"foo/bar\" and \"foo/bar/wombat\" will, presumably, perform related tasks but they are two independent packages. Package \"foo/bar\" does not contain package \"foo/bar/wombat\" and neither has access to the private elements of the other.", 
            "title": "The package structure"
        }, 
        {
            "location": "/packages/use-statement/", 
            "text": "Use command\n\n\nTo use a package in your code you need to have a \nuse\n command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\n\n\nUse commands are a similar concept to Python and Java \"import\", C/C++ \"#include\" and C# \"using\" commands, but not exactly the same. They come at the beginning of Pony files and look like this:\n\n\nuse \ncollections\n\n\n\n\n\nThis will find all of the publicly visible types defined in the \ncollections\n package and add them to the type namespace of the file containing the use command. These types are then available to use within that file, just as if they were defined locally.\n\n\nFor example, the standard library contains the package \ntime\n. This contains the following definition (among others):\n\n\nprimitive Time\n  fun now(): (I64, I64)\n\n\n\n\nTo access the \nnow\n function just add a use command:\n\n\nuse \ntime\n\n\nclass Foo\n  fun f() =\n\n    (var secs, var nsecs) = Time.now()\n\n\n\n\nUse names\n\n\nAs we saw above the use command adds all the public types from a package into the namespace of the using file. This means that using a package may define type names that you want to use for your own types. Furthermore, if you use two packages within a file they may both define the same type name, causing a clash in your namespace. For example:\n\n\n// In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse \npackageA\n\nuse \npackageB\n\n\nclass Bar\n  var _x: Foo\n\n\n\n\nThe declarations of _x is an error because we don't know which \nFoo\n is being referred to. Actually using 'Foo' is not even required, simply using both package A and package B is enough to cause an error here.\n\n\nTo avoid this problem the use command allows you to specify an alias. If you do this then only that alias is put into your namespace. The types from the used package can then be accessed using this alias as a qualifier. Our example now becomes:\n\n\n// In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse a = \npackageA\n\nuse b = \npackageB\n\n\nclass Bar\n  var _x: a.Foo  // The Foo from package A\n  var _y: b.Foo  // The Foo from package B\n\n\n\n\nIf you prefer you can give an alias to only one of the packages. \nFoo\n will then still be added to your namespace referring to the unaliased package:\n\n\n// In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse \npackageA\n\nuse b = \npackageB\n\n\nclass Bar\n  var _x: Foo  // The Foo from package A\n  var _y: b.Foo  // The Foo from package B\n\n\n\n\nCan I just specify the full package path and forget about the use command, like I do in Java and C#?\n No, you can't do that in Pony. You can't refer to one package based on a use command for another package and you can't use types from a package without a use command for that package. Every package that you want to use must have its own use command.\n\n\nAre there limits on the names I can use for an alias?\n Use alias names have to start with a lower case letter. Other than that you can use whatever name you want, as long as you're not using that name for any other purpose in your file.\n\n\nScheme indicators\n\n\nThe string we give to a use command is known as the \nspecifier\n. This consists of a \nscheme\n indicator and a \nlocator\n, separated by a colon. The scheme indicator tells the use command what we want it to do, for example the scheme indicator for including a package is \"package\". If no colon is found within the specifier string then the use command assumes you meant \"package\".\n\n\nThe following two use commands are exactly equivalent:\n\n\nuse \nfoo\n\nuse \npackage:foo\n\n\n\n\n\nIf you are using a locator string that includes a colon, for example an absolute path in Windows, then you \nhave\n to include the \"package\" scheme specifier:\n\n\nuse \nC:/foo/bar\n  // Error, scheme \nC\n is unknown\nuse \npackage:C:/foo/bar\n  // OK\n\n\n\n\nTo allow use commands to be portable across operating systems, and to avoid confusion with escape characters, '/' should always be used as the path separator in use commands, even on Windows.", 
            "title": "Use statement"
        }, 
        {
            "location": "/packages/use-statement/#use-command", 
            "text": "To use a package in your code you need to have a  use  command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.  Use commands are a similar concept to Python and Java \"import\", C/C++ \"#include\" and C# \"using\" commands, but not exactly the same. They come at the beginning of Pony files and look like this:  use  collections   This will find all of the publicly visible types defined in the  collections  package and add them to the type namespace of the file containing the use command. These types are then available to use within that file, just as if they were defined locally.  For example, the standard library contains the package  time . This contains the following definition (among others):  primitive Time\n  fun now(): (I64, I64)  To access the  now  function just add a use command:  use  time \n\nclass Foo\n  fun f() = \n    (var secs, var nsecs) = Time.now()", 
            "title": "Use command"
        }, 
        {
            "location": "/packages/use-statement/#use-names", 
            "text": "As we saw above the use command adds all the public types from a package into the namespace of the using file. This means that using a package may define type names that you want to use for your own types. Furthermore, if you use two packages within a file they may both define the same type name, causing a clash in your namespace. For example:  // In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse  packageA \nuse  packageB \n\nclass Bar\n  var _x: Foo  The declarations of _x is an error because we don't know which  Foo  is being referred to. Actually using 'Foo' is not even required, simply using both package A and package B is enough to cause an error here.  To avoid this problem the use command allows you to specify an alias. If you do this then only that alias is put into your namespace. The types from the used package can then be accessed using this alias as a qualifier. Our example now becomes:  // In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse a =  packageA \nuse b =  packageB \n\nclass Bar\n  var _x: a.Foo  // The Foo from package A\n  var _y: b.Foo  // The Foo from package B  If you prefer you can give an alias to only one of the packages.  Foo  will then still be added to your namespace referring to the unaliased package:  // In package A\nclass Foo\n\n// In package B\nclass Foo\n\n// In your code\nuse  packageA \nuse b =  packageB \n\nclass Bar\n  var _x: Foo  // The Foo from package A\n  var _y: b.Foo  // The Foo from package B  Can I just specify the full package path and forget about the use command, like I do in Java and C#?  No, you can't do that in Pony. You can't refer to one package based on a use command for another package and you can't use types from a package without a use command for that package. Every package that you want to use must have its own use command.  Are there limits on the names I can use for an alias?  Use alias names have to start with a lower case letter. Other than that you can use whatever name you want, as long as you're not using that name for any other purpose in your file.", 
            "title": "Use names"
        }, 
        {
            "location": "/packages/use-statement/#scheme-indicators", 
            "text": "The string we give to a use command is known as the  specifier . This consists of a  scheme  indicator and a  locator , separated by a colon. The scheme indicator tells the use command what we want it to do, for example the scheme indicator for including a package is \"package\". If no colon is found within the specifier string then the use command assumes you meant \"package\".  The following two use commands are exactly equivalent:  use  foo \nuse  package:foo   If you are using a locator string that includes a colon, for example an absolute path in Windows, then you  have  to include the \"package\" scheme specifier:  use  C:/foo/bar   // Error, scheme  C  is unknown\nuse  package:C:/foo/bar   // OK  To allow use commands to be portable across operating systems, and to avoid confusion with escape characters, '/' should always be used as the path separator in use commands, even on Windows.", 
            "title": "Scheme indicators"
        }, 
        {
            "location": "/packages/builtin/", 
            "text": "Standard library\n\n\nThe Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example the \nfiles\n package provides file access and the \ncollections\n package provides generic lists, maps, sets and so on.\n\n\nThere is also a special package in the standard library called \nbuiltin\n. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them. All Pony source files have an implicit \nuse \"builtin\"\n command. This means all the types defined in the package builtin are automatically available in the type namespace of all Pony source files.", 
            "title": "Builtin"
        }, 
        {
            "location": "/packages/builtin/#standard-library", 
            "text": "The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example the  files  package provides file access and the  collections  package provides generic lists, maps, sets and so on.  There is also a special package in the standard library called  builtin . This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them. All Pony source files have an implicit  use \"builtin\"  command. This means all the types defined in the package builtin are automatically available in the type namespace of all Pony source files.", 
            "title": "Standard library"
        }, 
        {
            "location": "/packages/platform/", 
            "text": "Platform dependent code\n\n\nThe Pony libraries of course want to abstract platform differences.\nSometimes you may want a use command that only works under certain\ncircumstances, most commonly only on a particular OS or only for debug\nbuilds. You can do this by specifying a condition for a use command:\n\n\nuse \nfoo\n if linux\nuse \nbar\n if (windows and debug)\n\n\n\n\nUse conditions can use any of the methods defined in \nbuiltin/Platform\n as conditions.\nThere are currently the following booleans defined:\n\nfreebsd\n, \nlinux\n, \nosx\n, \nposix\n =\n \n(freebsd or linux or osx)\n,\n\nwindows\n, \nx86\n, \narm\n, \nlp64\n, \nllp64\n, \nilp32\n, \nhas_i128\n, \ndebug\n\n\nThey can also use the operators \nand\n, \nor\n, \nxor\n and \nnot\n. As with other expressions in Pony, parentheses \nmust\n be used to indicate precedence if more than one of \nand\n, \nor\n and \nxor\n is used.\n\n\nAny use command whose condition evaluates to false is ignored.", 
            "title": "Use conditions"
        }, 
        {
            "location": "/packages/platform/#platform-dependent-code", 
            "text": "The Pony libraries of course want to abstract platform differences.\nSometimes you may want a use command that only works under certain\ncircumstances, most commonly only on a particular OS or only for debug\nbuilds. You can do this by specifying a condition for a use command:  use  foo  if linux\nuse  bar  if (windows and debug)  Use conditions can use any of the methods defined in  builtin/Platform  as conditions.\nThere are currently the following booleans defined: freebsd ,  linux ,  osx ,  posix  =   (freebsd or linux or osx) , windows ,  x86 ,  arm ,  lp64 ,  llp64 ,  ilp32 ,  has_i128 ,  debug  They can also use the operators  and ,  or ,  xor  and  not . As with other expressions in Pony, parentheses  must  be used to indicate precedence if more than one of  and ,  or  and  xor  is used.  Any use command whose condition evaluates to false is ignored.", 
            "title": "Platform dependent code"
        }, 
        {
            "location": "/compiler-clargs/clargs/", 
            "text": "Compiler args\n\n\nponyc\n, the compiler, is usually called in the project directory,\nwhere it finds the \n.pony\n files and its dependencies\nautomatically. There it will create the binary based on the directory\nname. You can override this and tune the compilation with several\noptions as described via \nponyc --help\n and you can pass a seperate\nsource directory as argument.\n\n\nponyc [OPTIONS] \npackage directory\n\n\nThe most useful options are \n--debug\n, \n--path\n or just \n-p\n,\n\n--output\n or just \n-o\n and \n--docs\n or \n-g\n. With \n-l\n you can\ngenerate a C library, \nlib\ndirectory\n.\n\n\n--debug\n will skip the LLVM optimizations passes. This should not be\nmixed up with \nmake config=debug\n, the default make configuration\ntarget. \nconfig=debug\n will create DWARF symbols, and add slower\nassertions to ponyc, but not to the generated binaries. For those you\ncan omit DWARF symbols with the \n--strip\n or \n-s\n option.\n\n\n--path\n or \n-p\n take a \n:\n seperated pathlist as argument, and adds\nthose to the compile-time library paths for the linker to find source\npackages and the native libraries, static or dynamic, being linked at\ncompile-time or via the FFI at run-time. The system adds several paths\nalready, e.g. on windows it queries the registry to find the compiler\nrun-time paths, you can also use \nuse \"lib:path\"\n statements in the\nsource code and as final possibility you can add \n-p\n paths. But if\nyou want the generated binary to accept such a path to find a dynamic\nlibrary at your client system, you need to handle that in your source\ncode by yourself. See the \noptions\n package for this.\n\n\n--output\n or \n-o\n takes a directory name where the final binary is\ncreated.\n\n\n--docs\n or -\ng\n creates a directory of the package with documentation\nin \nreadthedocs.org\n format, i.e. markdown.\n\n\nLet's study the documentation of the builtin stdlib:\n\n\n  pip install mkdocs\n  ponyc packages/stdlib --docs \n cd stdlib-docs \n mkdocs serve\n\n\n\n\nAnd point your web browser to \nhttp://127.0.0.1:8000\n\nserving a live-reloading local version of the docs. \nmkdocs gh-deploy\n wi\n\n\nNote that there is \nno builtin debugger\n to interactively step through\nyour program and interpret the results. But ponyc creates proper DWARF\nsymbols and you can step through your programs with a conventional\ndebugger, such as gdb or lldb.\n\n\nRuntime options for Pony programs\n\n\nBesides using the \noptions\n package, there are also several builtin\noptions for the generated binary (\nnot for use with ponyc\n) starting\nwith \n--pony*\n, see \nponyc --help\n, to tweak runtime performance. You\ncan override the number of initial threads, tune cycle detection\n(\nCD\n), the garbage collector and even turn off yield, which is not\nreally recommended.", 
            "title": "Compiler args"
        }, 
        {
            "location": "/compiler-clargs/clargs/#compiler-args", 
            "text": "ponyc , the compiler, is usually called in the project directory,\nwhere it finds the  .pony  files and its dependencies\nautomatically. There it will create the binary based on the directory\nname. You can override this and tune the compilation with several\noptions as described via  ponyc --help  and you can pass a seperate\nsource directory as argument.  ponyc [OPTIONS]  package directory  The most useful options are  --debug ,  --path  or just  -p , --output  or just  -o  and  --docs  or  -g . With  -l  you can\ngenerate a C library,  lib directory .  --debug  will skip the LLVM optimizations passes. This should not be\nmixed up with  make config=debug , the default make configuration\ntarget.  config=debug  will create DWARF symbols, and add slower\nassertions to ponyc, but not to the generated binaries. For those you\ncan omit DWARF symbols with the  --strip  or  -s  option.  --path  or  -p  take a  :  seperated pathlist as argument, and adds\nthose to the compile-time library paths for the linker to find source\npackages and the native libraries, static or dynamic, being linked at\ncompile-time or via the FFI at run-time. The system adds several paths\nalready, e.g. on windows it queries the registry to find the compiler\nrun-time paths, you can also use  use \"lib:path\"  statements in the\nsource code and as final possibility you can add  -p  paths. But if\nyou want the generated binary to accept such a path to find a dynamic\nlibrary at your client system, you need to handle that in your source\ncode by yourself. See the  options  package for this.  --output  or  -o  takes a directory name where the final binary is\ncreated.  --docs  or - g  creates a directory of the package with documentation\nin  readthedocs.org  format, i.e. markdown.  Let's study the documentation of the builtin stdlib:    pip install mkdocs\n  ponyc packages/stdlib --docs   cd stdlib-docs   mkdocs serve  And point your web browser to  http://127.0.0.1:8000 \nserving a live-reloading local version of the docs.  mkdocs gh-deploy  wi  Note that there is  no builtin debugger  to interactively step through\nyour program and interpret the results. But ponyc creates proper DWARF\nsymbols and you can step through your programs with a conventional\ndebugger, such as gdb or lldb.", 
            "title": "Compiler args"
        }, 
        {
            "location": "/compiler-clargs/clargs/#runtime-options-for-pony-programs", 
            "text": "Besides using the  options  package, there are also several builtin\noptions for the generated binary ( not for use with ponyc ) starting\nwith  --pony* , see  ponyc --help , to tweak runtime performance. You\ncan override the number of initial threads, tune cycle detection\n( CD ), the garbage collector and even turn off yield, which is not\nreally recommended.", 
            "title": "Runtime options for Pony programs"
        }, 
        {
            "location": "/c-ffi/calling-c/", 
            "text": "Pony supports integration with other native languages through the\nForeign Function Interface (FFI). The FFI library provides a stable\nand portable API and high level programming interface allowing Pony\nto integrate with native libraries easily.\n\n\nNote that calling C (or other low level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language's most useful, but also most dangerous, features. Calling well written, bug free, C code will have no ill effects on your program. However, calling buggy or malicious C code or calling C incorrectly can cause your Pony program to go wrong, including corrupting data and crashing. Consequently all of Pony guarantees regarding not crashing, memory safety and concurrent correctness can be voided by calling FFI functions.\n\n\nCalling FFI functions\n\n\nFFI is built into Pony and native libraries may be directly referenced\nin Pony code. There is no need to code or configure bindings, wrappers or interfaces.\n\n\nHere's an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n\n\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle)\n\n\n\n\nThe main difference is the @ symbol before the function name. This is what tells us it's an FFI call. Any time you see an @ in Pony there's an FFI going on.\n\n\nThe other key difference is that the return type of the function is specified after the function name, in square brackets. This is because the compiler needs to know what type the value returned is (if any), but has no way to determine that, so it needs you to explicitly tell it.\n\n\nThere are a few unusual things going on with the arguments to this FFI call as well. For the second argument, for which we're passing the value 1, we've had to specify that this is a U64. Again this is because the compiler needs to know what size argument to use, but has no way to determine this.\n\n\nSafely does it\n\n\nIt is VERY important that when calling FFI functions you MUST get the parameter and return types right\n. The compiler has no way to know what the native code expects and will just believe whatever you do. Errors here can cause invalid data to be passed to the FFI function or returned to Pony, which can lead to program crashes.\n\n\nTo help avoid bugs here Pony allows you to specify the type signatures of FFI functions in advance. Whilst you must still get the types correct the arguments you provide at each FFI call site are checked against the declared signature. This means that you must get a type wrong, in the same way, in at least 2 places for a bug to exist. This won't help if the argument types the native code expects are different to what you think they are, but it will protect you against trivial mistakes and simple typos.\n\n\nFFI signatures are declared using the \nuse\n command. Here's an example from the standard library:\n\n\nuse @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32,\n  parg: Pointer[U8] tag) if windows\n\nuse @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64,\n  parg: Pointer[U8] tag) if not windows\n\nclass SSLContext val\n  new create() =\n\n    // set SSL_OP_NO_SSLv2\n    @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8])\n\n\n\n\nThe @ symbol tells us that the use command is an FFI signature declaration. The types specified here are considered authoritative and any FFI calls that differ are considered to be an error.\n\n\nNote that we no longer need to specify the return type at the call site, since the signature declaration has already told us what it is. However, it is perfectly acceptable to specify it again if you want to.\n\n\nThe use @ command can take a condition just like other use commands. This is useful in this case, where the Windows version of SSL_CTX_ctrl has a slightly different signature to other platforms.\n\n\nC types\n\n\nMany C functions require types that don't have an exact equivalent in Pony. A variety of features are provided for these.\n\n\nFor FFI functions that have no return value (ie they return \nvoid\n in C) the return value specified should be \n[None]\n.\n\n\nIn Pony String is an object with a header and fields, but in C a \nchar*\n is simply a pointer to character data. The \n.cstring()\n function on String provides us with a valid pointer to hand to C. Our fwrite example above makes use of this for the first argument.\n\n\nPony classes corresponds directly to pointers to the class in C.\n\n\nFor C pointers to simple types, such as U64, the Pony \nPointer[]\n polymorphic type should be used, with a \ntag\n reference capability. \nPointer[U8] tag\n should be used for void*. This can be seen in our \nSSL_CTX_ctrl\n example above.\n\n\nTo pass pointers to values to C the \naddressof\n operator can be used (previously \n), just like taking an address in C. This is done in the standard library to pass the address of a \nU64\n to an FFI function that takes a \nuint64_t*\n as an out parameter:\n\n\nvar len = U64(0)\n@pcre2_substring_length_bynumber_8[I32](_match, i.u32(), addressof len)\n\n\n\n\nTo read c structs from FFI\n\n\nIf you have a c struct like this\n\n\ntypedef struct {\n  uint8_t code;\n  float x;\n  float y;\n} EGLEvent;\n\nEGLEvent getEvent() {\n    EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height};\n    return e;\n}\n\n\n\n\nthe you can destructure it and get the values using a tuple\n\n\ntype EGLEvent is (U8, F32, F32)\n(var code, var x, var y) = @getEvent[EGLEvent]()\n\n\n\n\nTo pass c structs to FFI\n\n\nIf you have a c struct like this\n\n\ntypedef struct {\n  uint8_t code;\n  float x;\n  float y;\n} EGLEvent;\n\nvoid setEvent(EGLEvent e) {\n    printf(\n%d\n, e.code);\n}\n\n\n\n\nthen you call it like this\n\n\ntype EGLEvent is (U8, F32, F32)\nlet e: EGLEvent = (4, 0, 0)\n@setEvent[None](e)\n\n\n\n\nGet and Pass Pointers to FFI\n\n\nTo pass and receive pointers to c structs you need to declare pointer to primitives\n\n\nprimitive _XDisplayHandle\nprimitive _EGLDisplayHandle\n\nlet x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0))\nif x_dpy.is_null() then\n  env.out.print(\nXOpenDisplay failed\n)\nend\n\nlet e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy)\nif e_dpy.is_null() then\n  env.out.print(\neglGetDisplay failed\n)\nend\n\n\n\n\nFFI functions raising errors\n\n\nFFI functions can raise Pony errors. Functions in existing C libraries are very unlikely to do this, but support libraries specifically written for use with Pony may well do.\n\n\nFFI calls to functions that \nmight\n raise an error \nmust\n mark it as such by adding a ? after the arguments. For example:\n\n\n@os_send[U64](_event, data.cstring(), data.size()) ? // May raise an error\n\n\n\n\nIf a signature declaration is used then that must be marked as possibly raising an error in the same way. The FFI call site then does not have to mark it as well, although doing so is allowed.\n\n\nuse @os_send[U64](ev: Event, buf: Pointer[U8] tag, len: U64) ?\n\n@os_send(_event, data.cstring(), data.size()) // May raise an error", 
            "title": "Calling C"
        }, 
        {
            "location": "/c-ffi/calling-c/#calling-ffi-functions", 
            "text": "FFI is built into Pony and native libraries may be directly referenced\nin Pony code. There is no need to code or configure bindings, wrappers or interfaces.  Here's an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:  @fwrite[U64](data.cstring(), U64(1), data.size(), _handle)  The main difference is the @ symbol before the function name. This is what tells us it's an FFI call. Any time you see an @ in Pony there's an FFI going on.  The other key difference is that the return type of the function is specified after the function name, in square brackets. This is because the compiler needs to know what type the value returned is (if any), but has no way to determine that, so it needs you to explicitly tell it.  There are a few unusual things going on with the arguments to this FFI call as well. For the second argument, for which we're passing the value 1, we've had to specify that this is a U64. Again this is because the compiler needs to know what size argument to use, but has no way to determine this.", 
            "title": "Calling FFI functions"
        }, 
        {
            "location": "/c-ffi/calling-c/#safely-does-it", 
            "text": "It is VERY important that when calling FFI functions you MUST get the parameter and return types right . The compiler has no way to know what the native code expects and will just believe whatever you do. Errors here can cause invalid data to be passed to the FFI function or returned to Pony, which can lead to program crashes.  To help avoid bugs here Pony allows you to specify the type signatures of FFI functions in advance. Whilst you must still get the types correct the arguments you provide at each FFI call site are checked against the declared signature. This means that you must get a type wrong, in the same way, in at least 2 places for a bug to exist. This won't help if the argument types the native code expects are different to what you think they are, but it will protect you against trivial mistakes and simple typos.  FFI signatures are declared using the  use  command. Here's an example from the standard library:  use @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32,\n  parg: Pointer[U8] tag) if windows\n\nuse @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64,\n  parg: Pointer[U8] tag) if not windows\n\nclass SSLContext val\n  new create() = \n    // set SSL_OP_NO_SSLv2\n    @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8])  The @ symbol tells us that the use command is an FFI signature declaration. The types specified here are considered authoritative and any FFI calls that differ are considered to be an error.  Note that we no longer need to specify the return type at the call site, since the signature declaration has already told us what it is. However, it is perfectly acceptable to specify it again if you want to.  The use @ command can take a condition just like other use commands. This is useful in this case, where the Windows version of SSL_CTX_ctrl has a slightly different signature to other platforms.", 
            "title": "Safely does it"
        }, 
        {
            "location": "/c-ffi/calling-c/#c-types", 
            "text": "Many C functions require types that don't have an exact equivalent in Pony. A variety of features are provided for these.  For FFI functions that have no return value (ie they return  void  in C) the return value specified should be  [None] .  In Pony String is an object with a header and fields, but in C a  char*  is simply a pointer to character data. The  .cstring()  function on String provides us with a valid pointer to hand to C. Our fwrite example above makes use of this for the first argument.  Pony classes corresponds directly to pointers to the class in C.  For C pointers to simple types, such as U64, the Pony  Pointer[]  polymorphic type should be used, with a  tag  reference capability.  Pointer[U8] tag  should be used for void*. This can be seen in our  SSL_CTX_ctrl  example above.  To pass pointers to values to C the  addressof  operator can be used (previously  ), just like taking an address in C. This is done in the standard library to pass the address of a  U64  to an FFI function that takes a  uint64_t*  as an out parameter:  var len = U64(0)\n@pcre2_substring_length_bynumber_8[I32](_match, i.u32(), addressof len)", 
            "title": "C types"
        }, 
        {
            "location": "/c-ffi/calling-c/#to-read-c-structs-from-ffi", 
            "text": "If you have a c struct like this  typedef struct {\n  uint8_t code;\n  float x;\n  float y;\n} EGLEvent;\n\nEGLEvent getEvent() {\n    EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height};\n    return e;\n}  the you can destructure it and get the values using a tuple  type EGLEvent is (U8, F32, F32)\n(var code, var x, var y) = @getEvent[EGLEvent]()", 
            "title": "To read c structs from FFI"
        }, 
        {
            "location": "/c-ffi/calling-c/#to-pass-c-structs-to-ffi", 
            "text": "If you have a c struct like this  typedef struct {\n  uint8_t code;\n  float x;\n  float y;\n} EGLEvent;\n\nvoid setEvent(EGLEvent e) {\n    printf( %d , e.code);\n}  then you call it like this  type EGLEvent is (U8, F32, F32)\nlet e: EGLEvent = (4, 0, 0)\n@setEvent[None](e)", 
            "title": "To pass c structs to FFI"
        }, 
        {
            "location": "/c-ffi/calling-c/#get-and-pass-pointers-to-ffi", 
            "text": "To pass and receive pointers to c structs you need to declare pointer to primitives  primitive _XDisplayHandle\nprimitive _EGLDisplayHandle\n\nlet x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0))\nif x_dpy.is_null() then\n  env.out.print( XOpenDisplay failed )\nend\n\nlet e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy)\nif e_dpy.is_null() then\n  env.out.print( eglGetDisplay failed )\nend", 
            "title": "Get and Pass Pointers to FFI"
        }, 
        {
            "location": "/c-ffi/calling-c/#ffi-functions-raising-errors", 
            "text": "FFI functions can raise Pony errors. Functions in existing C libraries are very unlikely to do this, but support libraries specifically written for use with Pony may well do.  FFI calls to functions that  might  raise an error  must  mark it as such by adding a ? after the arguments. For example:  @os_send[U64](_event, data.cstring(), data.size()) ? // May raise an error  If a signature declaration is used then that must be marked as possibly raising an error in the same way. The FFI call site then does not have to mark it as well, although doing so is allowed.  use @os_send[U64](ev: Event, buf: Pointer[U8] tag, len: U64) ?\n\n@os_send(_event, data.cstring(), data.size()) // May raise an error", 
            "title": "FFI functions raising errors"
        }, 
        {
            "location": "/c-ffi/linking-c/", 
            "text": "If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\n\n\nLinking to C libraries\n\n\nTo link an external library to Pony code another variant of the use command is used. The \"lib\" specifier is used to tell the compiler you want to link to a library. For example:\n\n\nuse \nlib:foo\n\n\n\n\n\nAs with other use commands a condition may be specified. This is particularly useful when the library has slightly different names on different platforms.\n\n\nHere's a real example from the standard library:\n\n\nuse \npath:/usr/local/opt/libressl/lib\n if osx\nuse \nlib:ssl\n if not windows\nuse \nlib:crypto\n if not windows\nuse \nlib:libssl-32\n if windows\nuse \nlib:libcrypto-32\n if windows\n\nprimitive _SSLInit\n  \n\n  This initialises SSL when the program begins.\n  \n\n  fun _init(env: Env) =\n\n    @SSL_load_error_strings[None]()\n    @SSL_library_init[I32]()\n\n\n\n\nOn Windows we use the libraries \"libssl-32\" and \"libcrypto-32\" and on other platforms we use \"ssl\" and \"crypto\". These contain the FFI functions SSL_library_init and SSL_load_error_strings (amongst others).\n\n\nBy default the Pony compiler will look for the libraries to link in the standard places, however that is defined on the build platform. However, it may be necessary to look in extra places. The \nuse \"path:...\"\n command allows this. The specified path is added to the library search paths for the remainder of the current file. The example above uses this to add the path \"/usr/local/opt/libressl/lib\" for OSX. This is required because the library is provided by brew, which installs things outside the standard library search paths.\n\n\nIf you are integrating with existing libraries, that is all you need to do.", 
            "title": "Linking to C Libraries"
        }, 
        {
            "location": "/c-ffi/linking-c/#linking-to-c-libraries", 
            "text": "To link an external library to Pony code another variant of the use command is used. The \"lib\" specifier is used to tell the compiler you want to link to a library. For example:  use  lib:foo   As with other use commands a condition may be specified. This is particularly useful when the library has slightly different names on different platforms.  Here's a real example from the standard library:  use  path:/usr/local/opt/libressl/lib  if osx\nuse  lib:ssl  if not windows\nuse  lib:crypto  if not windows\nuse  lib:libssl-32  if windows\nuse  lib:libcrypto-32  if windows\n\nprimitive _SSLInit\n   \n  This initialises SSL when the program begins.\n   \n  fun _init(env: Env) = \n    @SSL_load_error_strings[None]()\n    @SSL_library_init[I32]()  On Windows we use the libraries \"libssl-32\" and \"libcrypto-32\" and on other platforms we use \"ssl\" and \"crypto\". These contain the FFI functions SSL_library_init and SSL_load_error_strings (amongst others).  By default the Pony compiler will look for the libraries to link in the standard places, however that is defined on the build platform. However, it may be necessary to look in extra places. The  use \"path:...\"  command allows this. The specified path is added to the library search paths for the remainder of the current file. The example above uses this to add the path \"/usr/local/opt/libressl/lib\" for OSX. This is required because the library is provided by brew, which installs things outside the standard library search paths.  If you are integrating with existing libraries, that is all you need to do.", 
            "title": "Linking to C libraries"
        }, 
        {
            "location": "/c-ffi/c-abi/", 
            "text": "The FFI support in pony uses the C application binary interface (ABI) to\ninterface with native code. The C ABI is a calling convention, one of many,\nthat allow objects from different programming languages to be used together.\n\n\nWriting a C library for Pony\n\n\nWriting your own C library for use by Pony is almost as easy as using existing libraries.\n\n\nLet's look at a complete example of a C function we may wish to provide to Pony. A Jump Consistent Hash, for example, could be provided in pure Pony as follows:\n\n\n// Jump consistent hashing in pony, with an inline pseudo random generator\n\nfun jch(key: U64, buckets: I64): I32 =\n\n  var k = key\n  var b = I64(0)\n  var j = I64(0)\n\n  while j \n buckets do\n    b = j\n    k = (k * 2862933555777941757) + 1\n    j = ((b + 1).f64() * (U32(1 \n 31).f64() / ((key \n 33) + 1).f64())).i64()\n  end\n\n  b.i32()\n\n\n\n\nLet's say we wish to compare the pure Pony performance to an existing C function with the following header:\n\n\n#ifndef __JCH_H_\n#define __JCH_H_\n\nextern \nC\n\n{\n  int32_t jch_chash(uint64_t key, uint32_t num_buckets);\n}\n\n#endif\n\n\n\n\nNote the use of \nextern \"C\"\n. If the library is built as C++ then we need to tell the compiler not to mangle the function name, otherwise Pony won't be able to find it. For libraries built as C this is not needed, of course.\n\n\nThe implemented would be something like:\n\n\n#include \nstdint.h\n\n#include \nlimits.h\n\n#include \nmath.h\n\n\n// A reasonably fast, good period, low memory use, xorshift64* based prng\ndouble lcg_next(uint64_t* x)\n{\n  *x ^= *x \n 12;\n  *x ^= *x \n 25;\n  *x ^= *x \n 27;\n  return (double)(*x * 2685821657736338717LL) / ULONG_MAX;\n}\n\n// Jump consistent hash\nint32_t jch_chash(uint64_t key, uint32_t num_buckets)\n{\n  uint64_t seed = key;\n  int b = -1;\n  int32_t j = 0;\n\n  do {\n    b = j;\n    double r = lcg_next(\nseed);\n    j = floor((b + 1)/r);\n  } while(j \n num_buckets);\n\n  return (int32_t)b;\n}\n\n\n\n\nWe need to compile the native code to a shared library. This example is for OSX. The exact details may vary on other platforms.\n\n\nclang++ -fPIC -Wall -Wextra -O3 -g -MM jch.c \njch.d\nclang++ -fPIC -Wall -Wextra -O3 -g   -c -o jch.o jch.c\nclang++ -shared -lm -o libjch.dylib jch.o\n\n\n\n\nThe Pony code to use this new C library is just like the code we've already seen for using C libraries.\n\n\n This is an example of pony integrating with native code via the builtin FFI support \n\n\nuse \nlib:jch\n\nuse \ncollections\n\nuse \nrandom\n\nuse @jch_chash[I32](hash: U64, bucket_size: U32)\n\nactor Main\n  var _env: Env\n\n  new create(env: Env) =\n\n    _env = env\n\n    let bucket_size: U32 = 1000000\n    var random = MT\n\n    for i in Range[U64](1, 20) do\n        let r: U64 = random.next()\n        let hash = @jch_chash(i, bucket_size)\n        _env.out.print(i.string() + \n: \n + hash.string())\n    end\n\n\n\n\nWe can now use ponyc to compile a native executable integrating pony and our C library. And that's all we need to do.", 
            "title": "C abi"
        }, 
        {
            "location": "/c-ffi/c-abi/#writing-a-c-library-for-pony", 
            "text": "Writing your own C library for use by Pony is almost as easy as using existing libraries.  Let's look at a complete example of a C function we may wish to provide to Pony. A Jump Consistent Hash, for example, could be provided in pure Pony as follows:  // Jump consistent hashing in pony, with an inline pseudo random generator\n\nfun jch(key: U64, buckets: I64): I32 = \n  var k = key\n  var b = I64(0)\n  var j = I64(0)\n\n  while j   buckets do\n    b = j\n    k = (k * 2862933555777941757) + 1\n    j = ((b + 1).f64() * (U32(1   31).f64() / ((key   33) + 1).f64())).i64()\n  end\n\n  b.i32()  Let's say we wish to compare the pure Pony performance to an existing C function with the following header:  #ifndef __JCH_H_\n#define __JCH_H_\n\nextern  C \n{\n  int32_t jch_chash(uint64_t key, uint32_t num_buckets);\n}\n\n#endif  Note the use of  extern \"C\" . If the library is built as C++ then we need to tell the compiler not to mangle the function name, otherwise Pony won't be able to find it. For libraries built as C this is not needed, of course.  The implemented would be something like:  #include  stdint.h \n#include  limits.h \n#include  math.h \n\n// A reasonably fast, good period, low memory use, xorshift64* based prng\ndouble lcg_next(uint64_t* x)\n{\n  *x ^= *x   12;\n  *x ^= *x   25;\n  *x ^= *x   27;\n  return (double)(*x * 2685821657736338717LL) / ULONG_MAX;\n}\n\n// Jump consistent hash\nint32_t jch_chash(uint64_t key, uint32_t num_buckets)\n{\n  uint64_t seed = key;\n  int b = -1;\n  int32_t j = 0;\n\n  do {\n    b = j;\n    double r = lcg_next( seed);\n    j = floor((b + 1)/r);\n  } while(j   num_buckets);\n\n  return (int32_t)b;\n}  We need to compile the native code to a shared library. This example is for OSX. The exact details may vary on other platforms.  clang++ -fPIC -Wall -Wextra -O3 -g -MM jch.c  jch.d\nclang++ -fPIC -Wall -Wextra -O3 -g   -c -o jch.o jch.c\nclang++ -shared -lm -o libjch.dylib jch.o  The Pony code to use this new C library is just like the code we've already seen for using C libraries.   This is an example of pony integrating with native code via the builtin FFI support  \n\nuse  lib:jch \nuse  collections \nuse  random \nuse @jch_chash[I32](hash: U64, bucket_size: U32)\n\nactor Main\n  var _env: Env\n\n  new create(env: Env) = \n    _env = env\n\n    let bucket_size: U32 = 1000000\n    var random = MT\n\n    for i in Range[U64](1, 20) do\n        let r: U64 = random.next()\n        let hash = @jch_chash(i, bucket_size)\n        _env.out.print(i.string() +  :   + hash.string())\n    end  We can now use ponyc to compile a native executable integrating pony and our C library. And that's all we need to do.", 
            "title": "Writing a C library for Pony"
        }, 
        {
            "location": "/runtime/otp/", 
            "text": "Pony/OTP\n\n\nThe most successful actor based programming language is \nErlang/OTP\n.\n\n\nOTP in a nutshell:\n\n\n\n\ngen_server\n \n \ngen_nb_server\n ~ A pony actor\n\n\ngen_event\n - Easy to implement\n\n\ngen_fsm\n - In progress\n\n\ngen_supervisor\n - Harder to implement ( needs monitors, links - feature planned )\n\n\ndistributed multinode erlang - Already being actively researched ( A String of Ponies )\n\n\napplications ~ a binary\n\n\nlibraries ~ a pony package or shared library\n\n\n\n\nGenEvent\n\n\nAn actor that will:\n\n\n\n\nRegister one or many handlers\n\n\nPush events to all registered handlers\n\n\n\n\ninterface GenEventHandler[T : Any #send]\n  fun box name() : String\n  be handle(data : T!)\n\n\n\n\nactor GenEvent[T: Any #send]\n  var subscribers : List[GenEventHandler[T] iso!]\n\n  new create() =\n\n    subscribers = List[GenEventHandler[T] iso!]\n\n  be subscribe(handler : GenEventHandler[T] tag) =\n\n    subscribers = subscribers.push(consume handler)\n\n  be push(data : T!) =\n\n    for subscriber in subscribers.values() do\n        let data' = data\n        subscriber.handle(consume data')\n    end\n\n\n\n\nA simple debug handler\n\n\nactor StringEventHandler is GenEventHandler[String]\n  let _name : String\n  new create( name' : String ) =\n\n    _name = name'\n  fun box name() : String =\n\n    _name\n  be handle(data : String ) =\n\n    Debug.out(\nString: \n + data + \n received by handler \n + name())\n\n\n\n\nOTP\n\n\nactor Main\n  let gen_event : GenEvent[String]\n\n  new create(env : Env) =\n\n    gen_event = GenEvent[String]\n    let foo = StringEventHandler(\nfoo\n)\n    let baz : Stringable = Foo(\nbar\n)\n    gen_event.subscribe(foo)\n    let x = \nhello world 4 \n + baz.string()\n    gen_event.push(\nHello Pony World 1!\n)\n      .push(\nHello Pony World 2!\n)\n      .push(x)\n      .push(baz.string())", 
            "title": "Otp"
        }, 
        {
            "location": "/runtime/otp/#ponyotp", 
            "text": "The most successful actor based programming language is  Erlang/OTP .  OTP in a nutshell:   gen_server     gen_nb_server  ~ A pony actor  gen_event  - Easy to implement  gen_fsm  - In progress  gen_supervisor  - Harder to implement ( needs monitors, links - feature planned )  distributed multinode erlang - Already being actively researched ( A String of Ponies )  applications ~ a binary  libraries ~ a pony package or shared library", 
            "title": "Pony/OTP"
        }, 
        {
            "location": "/runtime/otp/#genevent", 
            "text": "An actor that will:   Register one or many handlers  Push events to all registered handlers   interface GenEventHandler[T : Any #send]\n  fun box name() : String\n  be handle(data : T!)  actor GenEvent[T: Any #send]\n  var subscribers : List[GenEventHandler[T] iso!]\n\n  new create() = \n    subscribers = List[GenEventHandler[T] iso!]\n\n  be subscribe(handler : GenEventHandler[T] tag) = \n    subscribers = subscribers.push(consume handler)\n\n  be push(data : T!) = \n    for subscriber in subscribers.values() do\n        let data' = data\n        subscriber.handle(consume data')\n    end  A simple debug handler  actor StringEventHandler is GenEventHandler[String]\n  let _name : String\n  new create( name' : String ) = \n    _name = name'\n  fun box name() : String = \n    _name\n  be handle(data : String ) = \n    Debug.out( String:   + data +   received by handler   + name())", 
            "title": "GenEvent"
        }, 
        {
            "location": "/runtime/otp/#otp", 
            "text": "actor Main\n  let gen_event : GenEvent[String]\n\n  new create(env : Env) = \n    gen_event = GenEvent[String]\n    let foo = StringEventHandler( foo )\n    let baz : Stringable = Foo( bar )\n    gen_event.subscribe(foo)\n    let x =  hello world 4   + baz.string()\n    gen_event.push( Hello Pony World 1! )\n      .push( Hello Pony World 2! )\n      .push(x)\n      .push(baz.string())", 
            "title": "OTP"
        }, 
        {
            "location": "/runtime/memory-allocation/", 
            "text": "Memory allocation at runtime\n\n\nPony is NULL-free, type-safe language, with no dangling pointers, no\nbuffer overruns, but with a \nvery fast garbage collector\n, so you\ndon't have to worry about explicit memory allocation, if on the heap\nor stack, if in a threaded actor, or not.\n\n\nFast, Safe and Cheap\n\n\n\n\nAn actor has ~240 bytes of memory overhead.\n\n\nNo locks. No context switches. All mutation is local\n\n\nAn idle actor consumes no resources ( other than memory )\n\n\nYou can have millions of actors at the same time\n\n\n\n\nBut Caveat Emptor\n\n\nBut pony can be used to create \nC libraries\n and pony can use\nexternal C libraries via the \nFFI\n which does not have this luxury,\n\n\nSo you \ncan\n use any external C library out there, but the question is if\nyou \nneed to\n and if you \nshould\n.\n\n\nThe biggest problem is external heap memory, created by an external\nFFI call, or created to support an external call. But external stack\nspace might also need some thoughts, esp. when being created from\nactors.\n\n\nPony has no \nfinalizers\n, callbacks which are called by the garbage\ncollector to free external memory, which was allocated by a FFI call.\nThe garbage collector is \nnot timely\n (as with pure reference\ncounting), it is not triggered immediately when some object goes out\nof scope.\n\n\nA blocked actor will keep it's memory allocated, only a dead actor\nwill release it eventually.\n\n\nAnd, long-running actors\n\n\nmight cause unexpected out of memory errors, since the GC is not yet triggered on an\nout-of-memory segfault or stack exhaustion.\n\n\n...", 
            "title": "Memory allocation"
        }, 
        {
            "location": "/runtime/memory-allocation/#memory-allocation-at-runtime", 
            "text": "Pony is NULL-free, type-safe language, with no dangling pointers, no\nbuffer overruns, but with a  very fast garbage collector , so you\ndon't have to worry about explicit memory allocation, if on the heap\nor stack, if in a threaded actor, or not.", 
            "title": "Memory allocation at runtime"
        }, 
        {
            "location": "/runtime/memory-allocation/#fast-safe-and-cheap", 
            "text": "An actor has ~240 bytes of memory overhead.  No locks. No context switches. All mutation is local  An idle actor consumes no resources ( other than memory )  You can have millions of actors at the same time", 
            "title": "Fast, Safe and Cheap"
        }, 
        {
            "location": "/runtime/memory-allocation/#but-caveat-emptor", 
            "text": "But pony can be used to create  C libraries  and pony can use\nexternal C libraries via the  FFI  which does not have this luxury,  So you  can  use any external C library out there, but the question is if\nyou  need to  and if you  should .  The biggest problem is external heap memory, created by an external\nFFI call, or created to support an external call. But external stack\nspace might also need some thoughts, esp. when being created from\nactors.  Pony has no  finalizers , callbacks which are called by the garbage\ncollector to free external memory, which was allocated by a FFI call.\nThe garbage collector is  not timely  (as with pure reference\ncounting), it is not triggered immediately when some object goes out\nof scope.  A blocked actor will keep it's memory allocated, only a dead actor\nwill release it eventually.", 
            "title": "But Caveat Emptor"
        }, 
        {
            "location": "/runtime/memory-allocation/#and-long-running-actors", 
            "text": "might cause unexpected out of memory errors, since the GC is not yet triggered on an\nout-of-memory segfault or stack exhaustion.  ...", 
            "title": "And, long-running actors"
        }, 
        {
            "location": "/runtime/garbage-collection/", 
            "text": "Garbage collection with Pony-ORCA\n\n\nPony-ORCA is a fully concurrent protocol for garbage collection in the\nactor paradigm. It allows cheap and small actors to perform garbage\ncollection concurrently with any number of other actors, and this\nnumber can go into the millions, since one actor needs only 256 bytes\non 64bit systems. It does not require any form of synchronization\nacross actors except those introduced through the actor paradigm,\ni.e. \nmessage send\n and \nmessage receive\n.\n\n\nPony-ORCA, yes \nthe killer whale\n, is based on ideas from ownership\nand deferred, distributed, weighted \nreference counting\n. It adapts\nmessaging systems of actors to keep the reference count\nconsistent. The main challenges in concurrent garbage collection is\nthe detection of cycles of sleeping actors in the actors graph, in the\npresence of concurrent mutation of this graph. With message passing\nyou get deferred direct reference counting, a dedicated actor for the\ndetection of (cyclic) garbage, and a confirmation protocol (to deal\nwith the mutation of the actor graph).\n\n\n\n\n\n\nSoundness\n: the technique collects only dead actors.\n\n\n\n\n\n\nCompleteness\n: the technique collects all dead actors eventually.\n\n\n\n\n\n\nConcurrency\n: the technique does not require a stop-the-world\n   step, clocks, timestamps, versioning, thread coordination, actor\n   introspection, shared memory, read/write barriers or cache\n   coherency.\n\n\n\n\n\n\nThe type system ensures at compile time that your program can \nnever have data races\n.\nIt's \ndeadlock free\n... Because Pony has \nno locks\n!\n\n\nWhen an actor has completed local execution and has no pending\nmessages on its queue, it is \nblocked\n. An actor is \ndead\n, if it is\nblocked and all actors that have a reference to it are blocked,\ntransitively. Collection of dead actors depends on being able to\ncollect closed cycles of blocked actors.\n\n\nThe Pony type system guarantees soundness and race and dead-lock\nfree concurrency by adhering to the following principles:\n\n\nPony-ORCA characteristics\n\n\n\n\n\n\nAn actor may perform garbage collection concurrently other actors\n   while they are executing and kind of behaviour.\n\n\n\n\n\n\nAn actor may decide whether to garbage collect an object solely\n   based on its own local state, without consultation with, or\n   inspecting the state of any other actor.\n\n\n\n\n\n\nNo synchronization between actors is required during garbage\n   collection, other than potential message sends.\n\n\n\n\n\n\nAn actor may garbage collect between its normal behaviours, i.e. it\n   need not wait untils its message queue is empty.\n\n\n\n\n\n\nPony-ORCA can be applied to several other programming languages,\n   provided that the satisfy the following two requirements:\n\n\n\n\n\n\nActor behaviours are atomic\n.\n\n\n\n\n\n\nMessage delivery is casual\n - i.e. messages arrive before any\n  messages they may have caused, if they have the same destination. So\n  there needs to be some kind of casual ordering guarantee, but less\n  requirements than with comparable concurrent, fast garbage\n  collectors.", 
            "title": "Garbage collection"
        }, 
        {
            "location": "/runtime/garbage-collection/#garbage-collection-with-pony-orca", 
            "text": "Pony-ORCA is a fully concurrent protocol for garbage collection in the\nactor paradigm. It allows cheap and small actors to perform garbage\ncollection concurrently with any number of other actors, and this\nnumber can go into the millions, since one actor needs only 256 bytes\non 64bit systems. It does not require any form of synchronization\nacross actors except those introduced through the actor paradigm,\ni.e.  message send  and  message receive .  Pony-ORCA, yes  the killer whale , is based on ideas from ownership\nand deferred, distributed, weighted  reference counting . It adapts\nmessaging systems of actors to keep the reference count\nconsistent. The main challenges in concurrent garbage collection is\nthe detection of cycles of sleeping actors in the actors graph, in the\npresence of concurrent mutation of this graph. With message passing\nyou get deferred direct reference counting, a dedicated actor for the\ndetection of (cyclic) garbage, and a confirmation protocol (to deal\nwith the mutation of the actor graph).    Soundness : the technique collects only dead actors.    Completeness : the technique collects all dead actors eventually.    Concurrency : the technique does not require a stop-the-world\n   step, clocks, timestamps, versioning, thread coordination, actor\n   introspection, shared memory, read/write barriers or cache\n   coherency.    The type system ensures at compile time that your program can  never have data races .\nIt's  deadlock free ... Because Pony has  no locks !  When an actor has completed local execution and has no pending\nmessages on its queue, it is  blocked . An actor is  dead , if it is\nblocked and all actors that have a reference to it are blocked,\ntransitively. Collection of dead actors depends on being able to\ncollect closed cycles of blocked actors.  The Pony type system guarantees soundness and race and dead-lock\nfree concurrency by adhering to the following principles:", 
            "title": "Garbage collection with Pony-ORCA"
        }, 
        {
            "location": "/runtime/garbage-collection/#pony-orca-characteristics", 
            "text": "An actor may perform garbage collection concurrently other actors\n   while they are executing and kind of behaviour.    An actor may decide whether to garbage collect an object solely\n   based on its own local state, without consultation with, or\n   inspecting the state of any other actor.    No synchronization between actors is required during garbage\n   collection, other than potential message sends.    An actor may garbage collect between its normal behaviours, i.e. it\n   need not wait untils its message queue is empty.    Pony-ORCA can be applied to several other programming languages,\n   provided that the satisfy the following two requirements:    Actor behaviours are atomic .    Message delivery is casual  - i.e. messages arrive before any\n  messages they may have caused, if they have the same destination. So\n  there needs to be some kind of casual ordering guarantee, but less\n  requirements than with comparable concurrent, fast garbage\n  collectors.", 
            "title": "Pony-ORCA characteristics"
        }, 
        {
            "location": "/examples/examples/", 
            "text": "Enum with values\n\n\nprimitive Black fun apply(): U32 =\n 0xFF000000\nprimitive Red   fun apply(): U32 =\n 0xFFFF0000\n\n\n\n\nEnum with values with namespace\n\n\nprimitive Colours\n  fun black(): U32 =\n 0xFF000000\n  fun red(): U32 =\n 0xFFFF0000\n\n\n\n\nEnum which can be iterated\n\n\nprimitive Black\nprimitive Blue\nprimitive Red\nprimitive Yellow\n\ntype Colour is (Black | Blue | Red | Yellow)\n\nprimitive ColourList\n  fun tag apply(): Array[Colour] =\n\n    [Black, Blue, Red, Yellow]\n\nfor colour in ColourList().values() do\nend\n\n\n\n\nRead Struct values from FFI\n\n\nIf you have a C struct which returns a struct with data like this\n\n\ntypedef struct {\n  uint8_t code;\n  float x;\n  float y;\n} EGLEvent;\n\nEGLEvent getEvent() {\n    EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height};\n    return e;\n}\n\n\n\n\n\nthe you can destructure it and get the values using a tuple\n\n\ntype EGLEvent is (U8, F32, F32)\n(var code, var x, var y) = @getEvent[EGLEvent]()\n\n\n\n\nGet and Pass Pointers to FFI\n\n\nprimitive _XDisplayHandle\nprimitive _EGLDisplayHandle\n\nlet x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0))\nif x_dpy.is_null() then\n  env.out.print(\nXOpenDisplay failed\n)\nend\n\nlet e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy)\nif e_dpy.is_null() then\n  env.out.print(\neglGetDisplay failed\n)\nend\n\n\n\n\nPass an Array of values to FFI (TODO)\n\n\nprimitive _EGLConfigHandle\nlet a = Array[U16](8)\na.push(0x3040)\na.push(0x4)\na.push(0x3033)\na.push(0x4)\na.push(0x3022)\na.push(0x8)\na.push(0x3023)\na.push(0x8)\na.push(0x3024)\nlet config = Pointer[_EGLConfigHandle]\nif @eglChooseConfig[U32](e_dpy, a, config, U32(1), Pointer[U32]) == 0 then\n    env.out.print(\neglChooseConfig failed\n)\nend\n\n\n\n\nHow to use enviroment variables\n\n\nactor Main\n\n  new create(env: Env) =\n\n    env.out.print(env.args.size().string()) // The no of arguments\n    for value in env.args.values() do\n      env.out.print(value)\n    end\n    try env.out.print(env.args(0)) end // Access the arguments the first one will always be the the appication name\n\n\n\n\nHow to use options\n\n\nactor Main\n\n  new create(env: Env) =\n\n    var options = Options(env)\n\n    options\n      .add(\noutput\n, \no\n, StringArgument)\n\n    env.out.print(options.has_argument())\n\n    for option in options do\n      match option\n      | (\noutput\n, var arg: String) =\n _outputFileName = arg.string()\n      | let err: ParseError =\n\n          err.report(env.out)\n          env.out.print(\n            \n\n            pony-embed [OPTIONS]\n              --output     name   string output filename.\n            \n\n          )\n      end\n    end\n\n\n\n\n\nHow to write tests\n\n\nJust create a test.pony file\n\n\nuse \nponytest\n\n\nactor Main is TestList\n  new create(env: Env) =\n PonyTest(env, this)\n  new make() =\n None\n\n  fun tag tests(test: PonyTest) =\n\n    test(_TestAddition)\n\nclass iso _TestAddition is UnitTest\n  \n\n  Adding 2 numbers\n  \n\n  fun name(): String =\n \nu32/add\n\n\n  fun apply(h: TestHelper): TestResult =\n\n    h.expect_eq[U32](2 + 2, 4)\n\n\n\n\nSome assertions you can make with the TestHelper are\n\n\nfun tag log(msg: String, verbose: Bool = false)\nbe fail() =\n\nbe assert_failed(msg: String) =\n\nfun tag assert_true(actual: Bool, msg: String = \n) ?\nfun tag expect_true(actual: Bool, msg: String = \n): Bool\nfun tag assert_false(actual: Bool, msg: String = \n) ? \nfun tag expect_false(actual: Bool, msg: String = \n): Bool\nfun tag assert_error(test: ITest, msg: String = \n) ?\nfun tag expect_error(test: ITest box, msg: String = \n): Bool\nfun tag assert_is (expect: Any, actual: Any, msg: String = \n) ?\nfun tag expect_is (expect: Any, actual: Any, msg: String = \n): Bool\nfun tag assert_eq[A: (Equatable[A] #read \n Stringable)] (expect: A, actual: A, msg: String = \n) ?\nfun tag expect_eq[A: (Equatable[A] #read \n Stringable)] (expect: A, actual: A, msg: String = \n): Bool\n\n\n\n\nOperator Overloading (easy for copy and paste)\n\n\nfun add(other: A): A\nfun sub(other: A): A\nfun mul(other: A): A\nfun div(other: A): A\nfun mod(other: A): A\nfun eq(other: A): Bool\nfun ne(other: A): Bool\nfun lt(other: A): Bool\nfun le(other: A): Bool\nfun ge(other: A): Bool\nfun gt(other: A): Bool\nfun shl(other: A): A\nfun shr(other: A): A\nfun op_and(other:A): A\nfun op_or(other: A): A\nfun op_xor(othr: A): A\n\n\n\n\nCreate empty functions in a class\n\n\nclass Test\n  fun alpha() =\n\n      \n\n      \n\n  fun beta() =\n\n      \n\n      \n\n\n\n\n\nHow to Delegate objects\n\n\ntrait TAnimal\n  fun talk(): String\n\nclass Cat is TAnimal\n  fun talk(): String =\n\n    \nMeow\n\n\nclass CatToy is TAnimal\n  let _cat: Cat delegate TAnimal = Cat\n\nlet animals: Array[TAnimal] = Array[TAnimal]\nanimals.push(Cat.create())\nanimals.push(CatToy.create())\n\nfor animal in animals.values() do\n  env.out.print(animal.talk())\nend\n\n\n\n\nHow to create Arrays with values\n\n\nlet dice: Array[U32] = [1, 2, 3, 4, 5, 6]", 
            "title": "Examples"
        }
    ]
}